%=========================================================================

\chapter{Úvod}
\input{introduction}

\chapter{Ha¹ování}
\label{sec:hashing}
Ha¹ovací tabulky jsou dùle¾itou souèástí moderního svìta informaèních 
technologíí. Jsou to vyhledávací datové struktury, které nám za urèitıch
okolností umo¾ní vyhledávat, vkládat a mazat ulo¾ené polo¾ky s konstantní
èasovou slo¾itostí. Jedná se o jednu z nìkolika mo¾nıch implementací
asociativního pole. Ty dal¹í jsou napøíklad stromové implementace, 
implementace vázanım seznamem s lineáním prùchodem a dal¹í. ®ádnımi
z tìchto implementací se zde zabıvat nebudeme \cite{art_of_programming}.

\section{Princip}
Mìjme dané univerzum klíèù $U$, kde nìkteré klíèe $k \in U$ si pøejeme
asociovat s nìjakımi satelitnímy daty $v$, jejich¾ povaha není pro nás v
tuto chvíli dùle¾itá. Dále máme dynamickou mno¾inu $S = \{(k,v) | k \in u\}$
uchovávající klíèe s jejich satelitními daty. Pak nad mno¾inou $S$ chceme
pro nìjakı klíè $k$ a nìkteré její polo¾ky $x=(k, v)$ provádìt následující 
operace: 

\begin{enumerate}
	\item \textit{vkládání} dat, tedy operaci 
		$Insert(S,x) : S \to S \cup \{(k, v)\} $,

	\item \textit{mazání} dat, tedy operaci 
		$Delete(S,x) : S \to S - \{(k, v)\}$

	\item \textit{vıhledávání} satelitních dat podle zadaného klíèe,
		tedy operaci \newline $Search(S,k) : 
			\begin{cases}
				x 	: x.k = k \\
				nil : jinak 
			\end{cases} $
\end{enumerate}

Operace vyhledávání není totální, musíme tedy explicitnì vhodnì o¹etøit
pøípady, kdy se prvek $x=(k,v)$ v tabulce nevyskytuje.

Nejjedodu¹¹í implementací je \textit{tabulka s pøímım pøístupem} za
pøedpokladù, ¾e $|U|$ je pøijatelná. Uva¾me napøíklad univerzum
klíèu $U = \{0,1,2,3,\ldots,m-1\}$, a tabulku $T$ reprezentující
dynamickou mno¾inu $S$, pak nejjednodu¹¹ím pøístupem je pou¾ít jako
klíèe pøímo prvky mno¾iny $U$. Pak operace vyhledávání je rovna operaci
pøístupu do tabulky na zadanou lokaci, napøíklad $Search(T,k) = T[k]$
pro nìjakı klíè $k \in U$.

Mù¾e v¹ak nastat pøípad, kdy $m$ bude pøíi¹ velké èíslo. Typickım pøíkladem
jsou klíèe mno¾iny v¹ech mo¾nıch øetìzcù. Pak by tabulka s pøímım pøístupem
byla pøíli¹ velká a nevhodná pro moderní poèítaèe. Pokud potøebujeme 
vyhledávat pouze v nìjaké podmno¾inì $K \subset U$, kde $|K| << |U|$, je 
vhodné pou¾ít ha¹ovací funkci. Zjevnou vıhodou tabulek s pøímım pøistupem je slo¾itost
, která je $\theta (1)$ v nejhor¹ím pøípadì. Nevıhodou je pamì»ová nároènost
pro velká univerza $U$, kdy velká èást tabulky zùstane prázdná.

\subsection{Ha¹ovací funkce}
Ha¹ovací funkce je je zobrazení, mapující prvky mno¾iny $U$ na jednotlivé 
sloty (indexy) tabulky $T$ :
$$ f_{hash} : U \to (0,1,\ldots,m-1)$$
za pøedpokladu, ¾e tabulka má právì $m-1$ slotù. Vyhledávací struktura 
slo¾ená z dynamické mno¾iny $S$ reprezentovanou tabulkou $T$ a ha¹ovací 
funkcí $f_{hash}$ se nazıvá \textit{ha¹ovací tabulka} 
viz. \ref{fig:hash_table_example}.

%%%%%%%%%%%%% HASH TABLE EXAMPLE %%%%%%%%%%%%%%%
\begin{figure}[!ht]
	\centering
	\includegraphics[scale=0.6]{fig/hash_table_example}	
	\caption{Princip fungování ha¹ovacích tabulek}
	\label{fig:hash_table_example}
\end{figure}
%%%%%%%%%%%%% HASH TABLE EXAMPLE %%%%%%%%%%%%%%%
 
Vzhledem k tomu, ¾e velikost tabulky je men¹í, ne¾ velikost univerza $|U|$,
budou nastávat kolize. Kolize je pøípad kdy, dva rùzné prvky univerza
$k_{1}, k_{2} \in U$ budou zobrazeny na stejnı slot : 
$f_{hash} (k_{1}) = f_{hash} (k_{2})$. S tímto neduhem se dá vypoøádat mnoha 
zpùsoby, ale pro na¹e úèely postaèí zøetìzení prvkù ve slotu do listu.
Èasová slo¾itost takové implementace je :
\begin{itemize}
	\item v nejhor¹ím pøípadì $\theta (n)$, kdy v¹echny prvky budou namapovány
		na jeden slot,
	\item v prùmìru bude $\theta (1 + \alpha)$, za pøedpokladu
		uniformního rozlo¾ení, kdy pravdìpodobnost namapování libovolbného
		prvku na konkrétní slot je $\frac{1}{m}$ a
\end{itemize}

$\alpha$ je takzvanı \textit{faktor zatí¾ení} definovanı vztahem $\alpha = \frac{n}{m}$.
Èasová slo¾itost tabulky zále¾í za pøedpokladu uniformního rozlo¾ení 
ha¹ovací funkce na \textit{faktoru zatí¾ení}. 

\section{Kritéria kvality ha¹ovacích funkcí}

Shròme si nyní základní kritéria, která jsou dùle¾iá pro ha¹ovací funkce.

\subsection{Uniformní rozlo¾ení vıstupù}

Pro dokonalé uniformní rozlo¾ení ha¹ovací funkce bychom potøebovali \textit{náhodnı}
generátor a i kdybychom nìjakı mìli k dispozici, pak by sice dobøe dokázal 
rozprostøít jednotlivé prvky do ha¹ovací tabulky, nicménì vzhledem k jeho náhodné 
povaze bychom je jen tì¾ko zpìt dohledávali. Musíme tedy zvolit jinou 
alternativu. Ha¹ovací funkce musí bıt deterministická a musí dobøe aproximovat
uniformní rozlo¾ení. Uniformní rozlo¾ení vıstupù je pøedpokladem pro
nízkou èasovou slo¾itost ha¹ovacích algoritmù, jak je vidìt z pøíkladu
v sekci \ref{se:hash_function_design}.

\subsection{Odolnost proti kolizím}

Uva¾ujeme-li uniformní rozlo¾ení ha¹ovací funkce, pak dva klíèe u univerza
$U$ budou kolizní (dle \textit{birthday attack}) asi po $2^{\frac{m}{2}}$ 
operacích vlo¾ení\cite{NCHF_auto_design}. Pokud v¹ak ha¹ovací funkce nebude
uniformì distribuovat vısledky, pravdìpodobnost kolize se rapidnì zvı¹í.

\subsection{Lavinovı efekt}

Lavinovı efekt (angl. Avalanche effect) je vlastnost ha¹ovací funkce, pøi
které se rapidnì mìní vıstup ha¹ovací funkce pro malou zmìnu vstupu. 
Funkce které mají vysokı lavinovı efekt mohou odolávat problému shlukování,
pøi kterém se nìkteré èásti univerza mají tendenci shlukovat na vıstupu
do skupin.

\subsection{Rychlost}

Nesporná vıhoda ha¹ovacích tabulek je jejich rychlost. Dobøe navr¾ená ha¹ovací
tabulka dosahuje za urèitıch okolností slo¾itosti $\theta (1)$. Pokud je v¹ak
vıpoèetní algoritmus pøíli¹ slo¾itı, mù¾e daná funkce bıt pomalá. Je proto
nutné dbát na to, ¾e pøíli¹ pomalı, i kdy¾ dobrı algoritmus nemusí bıt
v¾dy ten nejlep¹í. 

\section{Návrh ha¹ovací funkce}
\label{se:hash_function_design}

V praxi je èasto sly¹et názor, ¾e ha¹ovací funkce pracují v konstantním èase.
To v¹ak není pravda, nebo» vıkon ha¹ovací funkce zále¾í jednak na faktoru
zatí¾ení ha¹ovací tabulky a uniformnosti, s jakou doká¾e ha¹ovací funkce
pøíøazovat klíèe do slotù.

Zamìøme se nejprve na zatí¾ení tabulky a uva¾me nìjakou podmno¾inu univerza
v¹ech klíèù $K \in U$, ha¹ovací tabulku $T$ s $m$ sloty a oznaème $n = |K|$.
Pokud $n$ bude men¹í ne¾ $m$, pak ha¹ovací tabulka bude skuteènì pracovat v 
$\theta (1)$, za pøedpokladu uniformního rozlo¾ení ha¹ovací funkce. Pokud ale
bude $m$ men¹í ne¾ $n$, faktor zatí¾ení bude vìt¹í ne¾ jedna a ha¹ovací tabulka
v konstantním èase pracovat nebude. Uva¾me $m=4$ a $n=5$. Pak za pøedpokladu
uniformního rozlo¾ení ha¹ovací funkce, s vlo¾ením pátého prvku bude ha¹ovací 
tabulka plná a nám nezbude ne¾ vkládanı prvek zaøadit na zaèátek jednosmìrnì
vázaného seznamu.

Existuje mnoho metod pro konstrukci ha¹ovací funkce, jako jsou napøíklad
\textit{metoda násobení}, \textit{metoda dìlení} a dal¹í komplikovanìj¹í
pøístupy. V souèasné dobì existují velmi dobré implementace obecnıch ha¹ovacích funkcí.
Av¹ak ¾ádná ha¹ovací funkce nemù¾e pracovat pro v¹echna mo¾ná univerza stejnì
dobøe. Jako pøíklad uva¾ujme ha¹ovací funkci navr¾enou metodou dìlení :
$$ f_{hash}(k) = k \text{ mod } 8 $$ 
a dále uva¾ujme univerzum $U = \mathbb{N}$ a jeho
podmno¾inu $K = \{1,2,3,4,8,13,22,71\}$, kterou budeme vkládat do tabulky.
Ha¹ovací funkce je schopna ulo¾it $8$ ruznıch hodnot a v pøípadì 
na¹eho vıbìru mno¾iny $K$, se nám podaøí ulo¾it v¹echny, ani¾ by do¹lo ke kolizi.
Co by se ale stalo, pokud bychom byli omezení na univerzum pouze tìch
pøirozenıch èisel, která jsou dìlitelné osmi $U = \{x \in \mathbb{N}
\land x \text{ mod } 8 = 0\}$? Nemohli bychom vybrat ¾ádnou podmno¾inu 
$F \in U$ takovou, kterou by funkce $f_{hash}$ nezobrazila pouze na jeden
slot.

Je vidìt, ¾e pokud máme informace o univerzu mo¾nıch klíèù, mù¾eme navrhnout
ha¹ovací funkci 'na míru' tak, aby mìla lep¹í vlastnosti, ne¾ obecná 
ha¹ovací funkce. Tento úkol je v¹ak obtí¾nı a neexistuj pro nìj obecnı
návod jak toho docílit. Musíme se spolehnout na zku¹enosti, znalosti a v 
neposlední øadì také na intuici. Nebo mù¾eme zvolit úplnì jinı pøístup
jak napovídá kapitola \ref{sec:evolution_design}.

\chapter{Evoluèní návrh}
\label{sec:evolution_design}

% Chapter INTRO
Evoluèní návrh je netradièní disciplína, která vyu¾ívá evoluèní algoritmy
k návrhu. Evoluèní algoritmy spadají do oblasti umìlé 
inteligence. Specifickou vlastností mnoha úloh spadajících do obasti umìlé 
inteligence je, ¾e èasto vhodnım zpùsobem prohledávají prostor $U$,
reprezentující v¹echna mo¾ná øe¹ení (kandidátní) dané úlohy 
\cite{evolution_hardware}. Evoluèní algoritmy se dají pova¾ovat za speciální metodou 
prohledávání prostoru kandidátních øe¹ení.

% Section Natural computing
\section{Poèítání podle pøírody}
\label{sec:natural_computing}
Poèítání podle pøírody (Natural computing) je sohrnı termín pro tvorbu 
inteligentních strojù napodobováním biologickıch procesù, chování ¾ivıch 
tvorù nebo jejich mechanismù. Øadíme sem také vıpoèetní paradigmata, která 
svoji inspiraci nalezla v pøírodních procesech nebo pou¾ití organismù a 
jinıch netradièních materiálù jako vıpoèetních platforem. Míra do jaké je 
pøírodní fenomén napodoben se rùzní. Od Témìø úplného napodobení a¾ po 
inspiraci. 

Jedním z motivù pro vznik alternativních vıpoèetních pøístupù a poèítání 
podle pøírody je lep¹í splynutí s reálnım svìtem a jeho probémy.
V tomto kontextu je vhodné zmínit \textit{soft-computing}. \textit{Soft-computing}
je podmno¾inou poèítání podle pøírody, bıvají sem zaøazovány 
neuronové sítì, \textit{Support Vector Machines}, fuzzy systémy, evoluèní 
algoritmy a teorie chaosu. Postupy spadající do \textit{Soft-computing} 
tolerují nepøesnosti a nejistotu èím¾ dosahují vysoké robustnosti a 
lep¹ího vztahu s realitou. Poèítání podle pøírody ve svùj prospìch pou¾ívá 
procesy zejména fylogeneze, ontogeneze a epigeneze. Fylogeneze oznaèuje proces
evoluce druhù, ontogeneze proces vıvoje mnohobunìèného organismu a epigeneze
je nìjakı proces, kterı nastává v ji¾ slo¾itìj¹ím organismu 
(sem øadíme napøíklad neuronové sítì).
Dále se se poèítání podle pøíody inspirovalo procesy vznikajícími ve spoleènosti, 
v usuzování jedincù apodobnì. My se zde budeme zabıvat hloubìji pouze fylogenezí, nebo» 
právì na ní je zalo¾ena my¹lenka evoluèních algoritmù.

\section{Evoluèní algoritmy}

Fylogeneze je proces evoluce druhù. Evoluce je umo¾nìna schopností reprodukce jednotlivıch
jedincù, kdy potomkové se od svıch roduèù li¹í jen velmi málo. Pøi reprodukci v¹ak dochází také
k náhodnım obèasnım mutacím, které zabezpeèují dostateènou diferzitu a vzniká tak novı
genetickı materiál. Na fylogenezi jsou zalo¾ené evoluèní algoritmy. 

Evoluèní algoritmy lze chápat jako speciální optimalizaèní metodu nad prostorem 
$$U = D_{1} \times D_{2} \times D_{3} \times \ldots \times D_{n}$$
v¹ech kandidátních øe¹ení. Takovı prostor je pak kartézskı souèin domén, kde
jednotlivé domény univerza mohou nabıvat
hodnot z pøedem známıch, èasto nìjak omezenıch intervalù \cite{evolution_hardware}.  

V matematické optimalizaci, bychom se sna¾ili hledat hodnoty $x \in U$ takové,
pro které je hodnota úèelové funkce
$$ f : U \to \mathcal{R} $$
minimální (hledání maxima lze úpravou úèelové funkce pøevést na hledání minima).
Minima mohou bıt globální nebo lokální, ostrá nebo neostrá. Øe¹íme tedy úlohu,
kdy hledáme nìjakı argument, jeho¾ hodnota úèelové funkce spadá do mno¾iny optimálních
hodnot úèelové funkce \cite{nlprog}.
$$ argmin_{x}\{f(x)|x \in U\} $$		
V kontextu evoluèních algoritmù nazıváme $f$ funkcí \textit{fitness} a nehledáme 
argument $x$, pro nìj¾ je funkce $f$ minimální, ale postaèuje nám najít argument $x$ 
takovı, ¾e $f(x)$ splní nìjaké pøedem dáné ukonèovací podmínky.

\subsection{Princip}
Evoluèní algoritmy jsou inspirované procesem reprodukce jedincù napøíè generacemi.
Na zaèátku vıpoètu algoritmu vytvoøíme poèáteèní populaci $P_{0}$, tj.
populaci generace nula o pøedem známé velikosti $n$.
Volba jedincù do poèáteèní populace jsou rùzné, mù¾eme napøíklad sáhnout po náhodném 
vıbìru nebo volit jedince za pou¾ití vhodné heuristiky.

%$$ \mathcal{P}_{0} = \{x|x \in U \land vyber\_do\_poèáteèní\_populace(x) \} $$

V ka¾dém dal¹ím kroku evoluèního algoritmu, kterı nazıváme generace, je nejprve vybráno
$m$ vhodnıch jedincù z generace pøedchozí $P_{t - 1}$, kteøí nám tvoøí mno¾inu rodièù. Aplikací
genetickıch operátorù nad mno¾inou rodièù vznikne mno¾ina potomkù, Následnì se z obou
mno¾in vybere nová generace $P_{t}$ o velikosti $n$ a celı process (znázornìn na diagramu \ref{fig:eaflow})
se opakuje. Zpùsoby vıbìru rodièu jsou rùzné stejnì
tak jako mo¾né genetické operátory. Obìma se budeme zabıvat pozdìji.

%%%%%%%%%%%%% EVOLUTION ALGORITHM FLOWCHART %%%%%%%%%%%%%%%
\begin{figure}[!ht]
	\centering
	\includegraphics[scale=0.4]{fig/evolution_algorithm_flowchart}	
	\caption{Obecnı postup vıpoètu evoluèního algoritmu}
	\label{fig:eaflow}
\end{figure}
%%%%%%%%%%%%% EVOLUTION ALGORITHM FLOWCHART %%%%%%%%%%%%%%%

\subsection{Fitness funkce}
Fitness funkce je obdoba úèelové funkce z oboru matematické optimalizace. Název fitness
pochází z oboru evoluèní biologie, kde hodnota fitness popisuje biologickou zdatnost jedince
\cite{evolution_hardware}. Vstupem fitness funkce je (v jednodu¹¹ím pøípadì) jedinec
reprezentovanı chromozomem a vıstupem je hodnota reprezentující zdatnost jedince.

Ve slo¾itìj¹ích pøípadech je nutné rozli¹ovat mezi prostorem genotypù a fenotypù. Genotypem
nazıváme v kontextu evoluèních algoritmù prostor v¹ech mo¾nıch øe¹ení, tedy 
v¹ech mo¾nıch chromozomù. Fenotyp je soubor charakteristik, projevù a chování,
jimi¾ se danı jedinec reprezentovanı urèitım chromozomem projevuje.
Zobrazení z prostoru genotypù do prostoru fenotypù lze potom vyjádøít následovnì:
$$ f_{phenotype} : U \to \mathcal{F}, $$
Potom je v¹ak nutné modifikovat na¹i fitness funkci následovnì :
$$ f : \mathcal{F} \to \mathcal{R} $$
a celı proces evaluace jedince bude poté kompizice tìchto dvou funkcí :
$$ f_{eval} = f \circ f_{phenotype}$$

Volba pota¾mo návrh vhodné fitness funkce je znaènì obtí¾ná. Neexistuje ¾ádnı obecnı
pøedpis pro jejich návrh. Musíme se spoléhat na obecná pravidla, zku¹enosti nebo 
intuici. Velké mno¾ství dobøe zakomponovanıch informací o problému ve fitness funkci je
dobrım základem pro úspì¹nı evoluèní algoritmus. Obecnì tedy platí, ¾e 
vhodnì zvolená fitness funkce má znaènı dopad na kvalitu vısledného øe¹ení.

\subsection{Zpùsoby selekce}
Zpùsoby selekce jsou dùle¾itım faktorem pøi návrhu evoluèního algoritmu. Selekce
je proces, pøi nìm¾ se vybırají rodièe z aktuální populace urèení k reprodukci. 
Dobrı selekèní algoritmus musí bıt schopen upøednostòovat jedince s vysokou hodnotou
fitness funkce, na druhou stranu musí zajistit dostateèné mno¾ství genetického 
materiálù pro dal¹i generace. Èasto vyu¾ívané selekèní mechanismy, zejména v kontextu
genetickıch algoritmù jsou napøíklad \cite{selection_schemes_comparison} :

\begin{itemize}
	\item \textit{deterministická selekce}, kde se do mno¾iny rodièù vybere $k$
		jedincù z aktuální populace s nejvy¹¹í hodnotou fitness,
		
	\item \textit{proporcionlní selekce}, kde pravdìpodobnost vıbìru jedince $i$ je 
		rovna vztahu $p_{i} = \frac{f(i)}{\sum_{j=1}{N} f(j)}$,
		
	\item \textit{turnajová selekce}, kdy je v nìkolika kolech turnaje postupnì 
		porovnáno nìkolik náhodnì vybranıch jedincù a vítìz turnaje je zaøazen
		do mno¾iny rodièù. Turnaj provedeme $n$-krát, kde $n$ je po¾adovaná mohutnost
		mno¾iny rodièù. 
\end{itemize}

\subsection{Genetické operátory}
Evoluèní algoritmy vyu¾ívají køí¾ení i mutaci, oba mechanismy jsou pøevzaty z
oboru bunìèné biologie, kde se uplatòují v procesu redukèního dìlení bunìk.

Operátor mutace se aplikuje na potomka
a vytvoøí z nìj potomka mutovaného. Stejnì jako v biologii, mutace se vyskytuje
pouze v malém poètu pøípadù. Na¹im cílem je prozkoumat prostor $U$ postupnì a
konvergovat k dobrım øe¹ením. V pøípadì vysoké pravdìpodobnosti mutace se ji¾
nejedná o algorigmus \textbf{evoluèní}, nıbr¾ \textbf{revoluèní} a algoritmus pøipomíná 
spí¹e náhodné prohledávání. Operátor mutace je velmi dùle¾itı, nebo» zanesení
náhodne mutace zaji¹»uje novı genetickı materiál, èím¾ je algoritmus jednou za
èas nucen prozkoumat vzdálenìj¹í bod prostoru. Neuvázne tak v lokálních extrémech.

Pøi køí¾ení dochází k pøenosu èástí chromozomù rodièù na potomka. Zpùsobù køí¾ení
existuje celá øada. Obecnì v¹ak platí, ¾e zpùsob køí¾ení je závislı na zvolené 
reprezentaci. Pokud máme jedince reprezentovaného grafem, operátor køí¾ení 
se bude znaènì odli¹ovat od pøípadu, kdy máme jedince reprezentovaného binárním
vektorem. 

Uveïmì si zde alespoò nejznámìj¹í druhy køí¾ení nad binární reprezentaci, jimi¾ jsou:
\begin{itemize}
	\item \textit{jednobodové køí¾ení}, kdy se urèí místo køí¾ení urèující,
		která èást chromozomu doputuje do potomka.
		
	\item \textit{dvoubodové køí¾ení} je obdobou vı¹e zmínìného, av¹ak pro dva body
		køí¾ení a
	\item \textit{uniformní køí¾ení}, které je do znaèné míry zobecnìním vı¹e zmínìnıch.
		 Urèí $n$ genù v chromozomu, jejich¾ hodnoty jsou vystøídány.
\end{itemize}

\subsection{Návrh evoluèního algoritmu}

Kvalita námi navr¾eného evoluèního algoritmu, je zejména závislá na následujících faktorech:
\begin{enumerate}
	\item reprezentace problémù a jeho kódování,
	\item pou¾itá fitness funkce,
	\item zobrazení z prostoru genotypù do prostoru fenotypù,
	\item volbou genetickıch operátorù a zpùsoby selekce,
	\item nastavením parametrù genetického algoritmu.
\end{enumerate}

Prostor ka¾dého problému øe¹itelného evoluènímy algoritmy je jinı. Neexistuje tedy obecnı
evoluèní algoritmus, kterı by kvalitnì øe¹il v¹echny problémy. Toto tvrzení podporuje takzvanı
\textit{No Free Lunch} teorém. Pokud uvá¾íme dostateènì velkı poèet optimalizaèních problémù,
neexistuje ¾ádnı optimalizaèní algoritmus, kterı projde ka¾dı bod prostoru $U$ právì jednou
a v prùmìru bude efektivnìj¹í ne¾ ostatní optimalizaèní algoritmy \cite{nflteorem, evolution_hardware}. 
Z tohoto tvrzení plyne, ¾e chceme-li øe¹it optimalizaèní problém skuteènì efektnivnì, musíme 
do na¹eho evoluèního algoritmu \textbf{vlo¾it co nejvíce informací} o problému prostøednictvím 
zejména polo¾ek zmínìnıch vı¹e.

\subsection{Genetické algoritmy}

Evoluèní algoritmy popisují mno¾inu algoritmù, jejich¾ èinnost je urèena procesem Darwinovské
evoluce. Na druhé stranì je v¹ak neomezuje natolik, aby se od sebe nemohly (nìkdy i velmi
vıznamnì) li¹it.

Asi nejvıznamìj¹ím ¾ástupcem evoluèních algoritmù jsou genetické algoritmy. Jedinci jedné populace
jsou reprezentovány øetìzcem (chromozomem) binárních, celoèíselnıch nebo i reálnıch hodnot.
Iniciální populace vzniká buï náhodnì nebo za pou¾ití vhodné heuristiky. Uplatòují se zde v¹echny
bì¾né selekèní mechanismy a stejnì tak zde najdeme pou¾ity v¹echny druhy metod køí¾ení.
Mutace se takté¾ pou¾ívá. Nevıhodou mohou nìkdy bıt chromozomı pevné délky.

\subsection{Evoluèní strategie}

Dal¹ím zajímavım algoritmem jsou evoluèní strategie. Jejich nejvìt¹í zajímavostí je, ¾e
se spoléhají pouze na operátor mutace. Køí¾ení se zde nevyskytuje. Nové generace se zde
vytváøejí zejména tak, ¾e rodièovská populace je mutována pøiètením hodnoty normálního rozlo¾ení s nulovou
$x' = x + \mathcal{N}(0, \sigma)$
støední hodnotou. Rozptyl $\sigma$ se mìní na základì toho, jak dobøe algoritmus aktuálnì
konverguje. Jako selekèní mechanismy se u¾ívá totální elitismus ve variantách $(\mu + \lambda)$
a $(\mu, \lambda)$ \cite{ES}. Uva¾ujeme-li $\mu$ mno¾inu rodièù a $\lambda$ mno¾inu jejich
potomkù, pak :

\begin{itemize}
	\item $(\mu + \lambda)$ vybere do dal¹í generace nejlep¹í jedince z mno¾iny
		rodièù a potomku
	\item $(\mu, \lambda)$ vybere do dal¹í generace jen ty nejlep¹í potomky. Rodièovská
		generace tedy vymírá.
\end{itemize} 

\section{Genetické programování}

Pro na¹í práce je zejména zajímavé genetické programování, nebo» právì to jsme zvolili 
jako evoluèní algoritmus pro øe¹ení na¹eho problémù. Seznámíme se s ním podrobnìji a 
proto mu vìnujme celou sekci.

Genetické programování je speciálním druhem evoluèního algoritmu, kde jednotlivce a 
celé populace tvoøí poèítaèové programy. Vıpoèet iterativnì transformuje poèítaèové
programy na jiné poèítaèové programy aplikací genetickıch operátorù, které jsou 
pro genetické programování specifické. Vıstupem genetického algoritmu
je v pøípadì, ¾e uspìje, nìjakı program. 

\subsection{Reprezentace}
Evolvované programy musíme vhodnì reprezentovat. Musíme pøí tom klást dùraz na to,
¾e programy je mezi sebou tøeba køí¾it, mutovat a obecnì na nich provádìt nutné
genetické operace. Na druhé stranì v¹ak chceme volit takovou reprezentaci, která
nám umo¾ní programy evaluovat, tudí¾ vykonávat je nad zadanım vstupem. 

Jedinci v populaci jsou reprezentování radìji jako \textit{abstraktní syntaktické stromy}
\cite{GPTutorial} ne¾ jako øádky programu. Ukázka jedince v geneticém programování je na
diagramu \ref{fig:exampletree1} a zobrazuje jedince reprezentovaného programem
\texttt{max(min(x,y), 5 + z)}. Stromy se skládají z uzlù a listù. Listy jsou
reprezentovány terminálním symbolem z mno¾iny terminálù $T$ a uzly jsou reprezentovány
funkcí z mno¾iny $F$. Na diagramu \ref{fig:exampletree1} mno¾inu funkcí tvoøí 
$F = \{max, min, +\}$ a mno¾inu terminálu $T = \{5, x, y, z\}$. Mno¾iny povolenıch
funkcí a terminálù dohromady tvoøí primitivní mno¾inu systému. Prostor mo¾nıch 
øe¹ení mù¾eme tedy definovat jako mno¾inu v¹ech mo¾nıch stromù, které mohou vzniknout
kombinací funkcí a terminálù :

$$ U = \{t | t=(FT)^{n}, 0 \leq n \leq max\_depth \}$$

Programová reprezentace stromù se li¹í v závislosti na pou¾itém programovacího jazyku.
Platí v¹ak, ¾e 
v prosøedích nároènıch na vıpoèetní vıkon je pamì»ová nároènost grafové reprezentace
neefektnivní. Stromové reprezentace lze u¾ít i nepøímo za pou¾ití prefixové notace.
Pøí pou¾ití prefixové notace se závorky stanou nadbyteènımi a program lze v pamìti
ulo¾it jako \textit{lineární sekvenci symbolù}. Jako pøíklad poslou¾í diagram 
\ref{fig:exampletree1}, tedy \texttt{max min x y + 5 z}. Volba reprezentace tedy
v koneèném dùsledkù zále¾í na u¾ivateli a jeho preferencích, po¾adavcích a prostøedí. 

%%%%%%%%%%%%% TREE REPRESENTATION EXAMPLE 1 %%%%%%%%%%%%%%%
\begin{figure}[!ht]
	\centering
	\includegraphics[scale=0.6]{fig/example_tree1}	
	\caption{Ukázka reprezentace programu max(min(x,y), 5 + z)}
	\label{fig:exampletree1}
\end{figure}
%%%%%%%%%%%%% TREE REPRESENTATION EXAMPLE 1 %%%%%%%%%%%%%%%

\subsection{Inicializace nulté populace}

Pro inicializaci nulté populace platí obecná pravidla. Mù¾eme ji buï volit náhodnì
nebo pou¾ít nìjakou vhodnou heuristiku. Je zde v¹ak specifická vlastnost, kterou 
musíme vzít do úvahy. Na¹e programy nemají pevnì omezenou velikost (délka
chromozomu je promìnná). Jak velké náhodné programy tedy generovat? Existují tøi
základní pøístupy:

\begin{enumerate}
	\item \textit{Full} metoda, kdy náhodnì vygenerujeme strom do maximální povolené
		hloubky,
	\item \textit{Grow} metoda, generujeme stromy promìnlivé délky a tvaru (maximální
		hloubka je omezena) a
	\item \textit{Ramped half-and-half}, kdy polovina populace je generována metodou
		\textit{Grow} a druhá metodou \textit{Full}, za promìnlivé maximální hloubky.
\end{enumerate}

Metoda Full v¾dy a za v¹ech okolností generuje plné stromy. V uzlech jsou funkce
vybírány náhodnì z mno¾íny $F$ a jakmile algoritmus dosáhne maximální hloubky,
nageneruje terminály z mno¾iny $T$ a skonèí.

Grow metoda naproti tomu generuje v uzlech s urèitou pravdìpodobností i terminály, èím¾
je schopna vytváøet stromy rùznıch délek i tvarù. Je v¹ak velmi závisla na velikostech
mno¾in $F$ a $T$. Pokud $|T| << |F|$ algoritmus degraduje na metodu Full. Pokud
na druhé stranì $|T| >> |F|$, algoritmus bude generovat jen velmi malé stromy.

Aby se omezil dopad rozdílnıch velikostí mno¾in $T$ a $F$, John Koza navrhl alternativu
v podobì algoritmu ramped half-and-half. Ten pou¾ívá obì metody souèasnì na polovinu 
jedincù populace a maximální hloubku stromu volí náhodnì, èím¾ zaji¹»uje promìnlivou
velikost i tvar stromù.

\subsection{Genetické operátory a selekce}

V pøípadì selekce do mno¾iny rodièù, se vyu¾ívají v¹echny bì¾né selekèní mechanismy
známé z evoluèních algoritmù, av¹ak nejèastìji se vyu¾ívá turnajová selekce následovaná
proporcionální selekcí.

Zajímavìj¹í je to v pøípadì genetickıch operátorù køí¾ení a mutace. Nejèastìj¹í formou
køí¾ení je \textit{podstromové køí¾ení}. U rodièù vybranıch k reprodukci se se náhodnì 
vybere bod køí¾ení, kterı v genetickém programování zastupují vìtve stromu. Potomek
vznikne umístìním podstromu prvního rodièe na prázdnou vìtev druhého rodièe (rodièe
implicitnì zachováváme). Celı proces blí¾e ilustruje diagram \ref{fig:tree_crossover}

%%%%%%%%%%%%% TREE CROSSOVER EXAMPLE 1 %%%%%%%%%%%%%%%
\begin{figure}[!ht]
	\centering
	\includegraphics[scale=0.6]{fig/tree_crossover}	
	\caption{Ukázka operátoru podstromového køí¾ení}
	\label{fig:tree_crossover}
\end{figure}
%%%%%%%%%%%%% TREE CROSSOVER EXAMPLE 1 %%%%%%%%%%%%%%%

Je vidìt, ¾e køí¾ení vytvoøí pouze jednoho potomka. Pro více potomkù celı proces 
opakujeme. Dale existuje specializace podstromového køí¾ení, obdoba jednobodového
kø¾ení, kdy se urèí v obou rodièích stejnı bod køí¾ení a pøehození korespondujících
podstromù. Je v¹ak potøeba oba strommy projít a najít spoleènı region, tedy èást stromu,
kde je mo¾né køí¾it. Existují dal¹í varianty jako je køí¾ení se zachováním kontextu, 
velikost zachovávající køí¾ení a uniformní køí¾ení. Tìmito se zde zatím blí¾e zabıvat
nebudeme.

Nejbì¾nìj¹í druh mutace je podstromová mutace. Algoritmus podstromové mutace ve stromu
náhodnì zvolí vìtev z ní¾ náhodnì vygeneruje novı podstrom, jak ilustruje diagram
\ref{fig:subtree_mutation}. V pøípadì tohoto algoritmu jde v podstatì o alternativu k
podstromovému køí¾ení s jedním rodièem a jedním náhodnì generovanım stromem.

Dal¹í variantou mutace v genickém programování je uzlová nutace, kdy na ka¾dı
uzel stromu je s urèitou nizkou pravdìpodobností mutace aplikována. Staré uzly
se nahrazují novımi se stejnou aritou.

%%%%%%%%%%%%% SUBTREE MUTATION EXAMPLE 1 %%%%%%%%%%%%%%%
\begin{figure}[!ht]
	\centering
	\includegraphics[scale=0.6]{fig/subtree_mutation}	
	\caption{Ukázka operátoru podstromové mutace}
	\label{fig:subtree_mutation}
\end{figure}
%%%%%%%%%%%%% SUBTREE MUTATION EXAMPLE 1 %%%%%%%%%%%%%%%

\subsection{Fitness funkce}
Populace v genetickém programování jsou programy. Evaluace kvality programu se provádí
zpravidla spu¹tìním daného programu nad danım vstupem a ohodnocením vıstupu. Spu¹tìní 
programu nad zadanım vstupem mù¾eme chápat jako zobrazení z mno¾íny genotypù do mno¾iny
fenotypù za vstupu dal¹ího parametru. Celı proces evaluace mù¾e bıt tedy chápán jako :
$$ f_{eval} = f \circ f_{run}(input)$$
kde $f$ je standarní fitness funkce a $f_{run} : I \to (U \to \mathcal{F})$ je
modifikované zobrazení genotyp-fenotyp pro nìjakı vstup $I$.

Fitness funkce v pøípadì genetického programování se li¹í od té tradièní v jednom
dùle¾itém smìru. Proto¾e pracujeme nad programy, musíme poskytnout zpùsob, jak danı
program spustit. Mo¾ností by bylo program zkompilovat. To s sebou nese znaènou re¾ii
a tak toto øe¹ení není v mnoha pøípadech vhodné. Pokud v¹ak bychom danı program chtìli
evaluovat nìkolikrát (mnohokrát), mù¾e se i toto øe¹ení jevit jako vhodné.

Èastìj¹í je ale programy interpretovat, to znamená projít strom od listù ke koøenu a 
spoèítání hodnoty uzlu za vstupu hodnot jeho následníkù. Kostru algoritmu bude jistì
tvoøit prùchod \textit{postorder}. Evaluace jednotlivıch hodnot v¹ak nemusí bıt za v¹ech 
okolností triviální, mù¾e napøíklad nastat pøípad, kdy bude program dìlit nulou nebo
se sna¾it seèíst hodnoty rùznıch typù (napø. \texttt{Bool} a \texttt{Int}). Proto
se po prvcích mno¾iny $F$ vy¾adují dvì uzávìrové vlastnosti. 

\begin{enumerate}
	\item \textit{typová konzistence} a
	\item \textit{bezpeènost pøi evaluaci}.
\end{enumerate}

Typová bezpeènost je nutná zejména kvùli operátoru køí¾ení, proto¾e ten nebere typy 
v potaz. Musíme tedy poèítat s tím, ¾e jakıkoli podstrom mù¾e bıt zavì¹en jako argument
libovolné funkci z mno¾ny $F$ a vıslednı program pøesto musí bıt interpretovatelnı.
Jinımi slovy navratovı typ libovolné funkce z mno¾iny $F$ musí bıt stejnı jako
typ libovolného vstupního argumentu jakékoli dostupné funkce. Toho mù¾eme dosáhnout
napøíklad jednodu¹e tím, ¾e v¹echny funkce z mno¾iny $F$ budou definovány na jedním
oborem hodnot toto¾ného typu. Èasto to v¹ak není mo¾né, proto se musíme nìkdy uchílit
napøíklad k implicitním typovım konverzím, nebo k otypování funkcí a typovì bezpeèné
operaci køí¾ení.

Dal¹í vlastností, kterou je nutné splnit je, abychom se vypoøádali s mo¾nımi
nedefinovanımi hodnotami, které jsou typické pro vstupy nìkterıch parciálních funkcí
jako je dìlení, kde hodnota je nedefinovaná pokud je dìlitel roven nule.
S parciálními funkcemi se mù¾eme vypoøádat tím, ¾e je explicitnì roz¹íøíme na funkce
totální nebo v pøípadì, je-li nedefinovaná hodnota detekována, znaènì sní¾íme jedincùv 
fitness.

\chapter{Návrh øe¹ení}
\label{sec:solution_design}

Jak ji¾ bylo øeèeno v kapitole \ref{sec:hashing}, navrhujeme-li ha¹ovací funkci "na
míru" nìjakému konkrétnímu univerzu klíèù, mù¾eme dosáhnout podstatnì lep¹í 
vıkonnosti ha¹ovací funkce, ne¾ je tomu v pøípadì obecnıch ha¹ovacích funkcí.

\section{Problém}
Na¹im problémem bude navrhnout konkrétní ha¹ovací funkci pro ha¹ování domény
\texttt{IP} adres. Adresa \texttt{IP} je èíslo, jednoznaènì identifikující sí»ové
rozhraní v síti, která pou¾ívá internetovı protokol \texttt{IP}. Vzhledem k tomu,
¾e budeme ha¹ovat èísla, nabízí se otázka, zda by nebylo vhodné pou¾ít tabulku
s pøímım pøístupem, tedy pou¾ít \texttt{IP} adresy pro pøístup do tabulky
pøímo bez vyu¾ití ha¹ování. Bohu¾el neznáme konkrétní interval nebo podmno¾inu
univerza \texttt{IP} adres a celé univerzum je pøíli¹ velké na to, aby jeho 
prvky mohly slou¾it jako èísla slotù do tabulky. Ve verzi 4 se jedná o 32 
bitové èíslo a verzi 6 dokonce o velikosti 128 bitù. Tabulka by tedy musela
mít $2^{32} = 4 294 967 296$ slotù v pøípadì  \texttt{IP} verze 4 a ve verzi 6
dokonce $2^{128} \approx 3×10^{38}$
slotù. Je vidìt, ¾e tabulky by byly opravdu velké a jejich pamì»ová nároènost
by byla nedostupná i pro specializované poèítaèe, uva¾ujeme-li, ¾e by takovı
stroj mìl dìlat i nìco jiného, ne¾ uchovávat tak ohromnou tabulku. Musíme se
tedy uchílit k návrhu ha¹ovací funkce.

\section{Princip}
Ha¹ovací funkce budeme navrhovat evoluènímy algoritmy, konkrétnì za pou¾ití 
genetického programování. Zvoleno bylo genetické programování, proto¾e 
jako jedince populace vyu¾ívá programy. 

Z kapitoly \ref{sec:evolution_design}  víme, ¾e pro ohodnocení kvality jedincù
populace musíme nejprve programy spustit nad nìjakım vstupem. Na¹im vstupem
budou náhodnì vybrané \texttt{IP} adresy z celého rozsahu. Náhodnost je dùle¾itá,
abychom se vyhli funkcím, které ¹patnì zobecòují, viz pøíklad v kapitole 
\ref{sec:hashing}.
Jednotlivé jedince budeme nad tímto vstupem interpretovat a hodnotit
dle odolnosti vùèí kolizím a lavinového efektu.

\section{Pøinos práce}

V pøedchozí pracích zabıvajícími se evoluèním návrhem ha¹ovacích funkcí 
\cite{grammar_evolution, safdari, NCHF_auto_design} bylo cílem navrhnout obecné
ha¹ovací funkce. V prvních dvou pøípadech se autoøi vydali cestou odolnosti vùèi
kolizím a v posledním pøípadì se kvalita øe¹ení posuzovala podle lavinového efektu.
Samotnı lavinovı efekt ha¹ovací funkce nezabezpeèí, ¾e funkce bude dobøe aproximovat
uniformní rozlo¾ení vıstupu. Na druhé stranì, pøi návrhu obecné funkce se na 
odolnost proti kolizím coby kritérium kvality ha¹ovacích funkcí nedá spoléhat, nebo»
neznáme pøedem univerzum klíèù.

\section{Návrh fitness funkce}

V na¹em pøípadì ale nenavrhujeme obecnou ha¹ovací funkci. My navrhujeme specifickou
ha¹ovací funkci pro specifické univerzum hodnot. Proto mù¾eme pou¾ít jako kritérium
kvality odolnost vùèi kolizím, které je nepøímım ukazatelem toho, jak dobøe funkce
náhodnì distribuuje své vıstupy.

Jako dal¹í komponentu do na¹eho kritéria zaøadíme je¹te lavinovı efekt. Ten je 
dùle¾itım ukazatelem zejména z dùvodu dobrého zobecòování. Evaluovanou ha¹ovací
funkci budeme testoat nad náhodnımi prvky univerza. Nìkdy se mù¾e stát, ¾e i funkce
s dobrım uniformním rozlo¾ením vıstupù nebude pracovat správnì v praxi. To mù¾e bıt
zpùsobeno mnoha faktory, napøíklad ¹patnou volbou evaluaèních vstupù.
		 		 
Vısledná hodnota fitness bude brát v úvahu, oba faktory s vìt¹ím durazem na odolnost
vùèi kolizím.

\section{Zvolené parametry genetického programování}

V této sekci uvedeme, jaké parametry jsme zvolili parametry pro geneticé programování.

\subsection{Genetické operátory a selekce}

Operátory mutace pou¾ijeme ve dvou verzích. \textit{Podstromovou} mutaci a 
\textit{bodovou} mutaci zároveò. Budeme náhodnì volit mezi obìma alternativami, 
av¹ak pravdìpodobnost mutace ponecháme velmi nízkou. Pùvodní implementace algoritmù
genetického programování \cite{GPTutorial} operátor mutace vynechávaly úplnì. 
Budeme radìji volit cestu postupné pomaleji konvergující evoluce, ne¾ abychom 
nìjaká øe¹ení minuli.

Co se køí¾ení tıka, v prvních verzích pou¾ijeme základní formu tedy \textit{podstromové}
køí¾ení, pozdìji jej mù¾eme porovnat i s pokroèilej¹ími technikami jako jsou 
\textit{jednobodové} a køí¾ení se zachováním kontextu. 

Selekci pou¾ijeme turnajovou a to zejména kvùli své determinitiènosti (jedince
sice musíme volit náhodnì, ale nemusíme se mezi nimi stochastiky rozhodovat). Dal¹ím dùvodem
je dobrá ¹kálovatelnost selekèního tlaku.

Poèáteèní populaci budeme generovat náhodnì bez pou¾ití jakıchkoli heuristik
a to metodou \textit{ramped-half-and-half}, která zaji¹»uje pro start algoritmu
kvalitní populaci co se rùznorodosti verlikostí a tvarù jedincù tıká. 

\subsection{Mno¾ina terminálù a funkèních symbolù}

Mno¾inu vstupù zkonstruujeme z konstant a vstupních promìnnıch. Vstupní
promìnné vyrobíme z jednotlivıch oktetù adres a budeme po¾adovat, aby ka¾dı
vstupní program obsahoval v¹echny promìnné právì jednou, tedy aby pracoval
s celou adresou. Jako konstanty budeme volit prvoèísla. Prvoèísla hrají 
dùle¾itou roli pøi operaci modulo. Pokud volíme jako argument modula nìjaké
násobky malıch èísel jako je napøíklad èislo dvì, mù¾e se stát, ¾e funkce bude
mít tendenci seskupovat èísla dìlitelná dvìmi. Jako konstanty budeme volit
velká prvoèísla.

Mno¾inu funkcí zvolíme z bì¾nıch operací. Vyhneme se cyklùm a jinım slo¾itım
øídícím konstrukcím, nebo» ha¹ovací funkce musí bıt také rychlá. Dal¹í
nevítanou skupinou operací jsou operace v plovoucí øádové èárce. My se tedy
spokojíme s dìlením beze zbytku. Vıèet pou¾itıch operaci a terminálù
popisují tabulky \ref{tab:function_set_design} a \ref{tab:terminal_set_design}.


%%%%%%%%%%%%% FUNCTION AND TERMINAL SETS %%%%%%%%%%%%%%%
\begin{table}
\begin{center}
\begin{tabular}{ |c|c| }
	\hline
	\multicolumn{2}{|c|}{Mno¾ina zvolenıch funkcí} \\
  	\hline			
   	Kategorie & Zástupci \\
  	\hline \hline  
  	Aritmetické celoèíselné & $\{ +,-,*,/,mod \}$ \\
  	Aritmetické             & $\{\}$ \\
  	Booleovské				& $\{AND, OR, NOT, XOR\}$ \\
  	Øídící                  & $\{IF-THEN-ELSE\}$ \\
  	Bitové					& $\{<<, >>\}$ \\ 	 
  	\hline
\end{tabular}
\caption{Zvolená mno¾ina funkcí}
\label{tab:function_set_design}
\end{center}
\end{table}

\begin{table}
\begin{center}
\begin{tabular}{ |c|c| }
	\hline
	\multicolumn{2}{|c|}{Mno¾ina zvolenıch terminálù} \\
  	\hline			
   	Kategorie & Zástupci \\
  	\hline \hline  
  	Promìnné       & samostatná promìnná pro ka¾dı oktet adresy \\
  	Funkce arity 0 & $\{ \text{vygeneruj\_prvocislo} \}$ \\	 
  	\hline
\end{tabular}
\caption{Zvolená mno¾ina terminálù}
\label{tab:terminal_set_design}
\end{center}
\end{table}
%%%%%%%%%%%%% FUNCTION AND TERMINAL SETS %%%%%%%%%%%%%%%


\chapter{Závìr}
\input{conclusion}

%=========================================================================