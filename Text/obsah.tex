%=========================================================================

\chapter{Úvod}
\input{introduction}

\chapter{Ha¹ování}
\label{sec:hashing}
Ha¹ovací tabulky jsou dùle¾itou souèástí moderního svìta informaèních 
technologíí. Jsou to vyhledávací datové struktury, které nám za urèitých
okolností umo¾ní vyhledávat, vkládat a mazat ulo¾ené polo¾ky s konstantní
èasovou slo¾itostí. Jedná se o jednu z nìkolika mo¾ných implementací
asociativního pole. Ty dal¹í jsou napøíklad stromové implementace, 
implementace vázaným seznamem s lineáním prùchodem a dal¹í. ®ádnými
z tìchto implementací se zde zabývat nebudeme \cite{art_of_programming}.

\section{Princip}
Mìjme dané univerzum klíèù $U$, kde nìkteré klíèe $k \in U$ si pøejeme
asociovat s nìjakými satelitnímy daty $v$, jejich¾ povaha není pro nás v
tuto chvíli dùle¾itá. Dále máme dynamickou mno¾inu $S = \{(k,v) | k \in u\}$
uchovávající klíèe s jejich satelitními daty. Pak nad mno¾inou $S$ chceme
pro nìjaký klíè $k$ a nìkteré její polo¾ky $x=(k, v)$ provádìt následující 
operace: 

\begin{enumerate}
	\item \textit{vkládání} dat, tedy operaci 
		$Insert(S,x) : S \to S \cup \{(k, v)\} $,

	\item \textit{mazání} dat, tedy operaci 
		$Delete(S,x) : S \to S - \{(k, v)\}$

	\item \textit{výhledávání} satelitních dat podle zadaného klíèe,
		tedy operaci \newline $Search(S,k) : 
			\begin{cases}
				x 	: x.k = k \\
				nil : jinak 
			\end{cases} $
\end{enumerate}

Operace vyhledávání není totální, musíme tedy explicitnì vhodnì o¹etøit
pøípady, kdy se prvek $x=(k,v)$ v tabulce nevyskytuje.

Nejjedodu¹¹í implementací je \textit{tabulka s pøímým pøístupem} za
pøedpokladù, ¾e $|U|$ je pøijatelná. Uva¾me napøíklad univerzum
klíèu $U = \{0,1,2,3,\ldots,m-1\}$, a tabulku $T$ reprezentující
dynamickou mno¾inu $S$, pak nejjednodu¹¹ím pøístupem je pou¾ít jako
klíèe pøímo prvky mno¾iny $U$. Pak operace vyhledávání je rovna operaci
pøístupu do tabulky na zadanou lokaci, napøíklad $Search(T,k) = T[k]$
pro nìjaký klíè $k \in U$.

Mù¾e v¹ak nastat pøípad, kdy $m$ bude pøíi¹ velké èíslo. Typickým pøíkladem
jsou klíèe mno¾iny v¹ech mo¾ných øetìzcù. Pak by tabulka s pøímým pøístupem
byla pøíli¹ velká a nevhodná pro moderní poèítaèe. Pokud potøebujeme 
vyhledávat pouze v nìjaké podmno¾inì $K \subset U$, kde $|K| << |U|$, je 
vhodné pou¾ít ha¹ovací funkci. Zjevnou výhodou tabulek s pøímým pøistupem je slo¾itost
, která je $\theta (1)$ v nejhor¹ím pøípadì. Nevýhodou je pamì»ová nároènost
pro velká univerza $U$, kdy velká èást tabulky zùstane prázdná.

\subsection{Ha¹ovací funkce}
Ha¹ovací funkce je je zobrazení, mapující prvky mno¾iny $U$ na jednotlivé 
sloty (indexy) tabulky $T$ :
$$ f_{hash} : U \to (0,1,\ldots,m-1)$$
za pøedpokladu, ¾e tabulka má právì $m-1$ slotù. Vyhledávací struktura 
slo¾ená z dynamické mno¾iny $S$ reprezentovanou tabulkou $T$ a ha¹ovací 
funkcí $f_{hash}$ se nazývá \textit{ha¹ovací tabulka} 
viz. \ref{fig:hash_table_example}.

%%%%%%%%%%%%% HASH TABLE EXAMPLE %%%%%%%%%%%%%%%
\begin{figure}[!ht]
	\centering
	\includegraphics[scale=0.6]{fig/hash_table_example}	
	\caption{Princip fungování ha¹ovacích tabulek}
	\label{fig:hash_table_example}
\end{figure}
%%%%%%%%%%%%% HASH TABLE EXAMPLE %%%%%%%%%%%%%%%
 
Vzhledem k tomu, ¾e velikost tabulky je men¹í, ne¾ velikost univerza $|U|$,
budou nastávat kolize. Kolize je pøípad kdy, dva rùzné prvky univerza
$k_{1}, k_{2} \in U$ budou zobrazeny na stejný slot : 
$f_{hash} (k_{1}) = f_{hash} (k_{2})$. S tímto neduhem se dá vypoøádat mnoha 
zpùsoby, ale pro na¹e úèely postaèí zøetìzení prvkù ve slotu do listu.
Èasová slo¾itost takové implementace je :
\begin{itemize}
	\item v nejhor¹ím pøípadì $\theta (n)$, kdy v¹echny prvky budou namapovány
		na jeden slot,
	\item v prùmìru bude $\theta (1 + \alpha)$, za pøedpokladu
		uniformního rozlo¾ení, kdy pravdìpodobnost namapování libovolbného
		prvku na konkrétní slot je $\frac{1}{m}$ a
\end{itemize}

$\alpha$ je takzvaný \textit{faktor zatí¾ení} definovaný vztahem $\alpha = \frac{n}{m}$.
Èasová slo¾itost tabulky zále¾í za pøedpokladu uniformního rozlo¾ení 
ha¹ovací funkce na \textit{faktoru zatí¾ení}. 

\section{Kritéria kvality ha¹ovacích funkcí}

Shròme si nyní základní kritéria, která jsou dùle¾iá pro ha¹ovací funkce.

\subsection{Uniformní rozlo¾ení výstupù}

Pro dokonalé uniformní rozlo¾ení ha¹ovací funkce bychom potøebovali \textit{náhodný}
generátor a i kdybychom nìjaký mìli k dispozici, pak by sice dobøe dokázal 
rozprostøít jednotlivé prvky do ha¹ovací tabulky, nicménì vzhledem k jeho náhodné 
povaze bychom je jen tì¾ko zpìt dohledávali. Musíme tedy zvolit jinou 
alternativu. Ha¹ovací funkce musí být deterministická a musí dobøe aproximovat
uniformní rozlo¾ení. Uniformní rozlo¾ení výstupù je pøedpokladem pro
nízkou èasovou slo¾itost ha¹ovacích algoritmù, jak je vidìt z pøíkladu
v sekci \ref{se:hash_function_design}.

\subsection{Odolnost proti kolizím}

Uva¾ujeme-li uniformní rozlo¾ení ha¹ovací funkce, pak dva klíèe u univerza
$U$ budou kolizní (dle \textit{birthday attack}) asi po $2^{\frac{m}{2}}$ 
operacích vlo¾ení\cite{NCHF_auto_design}. Pokud v¹ak ha¹ovací funkce nebude
uniformì distribuovat výsledky, pravdìpodobnost kolize se rapidnì zvý¹í.

\subsection{Lavinový efekt}

Lavinový efekt (angl. Avalanche effect) je vlastnost ha¹ovací funkce, pøi
které se rapidnì mìní výstup ha¹ovací funkce pro malou zmìnu vstupu. 
Funkce které mají vysoký lavinový efekt mohou odolávat problému shlukování,
pøi kterém se nìkteré èásti univerza mají tendenci shlukovat na výstupu
do skupin.

\subsection{Rychlost}

Nesporná výhoda ha¹ovacích tabulek je jejich rychlost. Dobøe navr¾ená ha¹ovací
tabulka dosahuje za urèitých okolností slo¾itosti $\theta (1)$. Pokud je v¹ak
výpoèetní algoritmus pøíli¹ slo¾itý, mù¾e daná funkce být pomalá. Je proto
nutné dbát na to, ¾e pøíli¹ pomalý, i kdy¾ dobrý algoritmus nemusí být
v¾dy ten nejlep¹í. 

\section{Návrh ha¹ovací funkce}
\label{se:hash_function_design}

V praxi je èasto sly¹et názor, ¾e ha¹ovací funkce pracují v konstantním èase.
To v¹ak není pravda, nebo» výkon ha¹ovací funkce zále¾í jednak na faktoru
zatí¾ení ha¹ovací tabulky a uniformnosti, s jakou doká¾e ha¹ovací funkce
pøíøazovat klíèe do slotù.

Zamìøme se nejprve na zatí¾ení tabulky a uva¾me nìjakou podmno¾inu univerza
v¹ech klíèù $K \in U$, ha¹ovací tabulku $T$ s $m$ sloty a oznaème $n = |K|$.
Pokud $n$ bude men¹í ne¾ $m$, pak ha¹ovací tabulka bude skuteènì pracovat v 
$\theta (1)$, za pøedpokladu uniformního rozlo¾ení ha¹ovací funkce. Pokud ale
bude $m$ men¹í ne¾ $n$, faktor zatí¾ení bude vìt¹í ne¾ jedna a ha¹ovací tabulka
v konstantním èase pracovat nebude. Uva¾me $m=4$ a $n=5$. Pak za pøedpokladu
uniformního rozlo¾ení ha¹ovací funkce, s vlo¾ením pátého prvku bude ha¹ovací 
tabulka plná a nám nezbude ne¾ vkládaný prvek zaøadit na zaèátek jednosmìrnì
vázaného seznamu.

Existuje mnoho metod pro konstrukci ha¹ovací funkce, jako jsou napøíklad
\textit{metoda násobení}, \textit{metoda dìlení} a dal¹í komplikovanìj¹í
pøístupy. V souèasné dobì existují velmi dobré implementace obecných ha¹ovacích funkcí.
Av¹ak ¾ádná ha¹ovací funkce nemù¾e pracovat pro v¹echna mo¾ná univerza stejnì
dobøe. Jako pøíklad uva¾ujme ha¹ovací funkci navr¾enou metodou dìlení :
$$ f_{hash}(k) = k \text{ mod } 8 $$ 
a dále uva¾ujme univerzum $U = \mathbb{N}$ a jeho
podmno¾inu $K = \{1,2,3,4,8,13,22,71\}$, kterou budeme vkládat do tabulky.
Ha¹ovací funkce je schopna ulo¾it $8$ ruzných hodnot a v pøípadì 
na¹eho výbìru mno¾iny $K$, se nám podaøí ulo¾it v¹echny, ani¾ by do¹lo ke kolizi.
Co by se ale stalo, pokud bychom byli omezení na univerzum pouze tìch
pøirozených èisel, která jsou dìlitelné osmi $U = \{x \in \mathbb{N}
\land x \text{ mod } 8 = 0\}$? Nemohli bychom vybrat ¾ádnou podmno¾inu 
$F \in U$ takovou, kterou by funkce $f_{hash}$ nezobrazila pouze na jeden
slot.

Je vidìt, ¾e pokud máme informace o univerzu mo¾ných klíèù, mù¾eme navrhnout
ha¹ovací funkci 'na míru' tak, aby mìla lep¹í vlastnosti, ne¾ obecná 
ha¹ovací funkce. Tento úkol je v¹ak obtí¾ný a neexistuj pro nìj obecný
návod jak toho docílit. Musíme se spolehnout na zku¹enosti, znalosti a v 
neposlední øadì také na intuici. Nebo mù¾eme zvolit úplnì jiný pøístup
jak napovídá kapitola \ref{sec:evolution_design}.

\chapter{Evoluèní návrh}
\label{sec:evolution_design}

% Chapter INTRO
Evoluèní návrh je netradièní disciplína, která vyu¾ívá evoluèní algoritmy
k návrhu. Evoluèní algoritmy spadají do oblasti umìlé 
inteligence. Specifickou vlastností mnoha úloh spadajících do obasti umìlé 
inteligence je, ¾e èasto vhodným zpùsobem prohledávají prostor $U$,
reprezentující v¹echna mo¾ná øe¹ení (kandidátní) dané úlohy 
\cite{evolution_hardware}. Evoluèní algoritmy se dají pova¾ovat za speciální metodou 
prohledávání prostoru kandidátních øe¹ení.

% Section Natural computing
\section{Poèítání podle pøírody}
\label{sec:natural_computing}
Poèítání podle pøírody (Natural computing) je sohrný termín pro tvorbu 
inteligentních strojù napodobováním biologických procesù, chování ¾ivých 
tvorù nebo jejich mechanismù. Øadíme sem také výpoèetní paradigmata, která 
svoji inspiraci nalezla v pøírodních procesech nebo pou¾ití organismù a 
jiných netradièních materiálù jako výpoèetních platforem. Míra do jaké je 
pøírodní fenomén napodoben se rùzní. Od Témìø úplného napodobení a¾ po 
inspiraci. 

Jedním z motivù pro vznik alternativních výpoèetních pøístupù a poèítání 
podle pøírody je lep¹í splynutí s reálným svìtem a jeho probémy.
V tomto kontextu je vhodné zmínit \textit{soft-computing}. \textit{Soft-computing}
je podmno¾inou poèítání podle pøírody, bývají sem zaøazovány 
neuronové sítì, \textit{Support Vector Machines}, fuzzy systémy, evoluèní 
algoritmy a teorie chaosu. Postupy spadající do \textit{Soft-computing} 
tolerují nepøesnosti a nejistotu èím¾ dosahují vysoké robustnosti a 
lep¹ího vztahu s realitou. Poèítání podle pøírody ve svùj prospìch pou¾ívá 
procesy zejména fylogeneze, ontogeneze a epigeneze. Fylogeneze oznaèuje proces
evoluce druhù, ontogeneze proces vývoje mnohobunìèného organismu a epigeneze
je nìjaký proces, který nastává v ji¾ slo¾itìj¹ím organismu 
(sem øadíme napøíklad neuronové sítì).
Dále se se poèítání podle pøíody inspirovalo procesy vznikajícími ve spoleènosti, 
v usuzování jedincù apodobnì. My se zde budeme zabývat hloubìji pouze fylogenezí, nebo» 
právì na ní je zalo¾ena my¹lenka evoluèních algoritmù.

\section{Evoluèní algoritmy}

Fylogeneze je proces evoluce druhù. Evoluce je umo¾nìna schopností reprodukce jednotlivých
jedincù, kdy potomkové se od svých roduèù li¹í jen velmi málo. Pøi reprodukci v¹ak dochází také
k náhodným obèasným mutacím, které zabezpeèují dostateènou diferzitu a vzniká tak nový
genetický materiál. Na fylogenezi jsou zalo¾ené evoluèní algoritmy. 

Evoluèní algoritmy lze chápat jako speciální optimalizaèní metodu nad prostorem 
$$U = D_{1} \times D_{2} \times D_{3} \times \ldots \times D_{n}$$
v¹ech kandidátních øe¹ení. Takový prostor je pak kartézský souèin domén, kde
jednotlivé domény univerza mohou nabývat
hodnot z pøedem známých, èasto nìjak omezených intervalù \cite{evolution_hardware}.  

V matematické optimalizaci, bychom se sna¾ili hledat hodnoty $x \in U$ takové,
pro které je hodnota úèelové funkce
$$ f : U \to \mathcal{R} $$
minimální (hledání maxima lze úpravou úèelové funkce pøevést na hledání minima).
Minima mohou být globální nebo lokální, ostrá nebo neostrá. Øe¹íme tedy úlohu,
kdy hledáme nìjaký argument, jeho¾ hodnota úèelové funkce spadá do mno¾iny optimálních
hodnot úèelové funkce \cite{nlprog}.
$$ argmin_{x}\{f(x)|x \in U\} $$		
V kontextu evoluèních algoritmù nazýváme $f$ funkcí \textit{fitness} a nehledáme 
argument $x$, pro nìj¾ je funkce $f$ minimální, ale postaèuje nám najít argument $x$ 
takový, ¾e $f(x)$ splní nìjaké pøedem dáné ukonèovací podmínky.

\subsection{Princip}
Evoluèní algoritmy jsou inspirované procesem reprodukce jedincù napøíè generacemi.
Na zaèátku výpoètu algoritmu vytvoøíme poèáteèní populaci $P_{0}$, tj.
populaci generace nula o pøedem známé velikosti $n$.
Volba jedincù do poèáteèní populace jsou rùzné, mù¾eme napøíklad sáhnout po náhodném 
výbìru nebo volit jedince za pou¾ití vhodné heuristiky.

%$$ \mathcal{P}_{0} = \{x|x \in U \land vyber\_do\_poèáteèní\_populace(x) \} $$

V ka¾dém dal¹ím kroku evoluèního algoritmu, který nazýváme generace, je nejprve vybráno
$m$ vhodných jedincù z generace pøedchozí $P_{t - 1}$, kteøí nám tvoøí mno¾inu rodièù. Aplikací
genetických operátorù nad mno¾inou rodièù vznikne mno¾ina potomkù, Následnì se z obou
mno¾in vybere nová generace $P_{t}$ o velikosti $n$ a celý process (znázornìn na diagramu \ref{fig:eaflow})
se opakuje. Zpùsoby výbìru rodièu jsou rùzné stejnì
tak jako mo¾né genetické operátory. Obìma se budeme zabývat pozdìji.

%%%%%%%%%%%%% EVOLUTION ALGORITHM FLOWCHART %%%%%%%%%%%%%%%
\begin{figure}[!ht]
	\centering
	\includegraphics[scale=0.4]{fig/evolution_algorithm_flowchart}	
	\caption{Obecný postup výpoètu evoluèního algoritmu}
	\label{fig:eaflow}
\end{figure}
%%%%%%%%%%%%% EVOLUTION ALGORITHM FLOWCHART %%%%%%%%%%%%%%%

\subsection{Fitness funkce}
Fitness funkce je obdoba úèelové funkce z oboru matematické optimalizace. Název fitness
pochází z oboru evoluèní biologie, kde hodnota fitness popisuje biologickou zdatnost jedince
\cite{evolution_hardware}. Vstupem fitness funkce je (v jednodu¹¹ím pøípadì) jedinec
reprezentovaný chromozomem a výstupem je hodnota reprezentující zdatnost jedince.

Ve slo¾itìj¹ích pøípadech je nutné rozli¹ovat mezi prostorem genotypù a fenotypù. Genotypem
nazýváme v kontextu evoluèních algoritmù prostor v¹ech mo¾ných øe¹ení, tedy 
v¹ech mo¾ných chromozomù. Fenotyp je soubor charakteristik, projevù a chování,
jimi¾ se daný jedinec reprezentovaný urèitým chromozomem projevuje.
Zobrazení z prostoru genotypù do prostoru fenotypù lze potom vyjádøít následovnì:
$$ f_{phenotype} : U \to \mathcal{F}, $$
Potom je v¹ak nutné modifikovat na¹i fitness funkci následovnì :
$$ f : \mathcal{F} \to \mathcal{R} $$
a celý proces evaluace jedince bude poté kompizice tìchto dvou funkcí :
$$ f_{eval} = f \circ f_{phenotype}$$

Volba pota¾mo návrh vhodné fitness funkce je znaènì obtí¾ná. Neexistuje ¾ádný obecný
pøedpis pro jejich návrh. Musíme se spoléhat na obecná pravidla, zku¹enosti nebo 
intuici. Velké mno¾ství dobøe zakomponovaných informací o problému ve fitness funkci je
dobrým základem pro úspì¹ný evoluèní algoritmus. Obecnì tedy platí, ¾e 
vhodnì zvolená fitness funkce má znaèný dopad na kvalitu výsledného øe¹ení.

\subsection{Zpùsoby selekce}
Zpùsoby selekce jsou dùle¾itým faktorem pøi návrhu evoluèního algoritmu. Selekce
je proces, pøi nìm¾ se vybýrají rodièe z aktuální populace urèení k reprodukci. 
Dobrý selekèní algoritmus musí být schopen upøednostòovat jedince s vysokou hodnotou
fitness funkce, na druhou stranu musí zajistit dostateèné mno¾ství genetického 
materiálù pro dal¹i generace. Èasto vyu¾ívané selekèní mechanismy, zejména v kontextu
genetických algoritmù jsou napøíklad \cite{selection_schemes_comparison} :

\begin{itemize}
	\item \textit{deterministická selekce}, kde se do mno¾iny rodièù vybere $k$
		jedincù z aktuální populace s nejvy¹¹í hodnotou fitness,
		
	\item \textit{proporcionlní selekce}, kde pravdìpodobnost výbìru jedince $i$ je 
		rovna vztahu $p_{i} = \frac{f(i)}{\sum_{j=1}{N} f(j)}$,
		
	\item \textit{turnajová selekce}, kdy je v nìkolika kolech turnaje postupnì 
		porovnáno nìkolik náhodnì vybraných jedincù a vítìz turnaje je zaøazen
		do mno¾iny rodièù. Turnaj provedeme $n$-krát, kde $n$ je po¾adovaná mohutnost
		mno¾iny rodièù. 
\end{itemize}

\subsection{Genetické operátory}
Evoluèní algoritmy vyu¾ívají køí¾ení i mutaci, oba mechanismy jsou pøevzaty z
oboru bunìèné biologie, kde se uplatòují v procesu redukèního dìlení bunìk.

Operátor mutace se aplikuje na potomka
a vytvoøí z nìj potomka mutovaného. Stejnì jako v biologii, mutace se vyskytuje
pouze v malém poètu pøípadù. Na¹im cílem je prozkoumat prostor $U$ postupnì a
konvergovat k dobrým øe¹ením. V pøípadì vysoké pravdìpodobnosti mutace se ji¾
nejedná o algorigmus \textbf{evoluèní}, nýbr¾ \textbf{revoluèní} a algoritmus pøipomíná 
spí¹e náhodné prohledávání. Operátor mutace je velmi dùle¾itý, nebo» zanesení
náhodne mutace zaji¹»uje nový genetický materiál, èím¾ je algoritmus jednou za
èas nucen prozkoumat vzdálenìj¹í bod prostoru. Neuvázne tak v lokálních extrémech.

Pøi køí¾ení dochází k pøenosu èástí chromozomù rodièù na potomka. Zpùsobù køí¾ení
existuje celá øada. Obecnì v¹ak platí, ¾e zpùsob køí¾ení je závislý na zvolené 
reprezentaci. Pokud máme jedince reprezentovaného grafem, operátor køí¾ení 
se bude znaènì odli¹ovat od pøípadu, kdy máme jedince reprezentovaného binárním
vektorem. 

Uveïmì si zde alespoò nejznámìj¹í druhy køí¾ení nad binární reprezentaci, jimi¾ jsou:
\begin{itemize}
	\item \textit{jednobodové køí¾ení}, kdy se urèí místo køí¾ení urèující,
		která èást chromozomu doputuje do potomka.
		
	\item \textit{dvoubodové køí¾ení} je obdobou vý¹e zmínìného, av¹ak pro dva body
		køí¾ení a
	\item \textit{uniformní køí¾ení}, které je do znaèné míry zobecnìním vý¹e zmínìných.
		 Urèí $n$ genù v chromozomu, jejich¾ hodnoty jsou vystøídány.
\end{itemize}

\subsection{Návrh evoluèního algoritmu}

Kvalita námi navr¾eného evoluèního algoritmu, je zejména závislá na následujících faktorech:
\begin{enumerate}
	\item reprezentace problémù a jeho kódování,
	\item pou¾itá fitness funkce,
	\item zobrazení z prostoru genotypù do prostoru fenotypù,
	\item volbou genetických operátorù a zpùsoby selekce,
	\item nastavením parametrù genetického algoritmu.
\end{enumerate}

Prostor ka¾dého problému øe¹itelného evoluènímy algoritmy je jiný. Neexistuje tedy obecný
evoluèní algoritmus, který by kvalitnì øe¹il v¹echny problémy. Toto tvrzení podporuje takzvaný
\textit{No Free Lunch} teorém. Pokud uvá¾íme dostateènì velký poèet optimalizaèních problémù,
neexistuje ¾ádný optimalizaèní algoritmus, který projde ka¾dý bod prostoru $U$ právì jednou
a v prùmìru bude efektivnìj¹í ne¾ ostatní optimalizaèní algoritmy \cite{nflteorem, evolution_hardware}. 
Z tohoto tvrzení plyne, ¾e chceme-li øe¹it optimalizaèní problém skuteènì efektnivnì, musíme 
do na¹eho evoluèního algoritmu \textbf{vlo¾it co nejvíce informací} o problému prostøednictvím 
zejména polo¾ek zmínìných vý¹e.

\subsection{Genetické algoritmy}

Evoluèní algoritmy popisují mno¾inu algoritmù, jejich¾ èinnost je urèena procesem Darwinovské
evoluce. Na druhé stranì je v¹ak neomezuje natolik, aby se od sebe nemohly (nìkdy i velmi
významnì) li¹it.

Asi nejvýznamìj¹ím ¾ástupcem evoluèních algoritmù jsou genetické algoritmy. Jedinci jedné populace
jsou reprezentovány øetìzcem (chromozomem) binárních, celoèíselných nebo i reálných hodnot.
Iniciální populace vzniká buï náhodnì nebo za pou¾ití vhodné heuristiky. Uplatòují se zde v¹echny
bì¾né selekèní mechanismy a stejnì tak zde najdeme pou¾ity v¹echny druhy metod køí¾ení.
Mutace se takté¾ pou¾ívá. Nevýhodou mohou nìkdy být chromozomý pevné délky.

\subsection{Evoluèní strategie}

Dal¹ím zajímavým algoritmem jsou evoluèní strategie. Jejich nejvìt¹í zajímavostí je, ¾e
se spoléhají pouze na operátor mutace. Køí¾ení se zde nevyskytuje. Nové generace se zde
vytváøejí zejména tak, ¾e rodièovská populace je mutována pøiètením hodnoty normálního rozlo¾ení s nulovou
$x' = x + \mathcal{N}(0, \sigma)$
støední hodnotou. Rozptyl $\sigma$ se mìní na základì toho, jak dobøe algoritmus aktuálnì
konverguje. Jako selekèní mechanismy se u¾ívá totální elitismus ve variantách $(\mu + \lambda)$
a $(\mu, \lambda)$ \cite{ES}. Uva¾ujeme-li $\mu$ mno¾inu rodièù a $\lambda$ mno¾inu jejich
potomkù, pak :

\begin{itemize}
	\item $(\mu + \lambda)$ vybere do dal¹í generace nejlep¹í jedince z mno¾iny
		rodièù a potomku
	\item $(\mu, \lambda)$ vybere do dal¹í generace jen ty nejlep¹í potomky. Rodièovská
		generace tedy vymírá.
\end{itemize} 

\section{Genetické programování}

Pro na¹í práce je zejména zajímavé genetické programování, nebo» právì to jsme zvolili 
jako evoluèní algoritmus pro øe¹ení na¹eho problémù. Seznámíme se s ním podrobnìji a 
proto mu vìnujme celou sekci.

Genetické programování je speciálním druhem evoluèního algoritmu, kde jednotlivce a 
celé populace tvoøí poèítaèové programy. Výpoèet iterativnì transformuje poèítaèové
programy na jiné poèítaèové programy aplikací genetických operátorù, které jsou 
pro genetické programování specifické. Výstupem genetického algoritmu
je v pøípadì, ¾e uspìje, nìjaký program. 

\subsection{Reprezentace}
Evolvované programy musíme vhodnì reprezentovat. Musíme pøí tom klást dùraz na to,
¾e programy je mezi sebou tøeba køí¾it, mutovat a obecnì na nich provádìt nutné
genetické operace. Na druhé stranì v¹ak chceme volit takovou reprezentaci, která
nám umo¾ní programy evaluovat, tudí¾ vykonávat je nad zadaným vstupem. 

Jedinci v populaci jsou reprezentování radìji jako \textit{abstraktní syntaktické stromy}
\cite{GPTutorial} ne¾ jako øádky programu. Ukázka jedince v geneticém programování je na
diagramu \ref{fig:exampletree1} a zobrazuje jedince reprezentovaného programem
\texttt{max(min(x,y), 5 + z)}. Stromy se skládají z uzlù a listù. Listy jsou
reprezentovány terminálním symbolem z mno¾iny terminálù $T$ a uzly jsou reprezentovány
funkcí z mno¾iny $F$. Na diagramu \ref{fig:exampletree1} mno¾inu funkcí tvoøí 
$F = \{max, min, +\}$ a mno¾inu terminálu $T = \{5, x, y, z\}$. Mno¾iny povolených
funkcí a terminálù dohromady tvoøí primitivní mno¾inu systému. Prostor mo¾ných 
øe¹ení mù¾eme tedy definovat jako mno¾inu v¹ech mo¾ných stromù, které mohou vzniknout
kombinací funkcí a terminálù :

$$ U = \{t | t=(FT)^{n}, 0 \leq n \leq max\_depth \}$$

Programová reprezentace stromù se li¹í v závislosti na pou¾itém programovacího jazyku.
Platí v¹ak, ¾e 
v prosøedích nároèných na výpoèetní výkon je pamì»ová nároènost grafové reprezentace
neefektnivní. Stromové reprezentace lze u¾ít i nepøímo za pou¾ití prefixové notace.
Pøí pou¾ití prefixové notace se závorky stanou nadbyteènými a program lze v pamìti
ulo¾it jako \textit{lineární sekvenci symbolù}. Jako pøíklad poslou¾í diagram 
\ref{fig:exampletree1}, tedy \texttt{max min x y + 5 z}. Volba reprezentace tedy
v koneèném dùsledkù zále¾í na u¾ivateli a jeho preferencích, po¾adavcích a prostøedí. 

%%%%%%%%%%%%% TREE REPRESENTATION EXAMPLE 1 %%%%%%%%%%%%%%%
\begin{figure}[!ht]
	\centering
	\includegraphics[scale=0.6]{fig/example_tree1}	
	\caption{Ukázka reprezentace programu max(min(x,y), 5 + z)}
	\label{fig:exampletree1}
\end{figure}
%%%%%%%%%%%%% TREE REPRESENTATION EXAMPLE 1 %%%%%%%%%%%%%%%

\subsection{Inicializace nulté populace}

Pro inicializaci nulté populace platí obecná pravidla. Mù¾eme ji buï volit náhodnì
nebo pou¾ít nìjakou vhodnou heuristiku. Je zde v¹ak specifická vlastnost, kterou 
musíme vzít do úvahy. Na¹e programy nemají pevnì omezenou velikost (délka
chromozomu je promìnná). Jak velké náhodné programy tedy generovat? Existují tøi
základní pøístupy:

\begin{enumerate}
	\item \textit{Full} metoda, kdy náhodnì vygenerujeme strom do maximální povolené
		hloubky,
	\item \textit{Grow} metoda, generujeme stromy promìnlivé délky a tvaru (maximální
		hloubka je omezena) a
	\item \textit{Ramped half-and-half}, kdy polovina populace je generována metodou
		\textit{Grow} a druhá metodou \textit{Full}, za promìnlivé maximální hloubky.
\end{enumerate}

Metoda Full v¾dy a za v¹ech okolností generuje plné stromy. V uzlech jsou funkce
vybírány náhodnì z mno¾íny $F$ a jakmile algoritmus dosáhne maximální hloubky,
nageneruje terminály z mno¾iny $T$ a skonèí.

Grow metoda naproti tomu generuje v uzlech s urèitou pravdìpodobností i terminály, èím¾
je schopna vytváøet stromy rùzných délek i tvarù. Je v¹ak velmi závisla na velikostech
mno¾in $F$ a $T$. Pokud $|T| << |F|$ algoritmus degraduje na metodu Full. Pokud
na druhé stranì $|T| >> |F|$, algoritmus bude generovat jen velmi malé stromy.

Aby se omezil dopad rozdílných velikostí mno¾in $T$ a $F$, John Koza navrhl alternativu
v podobì algoritmu ramped half-and-half. Ten pou¾ívá obì metody souèasnì na polovinu 
jedincù populace a maximální hloubku stromu volí náhodnì, èím¾ zaji¹»uje promìnlivou
velikost i tvar stromù.

\subsection{Genetické operátory a selekce}

V pøípadì selekce do mno¾iny rodièù, se vyu¾ívají v¹echny bì¾né selekèní mechanismy
známé z evoluèních algoritmù, av¹ak nejèastìji se vyu¾ívá turnajová selekce následovaná
proporcionální selekcí.

Zajímavìj¹í je to v pøípadì genetických operátorù køí¾ení a mutace. Nejèastìj¹í formou
køí¾ení je \textit{podstromové køí¾ení}. U rodièù vybraných k reprodukci se se náhodnì 
vybere bod køí¾ení, který v genetickém programování zastupují vìtve stromu. Potomek
vznikne umístìním podstromu prvního rodièe na prázdnou vìtev druhého rodièe (rodièe
implicitnì zachováváme). Celý proces blí¾e ilustruje diagram \ref{fig:tree_crossover}

%%%%%%%%%%%%% TREE CROSSOVER EXAMPLE 1 %%%%%%%%%%%%%%%
\begin{figure}[!ht]
	\centering
	\includegraphics[scale=0.6]{fig/tree_crossover}	
	\caption{Ukázka operátoru podstromového køí¾ení}
	\label{fig:tree_crossover}
\end{figure}
%%%%%%%%%%%%% TREE CROSSOVER EXAMPLE 1 %%%%%%%%%%%%%%%

Je vidìt, ¾e køí¾ení vytvoøí pouze jednoho potomka. Pro více potomkù celý proces 
opakujeme. Dale existuje specializace podstromového køí¾ení, obdoba jednobodového
kø¾ení, kdy se urèí v obou rodièích stejný bod køí¾ení a pøehození korespondujících
podstromù. Je v¹ak potøeba oba strommy projít a najít spoleèný region, tedy èást stromu,
kde je mo¾né køí¾it. Existují dal¹í varianty jako je køí¾ení se zachováním kontextu, 
velikost zachovávající køí¾ení a uniformní køí¾ení. Tìmito se zde zatím blí¾e zabývat
nebudeme.

Nejbì¾nìj¹í druh mutace je podstromová mutace. Algoritmus podstromové mutace ve stromu
náhodnì zvolí vìtev z ní¾ náhodnì vygeneruje nový podstrom, jak ilustruje diagram
\ref{fig:subtree_mutation}. V pøípadì tohoto algoritmu jde v podstatì o alternativu k
podstromovému køí¾ení s jedním rodièem a jedním náhodnì generovaným stromem.

Dal¹í variantou mutace v genickém programování je uzlová nutace, kdy na ka¾dý
uzel stromu je s urèitou nizkou pravdìpodobností mutace aplikována. Staré uzly
se nahrazují novými se stejnou aritou.

%%%%%%%%%%%%% SUBTREE MUTATION EXAMPLE 1 %%%%%%%%%%%%%%%
\begin{figure}[!ht]
	\centering
	\includegraphics[scale=0.6]{fig/subtree_mutation}	
	\caption{Ukázka operátoru podstromové mutace}
	\label{fig:subtree_mutation}
\end{figure}
%%%%%%%%%%%%% SUBTREE MUTATION EXAMPLE 1 %%%%%%%%%%%%%%%

\subsection{Fitness funkce}
Populace v genetickém programování jsou programy. Evaluace kvality programu se provádí
zpravidla spu¹tìním daného programu nad daným vstupem a ohodnocením výstupu. Spu¹tìní 
programu nad zadaným vstupem mù¾eme chápat jako zobrazení z mno¾íny genotypù do mno¾iny
fenotypù za vstupu dal¹ího parametru. Celý proces evaluace mù¾e být tedy chápán jako :
$$ f_{eval} = f \circ f_{run}(input)$$
kde $f$ je standarní fitness funkce a $f_{run} : I \to (U \to \mathcal{F})$ je
modifikované zobrazení genotyp-fenotyp pro nìjaký vstup $I$.

Fitness funkce v pøípadì genetického programování se li¹í od té tradièní v jednom
dùle¾itém smìru. Proto¾e pracujeme nad programy, musíme poskytnout zpùsob, jak daný
program spustit. Mo¾ností by bylo program zkompilovat. To s sebou nese znaènou re¾ii
a tak toto øe¹ení není v mnoha pøípadech vhodné. Pokud v¹ak bychom daný program chtìli
evaluovat nìkolikrát (mnohokrát), mù¾e se i toto øe¹ení jevit jako vhodné.

Èastìj¹í je ale programy interpretovat, to znamená projít strom od listù ke koøenu a 
spoèítání hodnoty uzlu za vstupu hodnot jeho následníkù. Kostru algoritmu bude jistì
tvoøit prùchod \textit{postorder}. Evaluace jednotlivých hodnot v¹ak nemusí být za v¹ech 
okolností triviální, mù¾e napøíklad nastat pøípad, kdy bude program dìlit nulou nebo
se sna¾it seèíst hodnoty rùzných typù (napø. \texttt{Bool} a \texttt{Int}). Proto
se po prvcích mno¾iny $F$ vy¾adují dvì uzávìrové vlastnosti. 

\begin{enumerate}
	\item \textit{typová konzistence} a
	\item \textit{bezpeènost pøi evaluaci}.
\end{enumerate}

Typová bezpeènost je nutná zejména kvùli operátoru køí¾ení, proto¾e ten nebere typy 
v potaz. Musíme tedy poèítat s tím, ¾e jakýkoli podstrom mù¾e být zavì¹en jako argument
libovolné funkci z mno¾ny $F$ a výsledný program pøesto musí být interpretovatelný.
Jinými slovy navratový typ libovolné funkce z mno¾iny $F$ musí být stejný jako
typ libovolného vstupního argumentu jakékoli dostupné funkce. Toho mù¾eme dosáhnout
napøíklad jednodu¹e tím, ¾e v¹echny funkce z mno¾iny $F$ budou definovány na jedním
oborem hodnot toto¾ného typu. Èasto to v¹ak není mo¾né, proto se musíme nìkdy uchílit
napøíklad k implicitním typovým konverzím, nebo k otypování funkcí a typovì bezpeèné
operaci køí¾ení.

Dal¹í vlastností, kterou je nutné splnit je, abychom se vypoøádali s mo¾nými
nedefinovanými hodnotami, které jsou typické pro vstupy nìkterých parciálních funkcí
jako je dìlení, kde hodnota je nedefinovaná pokud je dìlitel roven nule.
S parciálními funkcemi se mù¾eme vypoøádat tím, ¾e je explicitnì roz¹íøíme na funkce
totální nebo v pøípadì, je-li nedefinovaná hodnota detekována, znaènì sní¾íme jedincùv 
fitness.

\chapter{Návrh øe¹ení}
\label{sec:solution_design}

Jak ji¾ bylo øeèeno v kapitole \ref{sec:hashing}, navrhujeme-li ha¹ovací funkci "na
míru" nìjakému konkrétnímu univerzu klíèù, mù¾eme dosáhnout podstatnì lep¹í 
výkonnosti ha¹ovací funkce, ne¾ je tomu v pøípadì obecných ha¹ovacích funkcí.

\section{Problém}
Na¹im problémem bude navrhnout konkrétní ha¹ovací funkci pro ha¹ování domény
\texttt{IP} adres. Adresa \texttt{IP} je èíslo, jednoznaènì identifikující sí»ové
rozhraní v síti, která pou¾ívá internetový protokol \texttt{IP}. Vzhledem k tomu,
¾e budeme ha¹ovat èísla, nabízí se otázka, zda by nebylo vhodné pou¾ít tabulku
s pøímým pøístupem, tedy pou¾ít \texttt{IP} adresy pro pøístup do tabulky
pøímo bez vyu¾ití ha¹ování. Bohu¾el neznáme konkrétní interval nebo podmno¾inu
univerza \texttt{IP} adres a celé univerzum je pøíli¹ velké na to, aby jeho 
prvky mohly slou¾it jako èísla slotù do tabulky. Ve verzi 4 se jedná o 32 
bitové èíslo a verzi 6 dokonce o velikosti 128 bitù. Tabulka by tedy musela
mít $2^{32} = 4 294 967 296$ slotù v pøípadì  \texttt{IP} verze 4 a ve verzi 6
dokonce $2^{128} \approx 3×10^{38}$
slotù. Je vidìt, ¾e tabulky by byly opravdu velké a jejich pamì»ová nároènost
by byla nedostupná i pro specializované poèítaèe, uva¾ujeme-li, ¾e by takový
stroj mìl dìlat i nìco jiného, ne¾ uchovávat tak ohromnou tabulku. Musíme se
tedy uchílit k návrhu ha¹ovací funkce.

\section{Princip}
Ha¹ovací funkce budeme navrhovat evoluènímy algoritmy, konkrétnì za pou¾ití 
genetického programování. Zvoleno bylo genetické programování, proto¾e 
jako jedince populace vyu¾ívá programy. 

Z kapitoly \ref{sec:evolution_design}  víme, ¾e pro ohodnocení kvality jedincù
populace musíme nejprve programy spustit nad nìjakým vstupem. Na¹im vstupem
budou náhodnì vybrané \texttt{IP} adresy z celého rozsahu. Náhodnost je dùle¾itá,
abychom se vyhli funkcím, které ¹patnì zobecòují, viz pøíklad v kapitole 
\ref{sec:hashing}.
Jednotlivé jedince budeme nad tímto vstupem interpretovat a hodnotit
dle odolnosti vùèí kolizím a lavinového efektu.

\section{Pøinos práce}

V pøedchozí pracích zabývajícími se evoluèním návrhem ha¹ovacích funkcí 
\cite{grammar_evolution, safdari, NCHF_auto_design} bylo cílem navrhnout obecné
ha¹ovací funkce. V prvních dvou pøípadech se autoøi vydali cestou odolnosti vùèi
kolizím a v posledním pøípadì se kvalita øe¹ení posuzovala podle lavinového efektu.
Samotný lavinový efekt ha¹ovací funkce nezabezpeèí, ¾e funkce bude dobøe aproximovat
uniformní rozlo¾ení výstupu. Na druhé stranì, pøi návrhu obecné funkce se na 
odolnost proti kolizím coby kritérium kvality ha¹ovacích funkcí nedá spoléhat, nebo»
neznáme pøedem univerzum klíèù.

\section{Návrh fitness funkce}

V na¹em pøípadì ale nenavrhujeme obecnou ha¹ovací funkci. My navrhujeme specifickou
ha¹ovací funkci pro specifické univerzum hodnot. Proto mù¾eme pou¾ít jako kritérium
kvality odolnost vùèi kolizím, které je nepøímým ukazatelem toho, jak dobøe funkce
náhodnì distribuuje své výstupy.

Jako dal¹í komponentu do na¹eho kritéria zaøadíme je¹te lavinový efekt. Ten je 
dùle¾itým ukazatelem zejména z dùvodu dobrého zobecòování. Evaluovanou ha¹ovací
funkci budeme testoat nad náhodnými prvky univerza. Nìkdy se mù¾e stát, ¾e i funkce
s dobrým uniformním rozlo¾ením výstupù nebude pracovat správnì v praxi. To mù¾e být
zpùsobeno mnoha faktory, napøíklad ¹patnou volbou evaluaèních vstupù.
		 		 
Výsledná hodnota fitness bude brát v úvahu, oba faktory s vìt¹ím durazem na odolnost
vùèi kolizím.

\section{Zvolené parametry genetického programování}

V této sekci uvedeme, jaké parametry jsme zvolili parametry pro geneticé programování.

\subsection{Genetické operátory a selekce}

Operátory mutace pou¾ijeme ve dvou verzích. \textit{Podstromovou} mutaci a 
\textit{bodovou} mutaci zároveò. Budeme náhodnì volit mezi obìma alternativami, 
av¹ak pravdìpodobnost mutace ponecháme velmi nízkou. Pùvodní implementace algoritmù
genetického programování \cite{GPTutorial} operátor mutace vynechávaly úplnì. 
Budeme radìji volit cestu postupné pomaleji konvergující evoluce, ne¾ abychom 
nìjaká øe¹ení minuli.

Co se køí¾ení týka, v prvních verzích pou¾ijeme základní formu tedy \textit{podstromové}
køí¾ení, pozdìji jej mù¾eme porovnat i s pokroèilej¹ími technikami jako jsou 
\textit{jednobodové} a køí¾ení se zachováním kontextu. 

Selekci pou¾ijeme turnajovou a to zejména kvùli své determinitiènosti (jedince
sice musíme volit náhodnì, ale nemusíme se mezi nimi stochastiky rozhodovat). Dal¹ím dùvodem
je dobrá ¹kálovatelnost selekèního tlaku.

Poèáteèní populaci budeme generovat náhodnì bez pou¾ití jakýchkoli heuristik
a to metodou \textit{ramped-half-and-half}, která zaji¹»uje pro start algoritmu
kvalitní populaci co se rùznorodosti verlikostí a tvarù jedincù týká. 

\subsection{Mno¾ina terminálù a funkèních symbolù}

Mno¾inu vstupù zkonstruujeme z konstant a vstupních promìnných. Vstupní
promìnné vyrobíme z jednotlivých oktetù adres a budeme po¾adovat, aby ka¾dý
vstupní program obsahoval v¹echny promìnné právì jednou, tedy aby pracoval
s celou adresou. Jako konstanty budeme volit prvoèísla. Prvoèísla hrají 
dùle¾itou roli pøi operaci modulo. Pokud volíme jako argument modula nìjaké
násobky malých èísel jako je napøíklad èislo dvì, mù¾e se stát, ¾e funkce bude
mít tendenci seskupovat èísla dìlitelná dvìmi. Jako konstanty budeme volit
velká prvoèísla.

Mno¾inu funkcí zvolíme z bì¾ných operací. Vyhneme se cyklùm a jiným slo¾itým
øídícím konstrukcím, nebo» ha¹ovací funkce musí být také rychlá. Dal¹í
nevítanou skupinou operací jsou operace v plovoucí øádové èárce. My se tedy
spokojíme s dìlením beze zbytku. Výèet pou¾itých operaci a terminálù
popisují tabulky \ref{tab:function_set_design} a \ref{tab:terminal_set_design}.


%%%%%%%%%%%%% FUNCTION AND TERMINAL SETS %%%%%%%%%%%%%%%
\begin{table}
\begin{center}
\begin{tabular}{ |c|c| }
	\hline
	\multicolumn{2}{|c|}{Mno¾ina zvolených funkcí} \\
  	\hline			
   	Kategorie & Zástupci \\
  	\hline \hline  
  	Aritmetické celoèíselné & $\{ +,-,*,/,mod \}$ \\
  	Aritmetické             & $\{\}$ \\
  	Booleovské				& $\{AND, OR, NOT, XOR\}$ \\
  	Øídící                  & $\{IF-THEN-ELSE\}$ \\
  	Bitové					& $\{<<, >>\}$ \\ 	 
  	\hline
\end{tabular}
\caption{Zvolená mno¾ina funkcí}
\label{tab:function_set_design}
\end{center}
\end{table}

\begin{table}
\begin{center}
\begin{tabular}{ |c|c| }
	\hline
	\multicolumn{2}{|c|}{Mno¾ina zvolených terminálù} \\
  	\hline			
   	Kategorie & Zástupci \\
  	\hline \hline  
  	Promìnné       & samostatná promìnná pro ka¾dý oktet adresy \\
  	Funkce arity 0 & $\{ \text{vygeneruj\_prvocislo} \}$ \\	 
  	\hline
\end{tabular}
\caption{Zvolená mno¾ina terminálù}
\label{tab:terminal_set_design}
\end{center}
\end{table}
%%%%%%%%%%%%% FUNCTION AND TERMINAL SETS %%%%%%%%%%%%%%%


\chapter{Závìr}
\input{conclusion}

%=========================================================================