%=========================================================================

\chapter{Úvod}
\input{introduction}

\chapter{Ha¹ování}
\label{sec:hashing}
Ha¹ovací tabulky jsou dùle¾itou souèástí moderního svìta informaèních 
technologíí. Jsou to vyhledávací datové struktury, které nám za urèitıch
okolností umo¾ní vyhledávat, vkládat a mazat ulo¾ené polo¾ky s konstantní
èasovou slo¾itostí. Jedná se o jednu z nìkolika mo¾nıch implementací
asociativního pole. Ty dal¹í jsou napøíklad stromové implementace, 
implementace vázanım seznamem s lineáním prùchodem a dal¹í. ®ádnımi
z tìchto implementací se zde zabıvat nebudeme \cite{art_of_programming}.

\section{Princip}
Mìjme dané univerzum klíèù $U$, kde nìkteré klíèe $k \in U$ si pøejeme
asociovat s nìjakımi satelitnímy daty $v$, jejich¾ povaha není pro nás v
tuto chvíli dùle¾itá. Dále máme dynamickou mno¾inu $S = \{(k,v) | k \in u\}$
uchovávající klíèe s jejich satelitními daty. Pak nad mno¾inou $S$ chceme
pro nìjakı klíè $k$ a nìkteré její polo¾ky $x=(k, v)$ provádìt následující 
operace: 

\begin{enumerate}
	\item \textit{vkládání} dat, tedy operaci 
		$Insert(S,x) : S \to S \cup \{(k, v)\} $,

	\item \textit{mazání} dat, tedy operaci 
		$Delete(S,x) : S \to S - \{(k, v)\}$

	\item \textit{vıhledávání} satelitních dat podle zadaného klíèe,
		tedy operaci \newline $Search(S,k) : 
			\begin{cases}
				x 	: x.k = k \\
				nil : jinak 
			\end{cases} $
\end{enumerate}

Operace vyhledávání není totální, musíme tedy explicitnì vhodnì o¹etøit
pøípady, kdy se prvek $x=(k,v)$ v tabulce nevyskytuje.

Nejjedodu¹¹í implementací je \textit{tabulka s pøímım pøístupem} za
pøedpokladù, ¾e $|U|$ je pøijatelná. Uva¾me napøíklad univerzum
klíèu $U = \{0,1,2,3,\ldots,m-1\}$, a tabulku $T$ reprezentující
dynamickou mno¾inu $S$, pak nejjednodu¹¹ím pøístupem je pou¾ít jako
klíèe pøímo prvky mno¾iny $U$. Pak operace vyhledávání je rovna operaci
pøístupu do tabulky na zadanou lokaci, napøíklad $Search(T,k) = T[k]$
pro nìjakı klíè $k \in U$.

Mù¾e v¹ak nastat pøípad, kdy $m$ bude pøíi¹ velké èíslo. Typickım pøíkladem
jsou klíèe mno¾iny v¹ech mo¾nıch øetìzcù. Pak by tabulka s pøímım pøístupem
byla pøíli¹ velká a nevhodná pro moderní poèítaèe. Pokud potøebujeme 
vyhledávat pouze v nìjaké podmno¾inì $K \subset U$, kde $|K| << |U|$, je 
vhodné pou¾ít ha¹ovací funkci. Zjevnou vıhodou tabulek s pøímım pøistupem je slo¾itost
, která je $\theta (1)$ v nejhor¹ím pøípadì. Nevıhodou je pamì»ová nároènost
pro velká univerza $U$, kdy velká èást tabulky zùstane prázdná.

\subsection{Ha¹ovací funkce}
Ha¹ovací funkce je zobrazení, mapující prvky mno¾iny $U$ na jednotlivé 
sloty (indexy) tabulky $T$ :
$$ f_{hash} : U \to (0,1,\ldots,m-1)$$
za pøedpokladu, ¾e tabulka má právì $m-1$ slotù. Vyhledávací struktura 
slo¾ená z dynamické mno¾iny $S$ reprezentovanou tabulkou $T$ a ha¹ovací 
funkcí $f_{hash}$ se nazıvá \textit{ha¹ovací tabulka} 
viz. \ref{fig:hash_table_example}.

%%%%%%%%%%%%% HASH TABLE EXAMPLE %%%%%%%%%%%%%%%
\begin{figure}[!ht]
	\centering
	\includegraphics[scale=0.6]{fig/hash_table_example}	
	\caption{Princip fungování ha¹ovacích tabulek}
	\label{fig:hash_table_example}
\end{figure}
%%%%%%%%%%%%% HASH TABLE EXAMPLE %%%%%%%%%%%%%%%
 
Vzhledem k tomu, ¾e velikost tabulky je men¹í, ne¾ velikost univerza $|U|$,
budou nastávat kolize. Kolize je pøípad kdy, dva rùzné prvky univerza
$k_{1}, k_{2} \in U$ budou zobrazeny na stejnı slot : 
$f_{hash} (k_{1}) = f_{hash} (k_{2})$. S tímto neduhem se dá vypoøádat mnoha 
zpùsoby, jak uvidíme dále v sekci \ref{sec:collisions}.

\section{Kritéria kvality ha¹ovacích funkcí}

Shròme si nyní základní kritéria, která jsou dùle¾iá pro ha¹ovací funkce.

\subsection{Uniformní rozlo¾ení vıstupù}

Pro dokonalé uniformní rozlo¾ení ha¹ovací funkce bychom potøebovali \textit{náhodnı}
generátor a i kdybychom nìjakı mìli k dispozici, pak by sice dobøe dokázal 
rozprostøít jednotlivé prvky do ha¹ovací tabulky, nicménì vzhledem k jeho náhodné 
povaze bychom je jen tì¾ko zpìt dohledávali. Musíme tedy zvolit jinou 
alternativu. Ha¹ovací funkce musí bıt deterministická a musí dobøe aproximovat
uniformní rozlo¾ení. Uniformní rozlo¾ení vıstupù je pøedpokladem pro
nízkou èasovou slo¾itost ha¹ovacích algoritmù, jak je vidìt z pøíkladu
v sekci \ref{se:hash_function_design}.

\subsection{Odolnost proti kolizím}

Uva¾ujeme-li uniformní rozlo¾ení ha¹ovací funkce, pak dva klíèe u univerza
$U$ budou kolizní (dle \textit{birthday attack}) asi po $2^{\frac{m}{2}}$ 
operacích vlo¾ení\cite{NCHF_auto_design}. Pokud v¹ak ha¹ovací funkce nebude
uniformì distribuovat vısledky, pravdìpodobnost kolize se rapidnì zvı¹í.

\subsection{Lavinovı efekt}

Lavinovı efekt (angl. Avalanche effect) je vlastnost ha¹ovací funkce, pøi
které se rapidnì mìní vıstup ha¹ovací funkce pro malou zmìnu vstupu. 
Funkce které mají vysokı lavinovı efekt mohou odolávat problému shlukování,
pøi kterém se nìkteré èásti univerza mají tendenci shlukovat na vıstupu
do skupin.

\subsection{Rychlost}

Nesporná vıhoda ha¹ovacích tabulek je jejich rychlost. Dobøe navr¾ená ha¹ovací
tabulka dosahuje za urèitıch okolností slo¾itosti $\theta (1)$. Pokud je v¹ak
vıpoèetní algoritmus pøíli¹ slo¾itı, mù¾e daná funkce bıt pomalá. Je proto
nutné dbát na to, ¾e pøíli¹ pomalı, i kdy¾ dobrı algoritmus nemusí bıt
v¾dy ten nejlep¹í. 

\section{Návrh ha¹ovací funkce}
\label{se:hash_function_design}

V praxi je èasto sly¹et názor, ¾e ha¹ovací funkce pracují v konstantním èase.
To v¹ak není pravda, nebo» vıkon ha¹ovací funkce zále¾í jednak na faktoru
zatí¾ení ha¹ovací tabulky a uniformnosti, s jakou doká¾e ha¹ovací funkce
pøíøazovat klíèe do slotù.

Zamìøme se nejprve na zatí¾ení tabulky a uva¾me nìjakou podmno¾inu univerza
v¹ech klíèù $K \in U$, ha¹ovací tabulku $T$ s $m$ sloty a oznaème $n = |K|$.
Pokud $n$ bude men¹í ne¾ $m$, pak ha¹ovací tabulka bude skuteènì pracovat v 
$\theta (1)$, za pøedpokladu uniformního rozlo¾ení ha¹ovací funkce. Pokud ale
bude $m$ men¹í ne¾ $n$, faktor zatí¾ení bude vìt¹í ne¾ jedna a ha¹ovací tabulka
v konstantním èase pracovat nebude. Uva¾me $m=4$ a $n=5$. Pak za pøedpokladu
uniformního rozlo¾ení ha¹ovací funkce, s vlo¾ením pátého prvku bude ha¹ovací 
tabulka plná a nám nezbude ne¾ vkládanı prvek zaøadit na zaèátek jednosmìrnì
vázaného seznamu.

Existuje mnoho metod pro konstrukci ha¹ovací funkce, jako jsou napøíklad
\textit{metoda násobení}, \textit{metoda dìlení} a dal¹í komplikovanìj¹í
pøístupy. V souèasné dobì existují velmi dobré implementace obecnıch ha¹ovacích funkcí.
Av¹ak ¾ádná ha¹ovací funkce nemù¾e pracovat pro v¹echna mo¾ná univerza stejnì
dobøe. Jako pøíklad uva¾ujme ha¹ovací funkci navr¾enou metodou dìlení :
$$ f_{hash}(k) = k \text{ mod } 8 $$ 
a dále uva¾ujme univerzum $U = \mathbb{N}$ a jeho
podmno¾inu $K = \{1,2,3,4,8,13,22,71\}$, kterou budeme vkládat do tabulky.
Ha¹ovací funkce je schopna ulo¾it $8$ ruznıch hodnot a v pøípadì 
na¹eho vıbìru mno¾iny $K$, se nám podaøí ulo¾it v¹echny, ani¾ by do¹lo ke kolizi.
Co by se ale stalo, pokud bychom byli omezení na univerzum pouze tìch
pøirozenıch èisel, která jsou dìlitelné osmi $U = \{x \in \mathbb{N}
\land x \text{ mod } 8 = 0\}$? Nemohli bychom vybrat ¾ádnou podmno¾inu 
$F \in U$ takovou, kterou by funkce $f_{hash}$ nezobrazila pouze na jeden
slot.

Je vidìt, ¾e pokud máme informace o univerzu mo¾nıch klíèù, mù¾eme navrhnout
ha¹ovací funkci 'na míru' tak, aby mìla lep¹í vlastnosti, ne¾ obecná
ha¹ovací funkce. Tento úkol je v¹ak obtí¾nı a neexistuj pro nìj obecnı
návod jak toho docílit. Musíme se spolehnout na zku¹enosti, znalosti a v 
neposlední øadì také na intuici. Nebo mù¾eme zvolit úplnì jinı pøístup
jak napovídá kapitola \ref{sec:evolution_design}.

\subsection{Merkle-Damg\r{a}rdovo konstrukèní schéma}
V oblasti kryptografickıch ha¹ovacích funkcí se Merkle-Damg\r{a}rdovo schéma \cite{merkle0} jedním ze základních
stavebních kamenù moderních kryptografickıch ha¹ovacích funkcí.
Dokazují to nesèetné implementace state of the art ha¹ovacích funkcí na nìm zalo¾ené. Jako
pøklad mù¾eme uvést algoritmy \textit{MD5} \cite{rfc1321}, \textit{SHA-1} \cite{rfc3174},
\textit{SHA-2} \cite{rfc4634} nebo \textit{Tiger} \cite{tiger}.

Jedná se o obecné schéma pro vıstavbu ha¹ovacích funkcí odolnıch proti kolizím z jednosmìrnì
kompresní funkce. Schéma se skládá z $n$ blokù pevné délky reprezentující vstupní zprávu.
K nim korespondují jednosmìrné kompresní funkce. Ka¾dá kompresní funkce má na vstupu blok vstupních dat,
vıstup pøedchozí kompresní funkce a produkuje vıstup. Velikosti obou vstupu a vıstupu jsou toto¾né,
proto nazıváme funkce kompresní. Poslední èlánek v øetìzu kompresních funkcí pøedstavuje vhodné 
zarovnání. Nìkdy se také pou¾ívá volitelna finalizaèní komponenta. Schéma blí¾e ilustruje obrázek 
\ref{fig:merkle_damgard}.

Bylo nezávisle ukázáno, ¾e pokud je pou¾itá vhodná 'vata'
(angl. \textit{padding}) pro zarovnání na správnou velikost a kompresní funkce jsou odolné
proti kolizím, pak vzniknuv¹í ha¹ovací funkce je také odolná proti kolizím \cite{damgard0}.

Dùvodem, proè se zde zabıváme kryptografickım schématem je, ¾e jej pou¾ívají i mnohé nekryptografické
ha¹ovací funkce. I pøes to, ¾e tyto funkce nejsou kryptograficky bezpeèné (co¾ ani není úèelem zavedení
Merkle-Damg\r{a}rdova shématu), pou¾ití kryptografického schématu dodá do ha¹ovací funkce dodateènou 
náhodnost. Pou¾itím schématu docílíme v evoluèním algoritmu znaèného zmen¹ení prohledávaného prostoru
a tedy lep¹í a rychlej¹í konvergence algoritmu viz. dále kapitola \ref{sec:evolution_design}.

Kromì Merkle-Damg\r{a}rdova schémata, exitují i jiná konstrukèní schémata, napøíklad Merkleho strom 
\cite{merkle1}, èasto pou¾ívanı v \textit{P2P} sítích,
struktura \textit{HAIFA} \cite{haifa} pou¾itá v rodinì kryptografickıch ha¹ovacích funkcí \textit{BLAKE}
nebo funkce \textit{Sponge} \cite{sponge}. Tìmito se zde v¹ak zabıvat nebudeme.

 
\begin{figure}
	\centering
	\includegraphics[width=\textwidth]{fig/merkle_damgard}
	\caption{Obecné Merkle-Damg\r{a}rdovo schéma pro $n$ blokù.}
	\label{fig:merkle_damgard}
\end{figure}

\section{Øe¹ení kolizí pøi ha¹ování}
\label{sec:collisions}

Situaci, kdy ha¹ovací funkce zobrazí dva rùzné klíèe na tentı¾ slot:
$f_{hash} (k_{1}) = f_{hash} (k_{2})$ nazıváme ha¹ovací kolize nebo jen kolize. 
Kolize jsou ne¾ádoucím dùsledkem pou¾ití ha¹ovacích funkcí
a chceme se jim pokud mo¾no vyhnout, nebo» zásadním zpùsoben negativnì ovlivòují 
èasovou slo¾itost asociativních polí, které jsou na ha¹ovacích funkcích postavené. 
Pro dobré pochopení kolizí je nezbytné uvést míru zaplnìní ha¹ovací tabulky
neboli takzvanı faktor zatí¾ení $\alpha$ definovanı vztahem $\alpha = \frac{n}{m}$.
Právì èasová slo¾itost tabulky zále¾í za pøedpokladu uniformního rozlo¾ení 
ha¹ovací funkce právì na \textit{faktoru zatí¾ení}. 

Pou¾itím kvalitní ha¹ovací funkce mù¾eme riziko kolizí do jisté míry minimalizovat, ale
s narùstajícím faktorem zatí¾ení $\alpha$ roste i riziko kolize, které dosáhne 
urèitosti pøi $\alpha = 1$, tedy v ha¹ovací tabulce není ji¾ ¾ádnı volnı slot.
V takovém pøípadì musíme kolizi vhodnım zpùsobem øe¹it. Zpùsobù jak takovou sitaci
øe¹it je mnoho. My si v této sekci uvedeme ty, které jsou pro na¹i práci podstatné.

\subsection{Zøetìzené ha¹ování}

\begin{figure}
	\centering
	\begin{subfigure}[b]{0.49\textwidth}
		\includegraphics[width=\textwidth]{fig/chained_hashing_insert}
		\caption{Operace vlo¾ení nového prvku do ha¹ovací tabulky zpùsobí kolizi klíèù.}
	\end{subfigure}
	\begin{subfigure}[b]{0.49\textwidth}
		\includegraphics[width=\textwidth]{fig/chained_hashing_insert_result}
		\caption{Kolidovaná data se zøetìzí v jednosmìrnì vázaném seznamu.}
	\end{subfigure}
	\caption{Demonstrace øe¹ení kolize za pou¾ití vázaného seznamu.}
	\label{chained_hashing}
\end{figure}

Nejjednodu¹¹í a nejznámìj¹í formou øe¹ení kolizí je øetìzení dat v daném slotu. Jednotlivé 
sloty jsou reprezentovány jednosmìrnì vázanım seznamem, jeho¾ polo¾ky tvoøí data dohromady
s klíèem. Èasová slo¾iost takové implementace je:
\begin{itemize}
	\item v nejhor¹ím pøípadì $\theta (n)$, kdy v¹echny prvky budou namapovány
	na jeden slot,
	\item v prùmìru bude $\theta (1 + \alpha)$, za pøedpokladu
	uniformního rozlo¾ení, kdy pravdìpodobnost namapování libovolného
	prvku na konkrétní slot je $\frac{1}{m}$.
\end{itemize}

Èasovou slo¾itost lze vylep¹it vhodnou heuristikou, jakou mù¾e bıt napøíklad sledování
èetnosti vyhledávání danıch klíèù s následnım vhodnım pøeuspoøádáním jednosmìrnì vázaného
seznamu. Prostorová slo¾itost této implementace také narùstá, nebo» souèástí ka¾dé polo¾ky jednosmìrnì
vázaného seznamu \textit{ll} je i ukazatel na dal¹í prvek potøebnı pro získání
dal¹ího prvku seznamu \textit{next(ll)}. Øe¹ení kolizí zøetìzením kolidovanıch 
polo¾ek do jednosmìrnì vázaného seznamu poskytuje za pøedpokladu uniformního rozlo¾ení dobré
vısledky a je vıraznì rychlej¹í ne¾ samotnı jednosmìrnì vázanı seznam. Existují v¹ak i jiné
pøístupy, nabízející lep¹í vlastnosti.

\subsection{Kukaèèí ha¹ování}

Kukaèèí ha¹ování je moderní pøístup k øe¹ení ha¹ovacích kolizí, za pou¾ití dvou a více ha¹ovacích
funkci a jedné nebo více tabulek \cite{Cuckoo_hashing}. Èastá implementace zahruje pouze jednu
tabulku, v ní¾ má ka¾dá ha¹ovací funkce vyhrazena vlastní prostor. Uva¾ujme univerzum klíèù $U$
a velikosti ha¹ovací tabulky $m$. Pak na pøíklad pro dvì ha¹ovací funkce 
$h_1, h_2$, kde $h_1 : U \rightarrow \{0,\ldots,r_1-1\}$ a $h_2 : U \leftarrow \{r_1,\ldots,r_2-1\}$ musí platit
$|\{0,\ldots,r_1-1\} \cup \{r_1,\ldots,r_2-1\}| = m$ a celkovı poèet slotù ha¹ovací tabulky je $m$.

Opakem je implementace, kdy ka¾dá ka¾dá ha¹ovací fukce obsluhuje dedikovanou tabulku. Zde pro
jiné dvì funkce $h_3, h_4$ tvaru $h_3 : U \rightarrow \{0,\ldots,r_1-1\}$ a $h_4 : U \leftarrow \{0,\ldots,r_1-1\}$
musí opìt platit $|\{0,\ldots,r_1-1\} \cup \{0,\ldots,r_1-1\}| = m$. Tedy ¾e ha¹ovací funkce musí dokonale pokrıt
celou ha¹ovací tabulku.

Název Kukaèèí ha¹ování je odvozen z chování nìkterıch druhù kukaèek, kdy kukaèky vytlaèují vejce nebo své mladé
z hnízda. Toto chování je velmi podobné operaci vkládání. I pøes to, ¾e se rozhraní operace $Insert(S,x)$ nemìní 
, vıraznì se mìní její vnitøní implementace. Operace vlo¾ení prvku do tabulky, vybere jednu z dostupnıch ha¹ovacích
funkcí a pokusí se vlo¾it prvek na pøíslu¹né místo. Dojde-li ke kolizi, pùvodní prvek je vytlaèen a nahrazen prvkem novım.
Vytlaèenı prvek je znovu vlo¾en do tabulky, av¹ak za pou¾ití jiné ha¹ovací funkce. Tento postup se opakuje tak dlouho, dokud
dochází pøi vkládání ke kolizím. Zøejmì tímto zpùsobem mù¾e docházet k cyklùm. Maximální poèet po sobì jdoucích vlo¾ení je tedy
omezen konstantou. Celı proces blí¾e demonstruje algoritmus \ref{alg:cuckoo_hashing} a obrázek \ref{fig:cuckoo_hashing}.

\begin{figure}
	\centering
	\begin{subfigure}[b]{0.53\textwidth}
		\includegraphics[width=\textwidth]{fig/cuckoo_hashing_insert}
		\caption{Kolize je øe¹ena za pou¾ití druhé ha¹ovací funkce.}
	\end{subfigure}
	\begin{subfigure}[b]{0.46\textwidth}
		\includegraphics[width=\textwidth]{fig/cuckoo_hashing_insert_result}
		\caption{Data v tabulkce se po nìkolikanásobném vytlaèení ustálí.}
	\end{subfigure}
	\caption{Demostrace øe¹ení kolize za pou¾ití kukaèèího ha¹ování.}
	\label{fig:cuckoo_hashing}
\end{figure}

Pokud v prùbìhu operace dosa¾eno mezní hodnoty $MaxLoop$, pøedpokládáme ¾e jsme narazili na cyklus. V takovém pøípadì 
provedeme nejprve operaci \Call{rehash}{} a poté zkusíme prvek vlo¾it opìtovnım zavoláním funkce \Call{insert}{x}.
Funkce \Call{rehash}{} zaji¹»uje, aby pøi opìtovném vlo¾ení prvku do tabulky znovu nevzniknul cyklus. Toho se dá
dosáhnout napøíklad pou¾itím jinıch ha¹ovacích funkci \cite{Cuckoo_hashing}. Není tøeba znovu vytváøet ha¹ovací tabulku,
postaèí ha¹ovací tabulku projít a na ka¾dı prvek uplatnit nejprve operace \Call{delete}{x}, která jej z tabulky odstraní 
a následnì jej znovu vlo¾it za pou¾ití operace \Call{insert}{x}.

\begin{algorithm}
\begin{algorithmic}
\Function{insert}{x}
	\Repeat
		\State $x \leftrightarrow T_1[h_1(x)]$
		\If {$x = \bot$} \Return \EndIf
		\State $x \leftrightarrow T_2[h_2(x)]$
		\If {$x = \bot$} \Return \EndIf
	\Until{$!MaxLoop$}
	\State \Call{rehash}{}; \Call{insert}{x}
\EndFunction
\end{algorithmic}
\caption{Pseudokód popisující operaci $insert$ za pou¾ití kukaèèího ha¹ování.}
\label{alg:cuckoo_hashing}
\end{algorithm}

Èasová slo¾itost vıhledávání v tabulce za pou¾ití Kukaèèího ha¹ování je v prùmìru $\theta(1)$. Pro nás je ale
dùle¾itìj¹í, ¾e èasová slo¾itost v nejhor¹ím pøípadì zustává také konstantní. Je v¹ak dùle¾ité zohlednit 
následující faktory:
\begin{itemize}
	\item Je nutné pou¾ít takové ha¹ovací funkce, které dobøe uniformì distribuují svoje vıstupy. Pokud by tento
	pøedpoklad nebyl splnìn, mù¾e bıt (a pravdìpodobnì bude) èasto volána nákladná operace \Call{REHASH}{}.

	\item Operace \Call{REHASH}{} nezvìt¹uje ani nezmen¹uje kapacitu ha¹ovací tabulky. Vzhledem k tomu, ¾e ka¾dı slot
	ha¹ovací tabulky pojme právì jeden klíè, maximální faktor zatí¾ení $\alpha$ je právì roven jedné (co¾ je pøesnı
	opak chování zøetìzeného ha¹ování, kdy za pou¾ití vázaného seznamu snadno dosáhneme $\alpha \geq 1$).

	\item Je dobré poèítat s tím, ¾e i za pou¾ití více ha¹ovacích funkcí se koeficientu $\alpha = 1$ pøiblí¾íme jen
	vzdálenì. Opìtovné pokusy o vlo¾ení prvku do tabulky, která má ji¾ koeficient $\alpha \approx 1$ nevyhnutelnì
	vyústí ve volání funkce \Call{REHASH}{}. Je tedy vhodné podrobit Kukaèèí ha¹ování nìjaké formì heuristiky, kdy
	bude její kapacita ve vhodnı okam¾ik zvìt¹ena, aby nedocházelo k opakovanému volání funkce \Call{REHASH}{}.
\end{itemize}

\section{Analıza existujících øe¹ení}
Cílem této sekce je podat pøehled o existujících state of the art obecnıch ha¹ovacích funkcích, proto¾e nìkterımi z tìchto
funkcí budeme porovnávat námi navr¾ené ha¹ovací funkce. Také budeme analyzovat, z jakıch elementárních operací se 
dané ha¹ovací funkce skládají, co¾ nám poslou¾í pøedev¹ím pro návrh mno¾iny funkcí dále viz. kapitola  
\ref{sec:solution_design}. 

\textit{MurmurHash2} \cite{murmurhash2}, \textit{MurmurHash3} \cite{murmurhash3} \textit{FarmHash} \cite{farmhash}, \textit{CityHash} \cite{cityhash_slides}

\chapter{Evoluèní návrh}
\label{sec:evolution_design}

% Chapter INTRO
Evoluèní návrh je netradièní disciplína, která vyu¾ívá evoluèní algoritmy
k návrhu. Evoluèní algoritmy spadají do oblasti umìlé 
inteligence. Specifickou vlastností mnoha úloh spadajících do obasti umìlé 
inteligence je, ¾e èasto vhodnım zpùsobem prohledávají prostor $U$,
reprezentující v¹echna mo¾ná øe¹ení (kandidátní) dané úlohy 
\cite{evolution_hardware}. Evoluèní algoritmy se dají pova¾ovat za speciální metodou 
prohledávání prostoru kandidátních øe¹ení.

% Section Natural computing
\section{Poèítání podle pøírody}
\label{sec:natural_computing}
Poèítání podle pøírody (Natural computing) je sohrnı termín pro tvorbu 
inteligentních strojù napodobováním biologickıch procesù, chování ¾ivıch 
tvorù nebo jejich mechanismù. Øadíme sem také vıpoèetní paradigmata, která 
svoji inspiraci nalezla v pøírodních procesech nebo pou¾ití organismù a 
jinıch netradièních materiálù jako vıpoèetních platforem. Míra do jaké je 
pøírodní fenomén napodoben se rùzní. Od Témìø úplného napodobení a¾ po 
inspiraci. 

Jedním z motivù pro vznik alternativních vıpoèetních pøístupù a poèítání 
podle pøírody je lep¹í splynutí s reálnım svìtem a jeho probémy.
V tomto kontextu je vhodné zmínit \textit{soft-computing}. \textit{Soft-computing}
je podmno¾inou poèítání podle pøírody, bıvají sem zaøazovány 
neuronové sítì, \textit{Support Vector Machines}, fuzzy systémy, evoluèní 
algoritmy a teorie chaosu. Postupy spadající do \textit{Soft-computing} 
tolerují nepøesnosti a nejistotu èím¾ dosahují vysoké robustnosti a 
lep¹ího vztahu s realitou. Poèítání podle pøírody ve svùj prospìch pou¾ívá 
procesy zejména fylogeneze, ontogeneze a epigeneze. Fylogeneze oznaèuje proces
evoluce druhù, ontogeneze proces vıvoje mnohobunìèného organismu a epigeneze
je nìjakı proces, kterı nastává v ji¾ slo¾itìj¹ím organismu 
(sem øadíme napøíklad neuronové sítì).
Dále se se poèítání podle pøíody inspirovalo procesy vznikajícími ve spoleènosti, 
v usuzování jedincù apodobnì. My se zde budeme zabıvat hloubìji pouze fylogenezí, nebo» 
právì na ní je zalo¾ena my¹lenka evoluèních algoritmù.

\section{Evoluèní algoritmy}

Fylogeneze je proces evoluce druhù. Evoluce je umo¾nìna schopností reprodukce jednotlivıch
jedincù, kdy potomkové se od svıch roduèù li¹í jen velmi málo. Pøi reprodukci v¹ak dochází také
k náhodnım obèasnım mutacím, které zabezpeèují dostateènou diferzitu a vzniká tak novı
genetickı materiál. Na fylogenezi jsou zalo¾ené evoluèní algoritmy. 

Evoluèní algoritmy lze chápat jako speciální optimalizaèní metodu nad prostorem 
$$U = D_{1} \times D_{2} \times D_{3} \times \ldots \times D_{n}$$
v¹ech kandidátních øe¹ení. Takovı prostor je pak kartézskı souèin domén, kde
jednotlivé domény univerza mohou nabıvat
hodnot z pøedem známıch, èasto nìjak omezenıch intervalù \cite{evolution_hardware}.  

V matematické optimalizaci, bychom se sna¾ili hledat hodnoty $x \in U$ takové,
pro které je hodnota úèelové funkce
$$ f : U \to \mathcal{R} $$
minimální (hledání maxima lze úpravou úèelové funkce pøevést na hledání minima).
Minima mohou bıt globální nebo lokální, ostrá nebo neostrá. Øe¹íme tedy úlohu,
kdy hledáme nìjakı argument, jeho¾ hodnota úèelové funkce spadá do mno¾iny optimálních
hodnot úèelové funkce \cite{nlprog}.
$$ argmin_{x}\{f(x)|x \in U\} $$		
V kontextu evoluèních algoritmù nazıváme $f$ funkcí \textit{fitness} a nehledáme 
argument $x$, pro nìj¾ je funkce $f$ minimální, ale postaèuje nám najít argument $x$ 
takovı, ¾e $f(x)$ splní nìjaké pøedem dáné ukonèovací podmínky.

\subsection{Princip}
Evoluèní algoritmy jsou inspirované procesem reprodukce jedincù napøíè generacemi.
Na zaèátku vıpoètu algoritmu vytvoøíme poèáteèní populaci $P_{0}$, tj.
populaci generace nula o pøedem známé velikosti $n$.
Volba jedincù do poèáteèní populace jsou rùzné, mù¾eme napøíklad sáhnout po náhodném 
vıbìru nebo volit jedince za pou¾ití vhodné heuristiky.

%$$ \mathcal{P}_{0} = \{x|x \in U \land vyber\_do\_poèáteèní\_populace(x) \} $$

V ka¾dém dal¹ím kroku evoluèního algoritmu, kterı nazıváme generace, je nejprve vybráno
$m$ vhodnıch jedincù z generace pøedchozí $P_{t - 1}$, kteøí nám tvoøí mno¾inu rodièù. Aplikací
genetickıch operátorù nad mno¾inou rodièù vznikne mno¾ina potomkù, Následnì se z obou
mno¾in vybere nová generace $P_{t}$ o velikosti $n$ a celı process (znázornìn na diagramu \ref{fig:eaflow})
se opakuje. Zpùsoby vıbìru rodièu jsou rùzné stejnì
tak jako mo¾né genetické operátory. Obìma se budeme zabıvat pozdìji.

%%%%%%%%%%%%% EVOLUTION ALGORITHM FLOWCHART %%%%%%%%%%%%%%%
\begin{figure}[!ht]
	\centering
	\includegraphics[scale=0.4]{fig/evolution_algorithm_flowchart}	
	\caption{Obecnı postup vıpoètu evoluèního algoritmu}
	\label{fig:eaflow}
\end{figure}
%%%%%%%%%%%%% EVOLUTION ALGORITHM FLOWCHART %%%%%%%%%%%%%%%

\subsection{Fitness funkce}
Fitness funkce je obdoba úèelové funkce z oboru matematické optimalizace. Název fitness
pochází z oboru evoluèní biologie, kde hodnota fitness popisuje biologickou zdatnost jedince
\cite{evolution_hardware}. Vstupem fitness funkce je (v jednodu¹¹ím pøípadì) jedinec
reprezentovanı chromozomem a vıstupem je hodnota reprezentující zdatnost jedince.

Ve slo¾itìj¹ích pøípadech je nutné rozli¹ovat mezi prostorem genotypù a fenotypù. Genotypem
nazıváme v kontextu evoluèních algoritmù prostor v¹ech mo¾nıch øe¹ení, tedy 
v¹ech mo¾nıch chromozomù. Fenotyp je soubor charakteristik, projevù a chování,
jimi¾ se danı jedinec reprezentovanı urèitım chromozomem projevuje.
Zobrazení z prostoru genotypù do prostoru fenotypù lze potom vyjádøít následovnì:
$$ f_{phenotype} : U \to \mathcal{F}, $$
Potom je v¹ak nutné modifikovat na¹i fitness funkci následovnì :
$$ f : \mathcal{F} \to \mathcal{R} $$
a celı proces evaluace jedince bude poté kompizice tìchto dvou funkcí :
$$ f_{eval} = f \circ f_{phenotype}$$

Volba pota¾mo návrh vhodné fitness funkce je znaènì obtí¾ná. Neexistuje ¾ádnı obecnı
pøedpis pro jejich návrh. Musíme se spoléhat na obecná pravidla, zku¹enosti nebo 
intuici. Velké mno¾ství dobøe zakomponovanıch informací o problému ve fitness funkci je
dobrım základem pro úspì¹nı evoluèní algoritmus. Obecnì tedy platí, ¾e 
vhodnì zvolená fitness funkce má znaènı dopad na kvalitu vısledného øe¹ení.

\subsection{Zpùsoby selekce}
Zpùsoby selekce jsou dùle¾itım faktorem pøi návrhu evoluèního algoritmu. Selekce
je proces, pøi nìm¾ se vybırají rodièe z aktuální populace urèení k reprodukci. 
Dobrı selekèní algoritmus musí bıt schopen upøednostòovat jedince s vysokou hodnotou
fitness funkce, na druhou stranu musí zajistit dostateèné mno¾ství genetického 
materiálù pro dal¹i generace. Èasto vyu¾ívané selekèní mechanismy, zejména v kontextu
genetickıch algoritmù jsou napøíklad \cite{selection_schemes_comparison} :

\begin{itemize}
	\item \textit{deterministická selekce}, kde se do mno¾iny rodièù vybere $k$
		jedincù z aktuální populace s nejvy¹¹í hodnotou fitness,
		
	\item \textit{proporcionlní selekce}, kde pravdìpodobnost vıbìru jedince $i$ je 
		rovna vztahu $p_{i} = \frac{f(i)}{\sum_{j=1}{N} f(j)}$,
		
	\item \textit{turnajová selekce}, kdy je v nìkolika kolech turnaje postupnì 
		porovnáno nìkolik náhodnì vybranıch jedincù a vítìz turnaje je zaøazen
		do mno¾iny rodièù. Turnaj provedeme $n$-krát, kde $n$ je po¾adovaná mohutnost
		mno¾iny rodièù. 
\end{itemize}

\subsection{Genetické operátory}
Evoluèní algoritmy vyu¾ívají køí¾ení i mutaci, oba mechanismy jsou pøevzaty z
oboru bunìèné biologie, kde se uplatòují v procesu redukèního dìlení bunìk.

Operátor mutace se aplikuje na potomka
a vytvoøí z nìj potomka mutovaného. Stejnì jako v biologii, mutace se vyskytuje
pouze v malém poètu pøípadù. Na¹im cílem je prozkoumat prostor $U$ postupnì a
konvergovat k dobrım øe¹ením. V pøípadì vysoké pravdìpodobnosti mutace se ji¾
nejedná o algorigmus \textbf{evoluèní}, nıbr¾ \textbf{revoluèní} a algoritmus pøipomíná 
spí¹e náhodné prohledávání. Operátor mutace je velmi dùle¾itı, nebo» zanesení
náhodne mutace zaji¹»uje novı genetickı materiál, èím¾ je algoritmus jednou za
èas nucen prozkoumat vzdálenìj¹í bod prostoru. Neuvázne tak v lokálních extrémech.

Pøi køí¾ení dochází k pøenosu èástí chromozomù rodièù na potomka. Zpùsobù køí¾ení
existuje celá øada. Obecnì v¹ak platí, ¾e zpùsob køí¾ení je závislı na zvolené 
reprezentaci. Pokud máme jedince reprezentovaného grafem, operátor køí¾ení 
se bude znaènì odli¹ovat od pøípadu, kdy máme jedince reprezentovaného binárním
vektorem. 

Uveïmì si zde alespoò nejznámìj¹í druhy køí¾ení nad binární reprezentaci, jimi¾ jsou:
\begin{itemize}
	\item \textit{jednobodové køí¾ení}, kdy se urèí místo køí¾ení urèující,
		která èást chromozomu doputuje do potomka.
		
	\item \textit{dvoubodové køí¾ení} je obdobou vı¹e zmínìného, av¹ak pro dva body
		køí¾ení a
	\item \textit{uniformní køí¾ení}, které je do znaèné míry zobecnìním vı¹e zmínìnıch.
		 Urèí $n$ genù v chromozomu, jejich¾ hodnoty jsou vystøídány.
\end{itemize}

\subsection{Návrh evoluèního algoritmu}

Kvalita námi navr¾eného evoluèního algoritmu, je zejména závislá na následujících faktorech:
\begin{enumerate}
	\item reprezentace problémù a jeho kódování,
	\item pou¾itá fitness funkce,
	\item zobrazení z prostoru genotypù do prostoru fenotypù,
	\item volbou genetickıch operátorù a zpùsoby selekce,
	\item nastavením parametrù genetického algoritmu.
\end{enumerate}

Prostor ka¾dého problému øe¹itelného evoluènímy algoritmy je jinı. Neexistuje tedy obecnı
evoluèní algoritmus, kterı by kvalitnì øe¹il v¹echny problémy. Toto tvrzení podporuje takzvanı
\textit{No Free Lunch} teorém. Pokud uvá¾íme dostateènì velkı poèet optimalizaèních problémù,
neexistuje ¾ádnı optimalizaèní algoritmus, kterı projde ka¾dı bod prostoru $U$ právì jednou
a v prùmìru bude efektivnìj¹í ne¾ ostatní optimalizaèní algoritmy \cite{nflteorem, evolution_hardware}. 
Z tohoto tvrzení plyne, ¾e chceme-li øe¹it optimalizaèní problém skuteènì efektnivnì, musíme 
do na¹eho evoluèního algoritmu \textbf{vlo¾it co nejvíce informací} o problému prostøednictvím 
zejména polo¾ek zmínìnıch vı¹e.

\subsection{Genetické algoritmy}

Evoluèní algoritmy popisují mno¾inu algoritmù, jejich¾ èinnost je urèena procesem Darwinovské
evoluce. Na druhé stranì je v¹ak neomezuje natolik, aby se od sebe nemohly (nìkdy i velmi
vıznamnì) li¹it.

Asi nejvıznamìj¹ím ¾ástupcem evoluèních algoritmù jsou genetické algoritmy. Jedinci jedné populace
jsou reprezentovány øetìzcem (chromozomem) binárních, celoèíselnıch nebo i reálnıch hodnot.
Iniciální populace vzniká buï náhodnì nebo za pou¾ití vhodné heuristiky. Uplatòují se zde v¹echny
bì¾né selekèní mechanismy a stejnì tak zde najdeme pou¾ity v¹echny druhy metod køí¾ení.
Mutace se takté¾ pou¾ívá. Nevıhodou mohou nìkdy bıt chromozomı pevné délky.

\subsection{Evoluèní strategie}

Dal¹ím zajímavım algoritmem jsou evoluèní strategie. Jejich nejvìt¹í zajímavostí je, ¾e
se spoléhají pouze na operátor mutace. Køí¾ení se zde nevyskytuje. Nové generace se zde
vytváøejí zejména tak, ¾e rodièovská populace je mutována pøiètením hodnoty normálního rozlo¾ení s nulovou
$x' = x + \mathcal{N}(0, \sigma)$
støední hodnotou. Rozptyl $\sigma$ se mìní na základì toho, jak dobøe algoritmus aktuálnì
konverguje. Jako selekèní mechanismy se u¾ívá totální elitismus ve variantách $(\mu + \lambda)$
a $(\mu, \lambda)$ \cite{ES}. Uva¾ujeme-li $\mu$ mno¾inu rodièù a $\lambda$ mno¾inu jejich
potomkù, pak :

\begin{itemize}
	\item $(\mu + \lambda)$ vybere do dal¹í generace nejlep¹í jedince z mno¾iny
		rodièù a potomku
	\item $(\mu, \lambda)$ vybere do dal¹í generace jen ty nejlep¹í potomky. Rodièovská
		generace tedy vymírá.
\end{itemize} 

\section{Genetické programování}

Pro na¹í práce je zejména zajímavé genetické programování, nebo» právì to jsme zvolili 
jako evoluèní algoritmus pro øe¹ení na¹eho problémù. Seznámíme se s ním podrobnìji a 
proto mu vìnujme celou sekci.

Genetické programování je speciálním druhem evoluèního algoritmu, kde jednotlivce a 
celé populace tvoøí poèítaèové programy. Vıpoèet iterativnì transformuje poèítaèové
programy na jiné poèítaèové programy aplikací genetickıch operátorù, které jsou 
pro genetické programování specifické. Vıstupem genetického algoritmu
je v pøípadì, ¾e uspìje, nìjakı program. 

\subsection{Reprezentace}
Evolvované programy musíme vhodnì reprezentovat. Musíme pøí tom klást dùraz na to,
¾e programy je mezi sebou tøeba køí¾it, mutovat a obecnì na nich provádìt nutné
genetické operace. Na druhé stranì v¹ak chceme volit takovou reprezentaci, která
nám umo¾ní programy evaluovat, tudí¾ vykonávat je nad zadanım vstupem. 

Jedinci v populaci jsou reprezentování radìji jako \textit{abstraktní syntaktické stromy}
\cite{GPTutorial} ne¾ jako øádky programu. Ukázka jedince v geneticém programování je na
diagramu \ref{fig:exampletree1} a zobrazuje jedince reprezentovaného programem
\texttt{max(min(x,y), 5 + z)}. Stromy se skládají z uzlù a listù. Listy jsou
reprezentovány terminálním symbolem z mno¾iny terminálù $T$ a uzly jsou reprezentovány
funkcí z mno¾iny $F$. Na diagramu \ref{fig:exampletree1} mno¾inu funkcí tvoøí 
$F = \{max, min, +\}$ a mno¾inu terminálu $T = \{5, x, y, z\}$. Mno¾iny povolenıch
funkcí a terminálù dohromady tvoøí primitivní mno¾inu systému. Prostor mo¾nıch 
øe¹ení mù¾eme tedy definovat jako mno¾inu v¹ech mo¾nıch stromù, které mohou vzniknout
kombinací funkcí a terminálù :

$$ U = \{t | t=(FT)^{n}, 0 \leq n \leq max\_depth \}$$

Programová reprezentace stromù se li¹í v závislosti na pou¾itém programovacího jazyku.
Platí v¹ak, ¾e 
v prosøedích nároènıch na vıpoèetní vıkon je pamì»ová nároènost grafové reprezentace
neefektnivní. Stromové reprezentace lze u¾ít i nepøímo za pou¾ití prefixové notace.
Pøí pou¾ití prefixové notace se závorky stanou nadbyteènımi a program lze v pamìti
ulo¾it jako \textit{lineární sekvenci symbolù}. Jako pøíklad poslou¾í diagram 
\ref{fig:exampletree1}, tedy \texttt{max min x y + 5 z}. Volba reprezentace tedy
v koneèném dùsledkù zále¾í na u¾ivateli a jeho preferencích, po¾adavcích a prostøedí. 

%%%%%%%%%%%%% TREE REPRESENTATION EXAMPLE 1 %%%%%%%%%%%%%%%
\begin{figure}[!ht]
	\centering
	\includegraphics[scale=0.6]{fig/example_tree1}	
	\caption{Ukázka reprezentace programu max(min(x,y), 5 + z)}
	\label{fig:exampletree1}
\end{figure}
%%%%%%%%%%%%% TREE REPRESENTATION EXAMPLE 1 %%%%%%%%%%%%%%%

\subsection{Inicializace nulté populace}

Pro inicializaci nulté populace platí obecná pravidla. Mù¾eme ji buï volit náhodnì
nebo pou¾ít nìjakou vhodnou heuristiku. Je zde v¹ak specifická vlastnost, kterou 
musíme vzít do úvahy. Na¹e programy nemají pevnì omezenou velikost (délka
chromozomu je promìnná). Jak velké náhodné programy tedy generovat? Existují tøi
základní pøístupy:

\begin{enumerate}
	\item \textit{Full} metoda, kdy náhodnì vygenerujeme strom do maximální povolené
		hloubky,
	\item \textit{Grow} metoda, generujeme stromy promìnlivé délky a tvaru (maximální
		hloubka je omezena) a
	\item \textit{Ramped half-and-half}, kdy polovina populace je generována metodou
		\textit{Grow} a druhá metodou \textit{Full}, za promìnlivé maximální hloubky.
\end{enumerate}

Metoda Full v¾dy a za v¹ech okolností generuje plné stromy. V uzlech jsou funkce
vybírány náhodnì z mno¾íny $F$ a jakmile algoritmus dosáhne maximální hloubky,
nageneruje terminály z mno¾iny $T$ a skonèí.

Grow metoda naproti tomu generuje v uzlech s urèitou pravdìpodobností i terminály, èím¾
je schopna vytváøet stromy rùznıch délek i tvarù. Je v¹ak velmi závisla na velikostech
mno¾in $F$ a $T$. Pokud $|T| << |F|$ algoritmus degraduje na metodu Full. Pokud
na druhé stranì $|T| >> |F|$, algoritmus bude generovat jen velmi malé stromy.

Aby se omezil dopad rozdílnıch velikostí mno¾in $T$ a $F$, John Koza navrhl alternativu
v podobì algoritmu ramped half-and-half. Ten pou¾ívá obì metody souèasnì na polovinu 
jedincù populace a maximální hloubku stromu volí náhodnì, èím¾ zaji¹»uje promìnlivou
velikost i tvar stromù.

\subsection{Genetické operátory a selekce}

V pøípadì selekce do mno¾iny rodièù, se vyu¾ívají v¹echny bì¾né selekèní mechanismy
známé z evoluèních algoritmù, av¹ak nejèastìji se vyu¾ívá turnajová selekce následovaná
proporcionální selekcí.

Zajímavìj¹í je to v pøípadì genetickıch operátorù køí¾ení a mutace. Nejèastìj¹í formou
køí¾ení je \textit{podstromové køí¾ení}. U rodièù vybranıch k reprodukci se se náhodnì 
vybere bod køí¾ení, kterı v genetickém programování zastupují vìtve stromu. Potomek
vznikne umístìním podstromu prvního rodièe na prázdnou vìtev druhého rodièe (rodièe
implicitnì zachováváme). Celı proces blí¾e ilustruje diagram \ref{fig:tree_crossover}

%%%%%%%%%%%%% TREE CROSSOVER EXAMPLE 1 %%%%%%%%%%%%%%%
\begin{figure}[!ht]
	\centering
	\includegraphics[scale=0.6]{fig/tree_crossover}	
	\caption{Ukázka operátoru podstromového køí¾ení}
	\label{fig:tree_crossover}
\end{figure}
%%%%%%%%%%%%% TREE CROSSOVER EXAMPLE 1 %%%%%%%%%%%%%%%

Je vidìt, ¾e køí¾ení vytvoøí pouze jednoho potomka. Pro více potomkù celı proces 
opakujeme. Dale existuje specializace podstromového køí¾ení, obdoba jednobodového
kø¾ení, kdy se urèí v obou rodièích stejnı bod køí¾ení a pøehození korespondujících
podstromù. Je v¹ak potøeba oba strommy projít a najít spoleènı region, tedy èást stromu,
kde je mo¾né køí¾it. Existují dal¹í varianty jako je køí¾ení se zachováním kontextu, 
velikost zachovávající køí¾ení a uniformní køí¾ení. Tìmito se zde zatím blí¾e zabıvat
nebudeme.

Nejbì¾nìj¹í druh mutace je podstromová mutace. Algoritmus podstromové mutace ve stromu
náhodnì zvolí vìtev z ní¾ náhodnì vygeneruje novı podstrom, jak ilustruje diagram
\ref{fig:subtree_mutation}. V pøípadì tohoto algoritmu jde v podstatì o alternativu k
podstromovému køí¾ení s jedním rodièem a jedním náhodnì generovanım stromem.

Dal¹í variantou mutace v genickém programování je uzlová nutace, kdy na ka¾dı
uzel stromu je s urèitou nizkou pravdìpodobností mutace aplikována. Staré uzly
se nahrazují novımi se stejnou aritou.

%%%%%%%%%%%%% SUBTREE MUTATION EXAMPLE 1 %%%%%%%%%%%%%%%
\begin{figure}[!ht]
	\centering
	\includegraphics[scale=0.6]{fig/subtree_mutation}	
	\caption{Ukázka operátoru podstromové mutace}
	\label{fig:subtree_mutation}
\end{figure}
%%%%%%%%%%%%% SUBTREE MUTATION EXAMPLE 1 %%%%%%%%%%%%%%%

\subsection{Fitness funkce}
Populace v genetickém programování jsou programy. Evaluace kvality programu se provádí
zpravidla spu¹tìním daného programu nad danım vstupem a ohodnocením vıstupu. Spu¹tìní 
programu nad zadanım vstupem mù¾eme chápat jako zobrazení z mno¾íny genotypù do mno¾iny
fenotypù za vstupu dal¹ího parametru. Celı proces evaluace mù¾e bıt tedy chápán jako :
$$ f_{eval} = f \circ f_{run}(input)$$
kde $f$ je standarní fitness funkce a $f_{run} : I \to (U \to \mathcal{F})$ je
modifikované zobrazení genotyp-fenotyp pro nìjakı vstup $I$.

Fitness funkce v pøípadì genetického programování se li¹í od té tradièní v jednom
dùle¾itém smìru. Proto¾e pracujeme nad programy, musíme poskytnout zpùsob, jak danı
program spustit. Mo¾ností by bylo program zkompilovat. To s sebou nese znaènou re¾ii
a tak toto øe¹ení není v mnoha pøípadech vhodné. Pokud v¹ak bychom danı program chtìli
evaluovat nìkolikrát (mnohokrát), mù¾e se i toto øe¹ení jevit jako vhodné.

Èastìj¹í je ale programy interpretovat, to znamená projít strom od listù ke koøenu a 
spoèítání hodnoty uzlu za vstupu hodnot jeho následníkù. Kostru algoritmu bude jistì
tvoøit prùchod \textit{postorder}. Evaluace jednotlivıch hodnot v¹ak nemusí bıt za v¹ech 
okolností triviální, mù¾e napøíklad nastat pøípad, kdy bude program dìlit nulou nebo
se sna¾it seèíst hodnoty rùznıch typù (napø. \texttt{Bool} a \texttt{Int}). Pøi reprodukci
jedincù zde nará¾íme na podobné problémy jako napøíklad v teorii typù. Typovost se v
pøípadì genetického programování øe¹í dvìma základnímy zpùsoby:

\begin{enumerate}
	\item \textit{typová unifikace}, kdy ve¹keré uzly i listy stromu budou tého¾ typu,
	\item \textit{silná typovost}, kdy souèástí ka¾dého uzlu i listu stromu bude uveden
	explicitnì jeho typ.
\end{enumerate}

Typová bezpeènost je nutná zejména kvùli operátoru køí¾ení a mutace. V prvním pøípadì
musíme tedy poèítat s tím, ¾e jakıkoli podstrom mù¾e bıt zavì¹en jako argument
libovolné funkci z mno¾ny $F$ a vıslednı program pøesto musí bıt interpretovatelnı.
Jinımi slovy navratovı typ libovolné funkce z mno¾iny $F$ musí bıt stejnı jako
typ libovolného vstupního argumentu jakékoli dostupné funkce. Toho mù¾eme dosáhnout
napøíklad jednodu¹e tím, ¾e v¹echny funkce z mno¾iny $F$ budou definovány nad jedním
oborem hodnot toto¾ného typu. Èasto to v¹ak není mo¾né, proto se musíme nìkdy uchílit
napøíklad k implicitním typovım konverzím.

Druhou mo¾ností je pou¾ití silnì typovanıch stromù. Tento zpùsob je obecnìj¹í, nebo»
nám umo¾òuje pou¾ít naprosto libovolnou mno¾inu funkcí $F$. Je v¹ak také vıraznì
implementaènì slo¾itìj¹í. Ve¹keré reprodukèní operace zde musí provádìt explicitní
typovou kontrolu a èastokrát dlouho procházet strom, ne¾ naleznou uzel vhodnı ke 
køí¾ení èi mutaci. To má dopad samozøejmì hlavnì na èasovou slo¾itost, která je 
vy¹¹í ne¾ v pøípadì typové unifikace.

Spoleènou vlastností, kterou je nutné splnit jak v pøípadì silné typovosti, tak v pøípadì
typové unifiace je, abychom se vypoøádali s mo¾nımi
nedefinovanımi hodnotami, které jsou typické pro vstupy nìkterıch parciálních funkcí
jako je dìlení, kde hodnota je nedefinovaná pokud je dìlitel roven nule.
S parciálními funkcemi se mù¾eme vypoøádat tím, ¾e je explicitnì roz¹íøíme na funkce
totální nebo v pøípadì, je-li nedefinovaná hodnota detekována, znaènì sní¾íme jedincùv 
fitness.

\chapter{Návrh øe¹ení}
\label{sec:solution_design}

Jak ji¾ bylo øeèeno v kapitole \ref{sec:hashing}, navrhujeme-li ha¹ovací funkci "na
míru" nìjakému konkrétnímu univerzu klíèù, mù¾eme dosáhnout podstatnì lep¹í 
vıkonnosti ha¹ovací funkce, ne¾ je tomu v pøípadì obecnıch ha¹ovacích funkcí.

\section{Problém}
Na¹im problémem bude navrhnout konkrétní ha¹ovací funkci pro ha¹ování domény
\texttt{IP} adres. Adresa \texttt{IP} je èíslo, jednoznaènì identifikující sí»ové
rozhraní v síti, která pou¾ívá internetovı protokol \texttt{IP}. Vzhledem k tomu,
¾e budeme ha¹ovat èísla, nabízí se otázka, zda by nebylo vhodné pou¾ít tabulku
s pøímım pøístupem, tedy pou¾ít \texttt{IP} adresy pro pøístup do tabulky
pøímo bez vyu¾ití ha¹ování. Bohu¾el neznáme konkrétní interval nebo podmno¾inu
univerza \texttt{IP} adres a celé univerzum je pøíli¹ velké na to, aby jeho 
prvky mohly slou¾it jako èísla slotù do tabulky. Ve verzi 4 se jedná o 32 
bitové èíslo a verzi 6 dokonce o velikosti 128 bitù. Tabulka by tedy musela
mít $2^{32} = 4 294 967 296$ slotù v pøípadì  \texttt{IP} verze 4 a ve verzi 6
dokonce $2^{128} \approx 3×10^{38}$
slotù. Je vidìt, ¾e tabulky by byly opravdu velké a jejich pamì»ová nároènost
by byla nedostupná i pro specializované poèítaèe, uva¾ujeme-li, ¾e by takovı
stroj mìl dìlat i nìco jiného, ne¾ uchovávat tak ohromnou tabulku. Musíme se
tedy uchílit k návrhu ha¹ovací funkce.

Pracujeme nad ctyømi datasety, kde ka¾dı dataset obsahuje právì 8192 rùznıch 
IP adres. Pro ka¾dı dataset bude nutno navrhnout zvlá¹tní ha¹ovací funkci a tu
na dané vstupy natrénovat. Nenavrhujeme obecnìj¹í ha¹ovací funkci, která by dobøe
pracovala nad libovolnou podmno¾inou celého univerza IP adres, ale velmi
specifické funkce, které budou dobøe pracovat právì nad zvolenım datasetem.
Proto¾e celı ha¹ovanı prostor je pøedem znám, sna¾íme se najít takové ha¹ovací
funkce, které pojmou co nejvíce z dané podmno¾iny. State of the art øe¹ení je v
tomto pøípadì taková ha¹ovací funkce, která pojme celı podprostor, její 
faktor zatí¾ení bude roven právì jedné ($\alpha = 1$). Taková øe¹ení v¹ak
bude tì¾ké najít. Pro na¹e úèely postaèí, nalezneme-li takové, které budou
pracovat lépe, ne¾ obecné ha¹ovací funkce, vytvoøené èlovìkem. Je zde samozøejmì
mo¾nost pou¾ít metody perfektního ha¹ovaní \cite{perfect_hashing}, ale to nemusí
bıt ve v¹ech pøípadech napøíklad z dùvodù pou¾ití na specializovaném hardware
dostupná mo¾nost. Zabıvat se jí tedy nebudeme.


\section{Princip}
Ha¹ovací funkce budeme navrhovat evoluènímy algoritmy, konkrétnì za pou¾ití 
genetického programování. Zvoleno bylo genetické programování, proto¾e 
jako jedince populace abstraktní syntaktické stromy. Jenotlivé syntaktické 
stromy budeme interpretovat nad zadanımi vstupy. Ohodnocení konkrétního jedince
bude spoèívat v naha¹ování jednoho celé subsetu. Na vıstupu budeme mìøit, kolik 
rùznıch klíèù dokázala ha¹ovach tabulku obsáhnout klíèù.

\section{Pøinos práce}
Evoluèní návrh ha¹ovacích funkcí byl se ukázalo jako zajímavé téma v posledním 
desetiletí \cite{dobai0,NCHF_auto_design,grammar_evolution,safdari}.
Naprostá vìt¹ina prací se se zamìrovala na návrh obecnıch ha¹ovacích
funkcí. Byly pou¾ity jak evoulèní návrh tak evoluèní optimalizace. Jedna z prací
podobná té na¹í je \cite{safdari}. Je podobná ve smyslu cíle a pou¾ité techniky,
av¹ak autor zde pou¾il evoluèní optimalizaci namísto návrhu. Autor zde optimalizuje
parametry $a,b$ následující ha¹ovací funkce:
$$h_{a,b}(k) = ((ak + b) \; mod \; p) \; mod \; N$$
kde $p$ je nìjaké prvoèíslo a $N - 1$ je nejvìt¹í index slotu ha¹ovací tabulky.
``Vısledky jsou slibné, ale pou¾itá metodika je sporná'' \cite{NCHF_auto_design}.
Proto¾e mno¾ina klíèù je obsahuje celá èisla a je volena náhodnì, náskıta se otázka,
proè vùbec evolvovat ha¹ovací funkci, kdy¾ mohou bıt pou¾ity její prvky k indexování
napøímo. Druhá vìc je, ¾e autor pou¾íva jako primární metriku fitness funkce odolnost
vùèi kolizím, která je silnì závislá na vstupní mno¾inì. Funkce tedy nemusí dobøe 
zobecòovat.

Vhodnìj¹í metrikou pro návrh obecnıch ha¹ovacích funkcí je lavinovı efekt, kterı 
není závislı na vstupu. Tohoto faktu vyu¾ili autoøi dal¹í podobné práce \cite{NCHF_auto_design}
zabıvající se návrhem ha¹ovacích funckí. Tato práce je pravdìpodobnì nejblí¾e té 
na¹í s rozdílem, ¾e my nenavrhujeme obecné ha¹ovací funkce. Autoøi stejnì jako my,
zvolili genetické programování jako evoluèní platformu a volili i podobné parametry.
Jako základ pro svoji fitnes funkci zvolili lavinovı efekt, kterı není
závislı na vstupu. Funkce navr¾ené jejích systémem otestovali na rùznıch vstupních tøídách
a dosáhli slibnıch vısledkù. Tvrdí, ¾e jeji algoritmus je velice robustní, proto¾e zmìny
klíèovıch parametrù mají jen velmi nízkı nebo ¾ádnı dopad na vısledné funkce. Bohu¾el
souèástí jejich experimentu není porovnání s algoritmem náhodného prohledávání, ke 
kterému mohl jejich systém nedopatøením degradovat a kterı je z povahy vìci také 
velmi robustní. Autoøi také tvrdí, ¾e evoluènì navrhují ha¹ovací funkce, co¾ 
vzhledem k tomu, ¾e navrhují kompresní funkce Merkle-Damg\r{a}rdova schémata
není ùplnì pravda. Takovı pøístup se nachází na pomezí evoluèního návrhu a optimalizace.

Zajímavou prací, která se vydala pøístupem kartézského genetického programování je
\cite{dobai0}. Kartézské genetické programování je zejména vhodné pro aplikace blízké
hardwarové vrstvì, tak¾e jeho volba se zdá velmi dobrá vzhledem k cílové aplikaèní doménì
, kterou jsou sí»ové prvky. Nespornı pøínos práce spoèívá v pou¾ití Kukaèèího ha¹ování, které
je pou¾ito za úèelem zvı¹ení faktoru zatí¾ení vısledné ha¹ovací tabulky a práce tak dosáhla velmi
dobrıch vısledkù. Faktor, kterı tato a na¹e práce sdílí je návrh doménovì specifické ha¹ovací 
funkce, kde ha¹ovanou doménou jsou také IP adresy. Práce se v¹ak rozchází zejména ve volbì 
fitnes funkce. Zatímco my (jak uvidíme pozdìji v této kapitole) jsme zvolili pøístup, kdy ha¹ujeme
celı danı rozsah a mìøíme vıskyt kolizi, mìøí poèet úspì¹nì naha¹ovanıch adres a¾ do vıskytu
první kolize. Taková metrika je vskutku zajímavá, ale intuitivnì se naskıta úvaha, ¾e fitnes funkce
velmi ¹patnì ohodnotí øe¹ení, která mají kolizi velmi brzo, ale pøitom mohou naha¹ovat velkou èást
celého rozsahu. Fitnes funkce jasnì míøí na cíl naha¹ovat celı rozsah (tedy optimální øe¹ení), toho
nicménì nedosáhla. Bude zajímavé porovnat vısledky na¹í prace s s vısledky dosa¾enımi v této
práci. Autoøi opìt pou¾ívají Merkle-Damg\r{a}rdovo schéma a práce se tudí¾ také nachází na 
pomezí evoluèního návrhu a evoluèní optimalizace.

\section{Návrh fitness funkce}

V na¹í práce navrhujeme specifickou
ha¹ovací funkci pro specifické univerzum hodnot. Proto mù¾eme pou¾ít jako kritérium
kvality odolnost vùèi kolizím, které je nepøímım ukazatelem toho, jak dobøe funkce
náhodnì distribuuje své vıstupy. Evaluovanou ha¹ovací
funkci budeme testoat nad v¹emi prvky univerza. To znamená, ¾e budeme navrhovat
celkem ctyøi ha¹ovací funkce, pro ka¾dı vsupní dataset jednu. Kdybychom pro v¹echny ètyøi
datasety navrhovali jednu jedinou, nedostali bychom dobré vısledky. Vıslednı ha¹ovací tabulka
by mìla 8192 slotù, ale byla by ``natrénována'' nad v¹emi adresami ze v¹ech datasetù. Navic 
bychom se museli zabıvat vhodnou volbou trénovacích dat, co¾ je obtí¾nı úkol a navíc pøídat
kritérim, které by bralo v úvahu zobecòování. Vıslednı ha¹ovací funkce by ji¾ nebyla obecná, ale
nìkde ``na pùl cesty'' mezi obecnou a velmi specifickou ha¹ovací funkci.

Neménì dùle¾itım kritériem je rychlost ha¹ovací funkce a to obzvlá¹tì v aplikacích jako jsou
sí»ové smìrovaèe nebo jiná uplatòìní nároèná na rychlost a odezvu. Jak uvidíme pozdìji v této
kapitole, ve¹keré námi navr¾ené funkce jsou implicitnì rychlé, proto¾e explicitnì omezíme hloubku
abstraktních syntaktickıch stromù a vhodnì zvolíme mno¾inu terminálù a neterminálù. 

\section{Zvolené parametry genetického programování}

V této sekci uvedeme, jaké parametry jsme zvolili parametry pro geneticé programování.

\subsection{Genetické operátory a selekce}

Operátory mutace pou¾ijeme ve dvou verzích. \textit{Podstromovou} mutaci a 
\textit{bodovou} mutaci zároveò. Budeme náhodnì volit mezi obìma alternativami, 
av¹ak pravdìpodobnost mutace ponecháme velmi nízkou. Pùvodní implementace algoritmù
genetického programování \cite{GPTutorial} operátor mutace vynechávaly úplnì. 
Budeme radìji volit cestu postupné pomaleji konvergující evoluce, ne¾ abychom 
nìjaká øe¹ení minuli.

Co se køí¾ení tıka, v prvních verzích pou¾ijeme základní formu tedy \textit{podstromové}
køí¾ení, pozdìji jej mù¾eme porovnat i s pokroèilej¹ími technikami jako jsou 
\textit{jednobodové} a køí¾ení se zachováním kontextu. 

Selekci pou¾ijeme turnajovou a to zejména kvùli své determinitiènosti (jedince
sice musíme volit náhodnì, ale nemusíme se mezi nimi stochastiky rozhodovat). Dal¹ím dùvodem
je dobrá ¹kálovatelnost selekèního tlaku.

Poèáteèní populaci budeme generovat náhodnì bez pou¾ití jakıchkoli heuristik
a to metodou \textit{ramped-half-and-half}, která zaji¹»uje pro start algoritmu
kvalitní populaci co se rùznorodosti verlikostí a tvarù jedincù tıká. 

\subsection{Mno¾ina terminálù a funkèních symbolù}

Mno¾inu vstupù zkonstruujeme z konstant a vstupních promìnnıch. Vstupní
promìnné vyrobíme z jednotlivıch oktetù adres a budeme po¾adovat, aby ka¾dı
vstupní program obsahoval v¹echny promìnné alespoò jednou, tedy aby pracoval
s celou adresou. Jako konstanty budeme volit prvoèísla. 

Prvoèísla hrají dùle¾itou roli pøi operaci modulo. Pokud volíme jako argument modula nìjaké
násobky malıch èísel jako je napøíklad èislo dvì, mù¾e se stát, ¾e funkce bude
mít tendenci seskupovat èísla dìlitelná dvìmi. Jako konstanty budeme volit
prvoèísla z rozsahu $\langle 2, 2N \rangle$, kde $N$ je velikost datasetu. Prvoèísla
budeme implementovat ve formì \textit{pomíjivé náhodné konstanty} (angl. \textit{ephemeral
random constant}, zkr. \textit{ERC}), kterou budeme znaèit $\Re$. Tento pøístup nám
zajistí vhodné chování konstany s ohledem na operátory køí¾ení a mutace a také pøi
evaluaci. Taková konstanta pokud je vygenerována bude pøi ka¾dém ohodnocení 
nabıvat stejné hodnoty, ale v mutaci jej bude mìnit s urèitou pravdìpodobností na
nìjaké nejbli¾¹í prvoèíslo. 

Ka¾dá IP adresa má délku 32 bitù a skládá se ze ètyø osmibitovıch oktetù. Oktety zahrneme
do na¹í mno¾iny terminálních symbolù ka¾dı zvlá¹» a oznaèíme je $o_0 \ldots o_4$ jemnìj¹í 
dìlení (napøíklad 4, 2 nebo 1 bit) nebudeme uva¾ovat, proto¾e pou¾ijeme rotace (viz. dále),
které budou schopny vybrat jednotlivé bity z oktetu.

Budeme-li uva¾ovat Merkle-Damg\r{a}rdovo schéma, musíme reprezentovat v na¹í
mno¾inì terminálù mezivısledky kompresní funkce. I kdy¾ se jedná obecnì o iterativní
schéma pracující nad libovolnou délkou vstupu, my si vzhledem k pøedem pevnì 
dané délce 32 bitù vystaèíme se ctyømi kompresními jednotkami, jejich¾ mezivısledky
budeme znaèit $a_0, a_1, a_2$ (pozn.v pøípadì $a_3 $ se jedná o vıstup). 

Mno¾inu funkcí zvolíme z bì¾nıch operací. Vyhneme se cyklùm a jinım slo¾itım
øídícím konstrukcím, nebo» ty by vzhledem ke stochastické povaze algoritmu mohly
vyústit ve velmi pomalé ha¹ovací funkce. Dal¹í nevítanou skupinou operací jsou operace
v plovoucí øádové èárce, které na procesorech s komplexní instrukèní sadou vy¾adují
mnoho taktù procesoru aøí implementaci v hardware zase zabírají velké místo na èipu.
Nosnou èást mno¾iny funkcí budou tvoøit aritmetické operace. Konkrétnì do ní zahrneme
násobení ($*$), sèítání ($+$), odèítání ($-$) a operaci modulo ($mod$). V pøípadì dìlení
se spokojíme s dìlením beze zbytku ($/$). Pou¾ívat budeme také booleovské operace,
kam zahrneme logické souèet ($OR$), logickı souèin ($AND$) a negaci ($NOT$), která 
je dùle¾itá zejmána proto, proto¾e umo¾òuje vytvoøit úplnou bázi a logické funkce mohou
tedy zkonstruovat libovolnou logickou funkci. Poslední skupinu budou tvoøit funkce bitové.
Zde zahrneme pravou ($\ggg$) a levou ($\lll$) rotaci. Které jsou dùle¾ité pro vıbìr 
jednotlivıch bitù ze vstupních argumentù. Vıèet pou¾itıch funkcí a terminálù
popisují tabulky \ref{tab:function_set_design} a \ref{tab:terminal_set_design}.

%%%%%%%%%%%%% FUNCTION AND TERMINAL SETS %%%%%%%%%%%%%%%
\begin{table}
\begin{center}
\begin{tabular}{ |l|c| }
	\hline
   	Kategorie & Zástupci \\
  	\hline
  	Aritmetické celoèíselné  & $\{ +,-,*,/,mo	d \}$ \\
  	Aritmetické                     & $\{\}$ \\
  	Booleovské				      & $\{AND, OR, NOT\}$ \\
  	Bitové					          & $\{ \lll, \ggg \}$ \\ 	 
  	\hline
\end{tabular}
\caption{Zvolená mno¾ina funkcí}
\label{tab:function_set_design}
\end{center}
\end{table}

\begin{table}
\begin{center}
\begin{tabular}{ |l|c| }
	\hline
   	Kategorie & Zástupci \\
  	\hline
  	Promìnné       & $\{o_0, o_1, o_2, o_3, a_0, a_1, a_2\}$ \\
  	Funkce arity 0 & $\{ \Re \}$ \\	 
  	\hline
\end{tabular}
\caption{Zvolená mno¾ina terminálù}
\label{tab:terminal_set_design}
\end{center}
\end{table}
%%%%%%%%%%%%% FUNCTION AND TERMINAL SETS %%%%%%%%%%%%%%%

\section{Evoluèní návrh ha¹ovacích funkcí}
V této sekci pøedstavíme princip metody a konkrétní podobu navr¾eného øe¹ení pro pøímı evoluèní 
návrh ha¹ovacích funkcí. Pøímı proto, proto¾e zde nebudeme uva¾ovat zádné schéma ani koncept
jeho¾ èásti bychom evolvovali. Ha¹ovací funkce zde budou reprezentovat pøímo abstraktní syntaktické
stromy, s kterımi pracuje algoritmus genetického programování. Funkce navr¾ené touto metodou 
budeme oznaèovat \textit{IPHash}. Ka¾dı jedinec bude pracovat se v¹emi oktety IP adresy.
Merkle-Damg\r{a}rdovo schéma zde nepou¾íváme, tak¾e do mno¾iny terminálù není tøeba zahrnovat
¾ádné symboly reprezentující mezivısledky. Dále do mno¾iny zahrneme konstantu  $\Re$. Operátor
køá¾ení zvolíme v podstromové variantì a operátor mutace takté¾. Hloubku jednotlivıch jedincù omezíme
na hodnotu ¹est a to ze dvou dùvodu. Jednak proto¾e oèekáváme od na¹ich ha¹ovacích funkcí aby byly
rychlé a také proto, ¾e algoritmus genetického programování je pamì»ovì nároènı a s rostoucí hloubkou
stromù roste exponenciálnì pamì»ová nároènost, co¾ klade neúnosné nároky na vıpoèetní zaøízení 
(servery \textit{edesign1} \ldots \textit{edesign4}). Parametry základní variantu této metody shrnuje 
tabulka \ref{tab:IPHash_params}.

\begin{table}[h]
	\centering
	\caption{Kompletní shrnutí parametrù genetického programování pro experimenty spjaté s touto sekcí.}
	\begin{tabular}{lc} \\ \hline
		Parametr & Hodnota \\ \hline
		Poèet populací v bìhu & 1 \\
		Velikost populace & 512 \\
		Reprezentace jedince & jeden abstraktní syntaktickı strom \\ \hline
		Maximální poèet ohodnocení & 100000 \\
		Maximální hloubka & 6 \\
		Mno¾ina funkcí & $\{*, +, \wedge, \ggg\}$ \\
		Mno¾ina symbolù & $\{o_{0} .. o_{3}, \Re \}$ \\
		\hline 
		Inicializaèní metoda & Ramped half-and-half \\
		Poèáteèní maximální hloubka & 6 \\
		Poèáteèní maximální hloubka & 2 \\
		\hline
		Selekce & Turnajová \\
		Velikost turnaje & 7 \\
		\hline
		Køí¾ení & Podstromové \\
		Èetnost selekce koøene & 0.0 \\
		Èetnost selekce listu & 0.1 \\ 
		Èetnost selekce uzlù & 0.9 \\
		\hline 
		Mutace & Podstromová \\
		Èetnost & 0.1 \\
		\hline
		Elitismus & Ano \\
		Èetnost & 0.05 \\
		\hline
	\end{tabular}
	\label{tab:IPHash_params}
\end{table}

\section{Optimalizace za pou¾ití Merkle-Damg\r{a}rdova schématu}

Dále se budeme zabıvat evoluèním návrhem kompresních funkcí pro Merkle-Damg\r{a}rdovo schéma.
Budeme zkoumat dva rùzné pøístupy. V prvním pøípadì budeme evolvovat jednu jedinou kompresní 
pøi konstrukci Merkle-Damg\r{a}rdova schématu tak jak bylo popsáno v kapitole \ref{sec:hashing}.
V druhém pøipadì budeme namísto jedné kompresní funkce evolvovat hned ctyøi, pro ka¾dı oktet
ha¹ovací funkce jednu jak je ukázáno na obrázku \ref{fig:merkle_damgard_2}. Tento pøístup nám
umo¾ní dekomponovat prohledávací prostor a dosáhnout tak lep¹ích vısledkù díky navr¾ení
kompresních funkcí na míru konkrétnímu oktetu IP adresy. Merkle-Damg\r{a}rdovo schéma je obecnì
iterativní schéma pøijímat vstup o libovolné velikosti. My vyu¾ijeme v obou pøípadech faktu, ¾e délku
vstupu pøedem známe. Omezíme se tedy pouze na ctyøi kompresní funkce, pro ka¾dı oktet vstupu jednu.
A proto¾e je velikost vstupu násobek osmi, nemusíme poslední oktet doplòovat o ohranièující vatu. Dále
náme nezále¾í na kryptografické bezpeènosti, mù¾eme tedy vzpostit poslední kompresní komponentu
pro délkové ohranièení. Ani dobrovolnou finalizaèní komponentu nevyu¾ijeme. Vısledná ha¹ovací funkce
bude tvaru
$$f_{Merkle-Damgard} : IV \times X \to \{0,1,2 \ldots 8192\}$$,
kde $IV$ je nìjaké celé èíslo a $X$ je vstupní IP adresa.

Druhı bude vy¾adovat zásadní zmìnu v reprezentaci jedincù. Ka¾dı jedinec se bude skládat ze ctyø 
rùznıch abstraktních syntaktickách stromù reprezentující jednotlivé kompresní funkce. Genetické operátory
mutace a zejména køí¾ení pracují v ka¾dém procesu reprodukce pouze nad jedním abstraktním
syntaktickım stromem. Proto¾e naráz pracujeme se ètyømi stromy zvedme poèet evaluací ctyønásobnì na
400 000 evaluací, abychom dosáhli ekvivalentní situace v porovnání s ostatními metodami. V procesu
reprodukce jsou abstraktní syntaktické stromy vybírány náhodnì. 

\begin{figure}[!ht]
\begin{subfigure}[b]{0.49\textwidth}
%	\includegraphics[width=\textwidth]{fig/merkle_damgard_design1}
	\caption{První pøípad, kterı budeme studovat. Schéma pou¾ívá zøetìzení jediné kompresní funkce.}
\end{subfigure}
\begin{subfigure}[b]{0.49\textwidth}
%	\includegraphics[width=\textwidth]{fig/merkle_damgard_design2}
	\caption{Druhı pøípad, kterı budeme studovat. Schéma pou¾ívá zøetìzení nìkolika rùznıch kompresních funkcí.}
\end{subfigure}
	\caption{Porovnání dvou navr¾enıch øe¹ení pou¾ívající Merkle-Damg\r{a}rdovo schéma.}
\end{figure}

U obou variant do tabulky terminálních symbolù musíme zavést pøíslu¹né symboly reprezentující
konkrétní mezivısledky $a_0, a_1, a_2$. Ostatní parametry se oproti metodì v pøedchozí sekci neli¹í.

\section{Evoluèní návrh za pou¾ití kukaèèího ha¹ování}

\chapter{Experimenty}

%%%%%%%%%%%%% EXPERIMENTS WITH VARIOUS FUNCTIONS %%%%%%%%%%%%%%%
V této kapitole provedeme experimenty v nich¾ nejprve ovìøíme, zda navr¾ené øe¹ení poskytuje dobré
vısledky. Poté provedeme dal¹í sérii experimentù, v ních¾ budeme postupnì mìnit parametry navr¾eného
øe¹ení a vyhodnotíme vısledky. Mìnit budeme jak samotné parametry algoritmu genetického
programování, tak i mno¾iny terminálních a neterminálních symbolù. Budeme provádìt v¾dy pouze
jednu zmìnu v ka¾dém experimentu, abychom zachovali jejich vìrohodnost a správnou korespondenci
mezi zmìnou parametru a dùsledkem, jakı má na vısledné øe¹ení.

V následující sekci budeme experimentovat s evolvovanımi ha¹ovacími funkcemi, do kterıch zahrneme
Merkle-Damg\r{a}rdovo schéma popsané v kapitole \ref{sec:hashing}. Krátce popí¹eme zmìny v na¹em
evoluèním algoritmu a provedeme pøíslu¹né experimenty.

V poslední sekci této kapitoly uvedeme do námi navr¾eného øe¹ení Kukaèèí schéma jak bylo popsané
v kapitole \ref{sec:hashing}. Opìt shrneme zmìny v genetickém algoritmu, provedeme a vyhodnotíme
pøíslu¹né experimenty.

Ve v¹ech experimentech budeme mìrit míru odolnosti proti kolizím, konkrétnì tedy kolik je daná ha¹ovací 
funkce schopna naha¹ovat rùznıch IP adres. Dal¹í, neménì dùle¾itou roli hraje u ha¹ovacích funkcí jejich
rychlost. Provedeme tedy i experimenty, které odhalí rychlost s jakou jednotlivé ha¹ovací funkce provádí svou
èinnost. 

\section{Experimenty s navr¾enım øe¹ením}
Nejprve se tedy budeme zkoumat vısledky, jaké poskytuje námi navr¾ené øe¹ení z kapitoly
 \ref{sec:solution_design}. Námi navr¾enı algoritmus porovnáme se dvìma variantami náhodného prohledávání.
 První varianta bude náhodné prohledávání bez pou¾ití elitismu, druhá s elitismem. Do grafu zahrneme i jednu
 variantu èlovekem vytvoøené obecné ha¹ovací funkce, konkrétnì ha¹ovací funkci \textit{Murmurhash3} pøedstavenou
 v sekci \ref{sec:evolution_design}. Bìhy námí navr¾eného øe¹ení jsme promítli do grafù, kde ka¾dému
 datasetu odpovída jeden graf. Na levé stranì grafu mù¾eme vidìt prùbìhy námi navr¾eného systémù a oba
 algoritmy náhodného prohledávání. Ka¾dá køivka je vısledkem mediánu z padesátí nezávislıch bìhù. Na levé
 stranì mù¾eme pozotovat medián systémù IPHash a u nìj je¹tì interval spolehlivosti. Interval spolehlivosti
 je zaznaèen dvìma ohranièujícímy køivkami, kde spodní zaèní první a horní tøetí kvartil.

%%%%%%%%%%%%% IPHASH AVG Population SET #1 %%%%%%%%%%%%%%%
\begin{figure*}[!ht]
	\centering
	\begin{tikzpicture}
	\begin{axis}[ %
	, name=plot1
	, height=8cm
	, width=0.50\textwidth
	, grid=major
	, xlabel=Generation
	, ymin=5180
	, ymax=5320
	, ylabel=Successfully hashed
	, legend style=
	{ at={(1.0, 0.3)}
		, anchor=east
	}
	]
	\addplot[color=black, dashdotted, thick, mark=none] table {graph/IPHash/Set1/ElitistRandomRun_1.dat};
	\addlegendentry{Elitist Random Search}
	
	\addplot[color=blue, dotted, very thick, mark=none] table {graph/IPHash/Set1/RandomRun_1.dat};
	\addlegendentry{Random Search}
	
	\addplot[color=green, solid, thick, mark=none] coordinates {(0,5190) (194, 5190)};
	\addlegendentry{MurmurHash3}
	
	\addplot[color=red, mark=none, dashed, thick] table {graph/IPHash/Set1/IPHashMedian_1.dat}; 
	\addlegendentry{Proposed IPHash}
	
	\end{axis}
	
	\begin{axis}[ %
	, name=plot2
	, at=(plot1.right of south east)
	, anchor=left of south west
	, ymin=5180
	, ymax=5320
	, height=8cm
	, width=0.50\textwidth
	, grid=major
	, xlabel=Generation
	%%	, ylabel=Successfully hashed
	, yticklabels={,,}
	%%	, legend pos=outer north east
	, legend style=
	{ at={(1.0, 0.3)}
		, anchor=east
	}
	]
	\addplot[color=red, mark=none, dashed,thick] table {graph/IPHash/Set1/IPHashMedian_1.dat}; 
	\addlegendentry{Proposed IPHash}
	\addplot[color=red, mark=none, dotted] table {graph/IPHash/Set1/IPHashReliab1_1.dat}; 
	%\addlegendentry{Proposed IPHash RR1}
	\addplot[color=red, mark=none, dotted] table {graph/IPHash/Set1/IPHashReliab3_1.dat}; 
	\addlegendentry{Diversity of runs}
	\end{axis}
	\end{tikzpicture}
	\caption{Evolvované ha¹ovací funkce a jejich fitnes hodnota nad data setem èíslo 1.}
	\label{fig:basicComparison1}
\end{figure*}
%%%%%%%%%%%%% IPHASH AVG Population SET #1 %%%%%%%%%%%%%%%

Na obrázku \ref{fig:basicComparison1} mù¾eme vidìt vidìt porovnání bìhù a jejich vısledkù v¹ech algoritmù.
Je patrné, ¾e nad prvním datasetem, navr¾ené øe¹ení jasnì dominuje nad zbıvajícímy algoritmy. IPHash
naha¹oval o 25 IP adres více ne¾ druhı nejùspì¹nìj¹í algoritmus náhodného prohledávání. Nejhùøe si vedl
èlovìkem vytvoøenı algoritmus \textit{MurmurHash3}, kterı naha¹oval o celıch 111 IP adres ménì. 

Z intervalu spolehlivost mù¾eme usoudit, ¾e námi navr¾enı algoritmus skuteènì funguje dobøe a rozptyly jeho
øe¹ení nejsou pøíli¹ signifikantní. Nalezené øe¹ení není tedy dílem èísté náhody. Z grafu mù¾eme vyèíst, ¾e 
algoritmus v prních nìkolika generacích rapidnì konverguje a s postupnım pøíbıváním generací se jeho 
konvergence zpomaluje. Toto je typickou vlastností algoritmu genetického programování \cite{GPTutorial}.

%%%%%%%%%%%%% IPHASH AVG Population SET #2 %%%%%%%%%%%%%%%
\begin{figure*}[!ht]
	\centering
	\begin{tikzpicture}
	\begin{axis}[ %
	, name=plot1
	, height=8cm
	, width=0.50\textwidth
	, grid=major
	, xlabel=Generation
	, ymin=5180
	, ymax=5330
	, ylabel=Successfully hashed
	, legend style=
	{ at={(1.0, 0.3)}
		, anchor=east
	}
	]
	\addplot[color=black, dashdotted, thick, mark=none] table {graph/IPHash/Set2/ElitistRandomRun_2.dat};
	\addlegendentry{Elitist Random Search}
	
	\addplot[color=blue, dotted, very thick, mark=none] table {graph/IPHash/Set2/RandomRun_2.dat};
	\addlegendentry{Random Search}
	
	\addplot[color=green, solid, thick, mark=none] coordinates {(0,5190) (194, 5190)};
	\addlegendentry{MurmurHash3}
	
	\addplot[color=red, mark=none, dashed, thick] table {graph/IPHash/Set2/IPHashMedian_2.dat}; 
	\addlegendentry{Proposed IPHash}
	
	\end{axis}
	
	\begin{axis}[ %
	, name=plot2
	, at=(plot1.right of south east)
	, anchor=left of south west
	, ymin=5180
	, ymax=5330
	, height=8cm
	, width=0.50\textwidth
	, grid=major
	, xlabel=Generation
	%%	, ylabel=Successfully hashed
	, yticklabels={,,}
	%%	, legend pos=outer north east
	, legend style=
	{ at={(1.0, 0.3)}
		, anchor=east
	}
	]
	\addplot[color=red, mark=none, dashed,thick] table {graph/IPHash/Set2/IPHashMedian_2.dat}; 
	\addlegendentry{Proposed IPHash}
	\addplot[color=red, mark=none, dotted] table {graph/IPHash/Set2/IPHash1stQ_2.dat}; 
	%\addlegendentry{Proposed IPHash RR1}
	\addplot[color=red, mark=none, dotted] table {graph/IPHash/Set2/IPHash3rdQ_2.dat}; 
	\addlegendentry{Diversity of runs}
	\end{axis}
	\end{tikzpicture}
	\caption{Evolvované ha¹ovací funkce a jejich fitnes hodnota nad data setem èíslo 2.}
	\label{fig:basicComparison2}
\end{figure*}
%%%%%%%%%%%%% IPHASH AVG Population SET #2 %%%%%%%%%%%%%%%

V pøípadì druhého datasetu jsou dosa¾ené vısledky (\ref{fig:basicComparison2}) je¹tì lep¹í. IPHash dosáhl vy¹¹ího mediánu
a opìt vıraznì pøevı¹il jak náhodné prohledávání, tak \textit{MurmurHash3}. Naha¹oval o 24
IP adres více ne¾ náhodné prohledávání a o 115 IP adres více, ne¾ \textit{MurmurHash3}. 
Interval spolehlivosti je s vıjimkou posledních nìkolika generací více sevøenı kolem køivky
IPHash, co¾ znaèí spolehlivı algoritmus. Stejnì jako v pøedchozím pøípadì, algoritmus rapidnì
konverguje v prvních nìkolika generacích. Poté jeho nástup ustává.

%%%%%%%%%%%%% IPHASH AVG Population SET #3 %%%%%%%%%%%%%%%
\begin{figure*}[!ht]
	\centering
	\begin{tikzpicture}
	\begin{axis}[ %
	, name=plot1
	, height=8cm
	, width=0.50\textwidth
	, grid=major
	, xlabel=Generation
	, ymin=5180
	, ymax=5320
	, ylabel=Successfully hashed
	, legend style=
	{ at={(1.0, 0.3)}
		, anchor=east
	}
	]
	\addplot[color=black, dashdotted, thick, mark=none] table {graph/IPHash/Set3/ElitistRandomRun_3.dat};
	\addlegendentry{Elitist Random Search}
	
	\addplot[color=blue, dotted, very thick, mark=none] table {graph/IPHash/Set3/RandomRun_3.dat};
	\addlegendentry{Random Search}
	
	\addplot[color=green, solid, thick, mark=none] coordinates {(0,5206) (194, 5206)};
	\addlegendentry{MurmurHash3}
	
	\addplot[color=red, mark=none, dashed, thick] table {graph/IPHash/Set3/IPHashMedian_3.dat}; 
	\addlegendentry{Proposed IPHash}
	
	\end{axis}
	
	\begin{axis}[ %
	, name=plot2
	, at=(plot1.right of south east)
	, anchor=left of south west
	, ymin=5180
	, ymax=5320
	, height=8cm
	, width=0.50\textwidth
	, grid=major
	, xlabel=Generation
	%%	, ylabel=Successfully hashed
	, yticklabels={,,}
	%%	, legend pos=outer north east
	, legend style=
	{ at={(1.0, 0.3)}
		, anchor=east
	}
	]
	\addplot[color=red, mark=none, dashed,thick] table {graph/IPHash/Set3/IPHashMedian_3.dat}; 
	\addlegendentry{Proposed IPHash}
	\addplot[color=red, mark=none, dotted] table {graph/IPHash/Set3/IPHash1stQ_3.dat}; 
	%\addlegendentry{Proposed IPHash RR1}
	\addplot[color=red, mark=none, dotted] table {graph/IPHash/Set3/IPHash3rdQ_3.dat}; 
	\addlegendentry{Diversity of runs}
	\end{axis}
	\end{tikzpicture}
	\caption{Evolvované ha¹ovací funkce a jejich fitnes hodnota nad data setem èíslo 3.}
	\label{fig:basicComparison3}
\end{figure*}
%%%%%%%%%%%%% IPHASH AVG Population SET #3 %%%%%%%%%%%%%%%

Zajímavá situace nastala v pøípadì tøetího datasetu \ref{fig:basicComparison3}. Na první pohled je patrné,
¾e oba iteraèní algoritmy zde øe¹ení s obdobnou hodnotou fitnes. Dále je vidìt,
¾e mediánová hodnota fitnes se nám znatelnì a to o více ne¾ dvacet naha¹ovanıch 
adres v pøípadì algoritmu IPHash. Vısledná øe¹ení náhodného prohledávání na¹la
øe¹ení s obdobnou hodnotou fitnes jako v pøedchozím pøípadì. Naopak se zvı¹ila 
hodnota u algoritmu \textit{MurmurHash3}, a to o celıh 15 naha¹ovanıch adres.

Z intervalu spolehlivosti mù¾eme vyèíst, mnohem vìt¹í rozptyl ne¾ v pøedchozích
pøípadech. IPHash algoritmus produkuje mnohem vìt¹í diverzitu v nalezenıch øe¹eních.
Tento fakt ve spojení s obdobnou hodnotou fitnes funkce jako má náhodné prohledávání
znaèí, ¾e stavovı prostor tak jak modelován tøetím datasetem je vhodnı spí¹e pro 
algoritmus náhodného prohledávání, ne¾ pro evoluèní algoritmus. Evoluèní algoritmus
se v prostoru dostupnıch øe¹ení ``nemá èeho chytit''. Proto ¹patnì konverguje a jeho
prùbìh pøipomíná náhodné prohledávání. Na poèátku algoritmus konverguje velmi rychle
velmi rychle v¹ak ztrácí ve¹kerı progres a témìø úplnì staguje.

%%%%%%%%%%%%% IPHASH AVG Population SET #4 %%%%%%%%%%%%%%%
\begin{figure*}[!ht]
	\centering
	\begin{tikzpicture}
	\begin{axis}[ %
	, name=plot1
	, height=8cm
	, width=0.50\textwidth
	, grid=major
	, xlabel=Generation
	, ymin=5180
	, ymax=5320
	, ylabel=Successfully hashed
	, legend style=
	{ at={(1.0, 0.3)}
		, anchor=east
	}
	]
	\addplot[color=black, dashdotted, thick, mark=none] table {graph/IPHash/Set4/ElitistRandomSearch_4.dat};
	\addlegendentry{Elitist Random Search}
	
	\addplot[color=blue, dotted, very thick, mark=none] table {graph/IPHash/Set4/RandomSearch_4.dat};
	\addlegendentry{Random Search}
	
	\addplot[color=green, solid, thick, mark=none] coordinates {(0,5206) (194, 5206)};
	\addlegendentry{MurmurHash3}
	
	\addplot[color=red, mark=none, dashed, thick] table {graph/IPHash/Set4/IPHashMedian_4.dat}; 
	\addlegendentry{Proposed IPHash}
	
	\end{axis}
	
	\begin{axis}[ %
	, name=plot2
	, at=(plot1.right of south east)
	, anchor=left of south west
	, ymin=5180
	, ymax=5320
	, height=8cm
	, width=0.50\textwidth
	, grid=major
	, xlabel=Generation
	%%	, ylabel=Successfully hashed
	, yticklabels={,,}
	%%	, legend pos=outer north east
	, legend style=
	{ at={(1.0, 0.3)}
		, anchor=east
	}
	]
	\addplot[color=red, mark=none, dashed,thick] table {graph/IPHash/Set4/IPHashMedian_4.dat}; 
	\addlegendentry{Proposed IPHash}
	\addplot[color=red, mark=none, dotted] table {graph/IPHash/Set4/IPHash1stQ_4.dat}; 
	%\addlegendentry{Proposed IPHash RR1}
	\addplot[color=red, mark=none, dotted] table {graph/IPHash/Set4/IPHash3rdQ_4.dat}; 
	\addlegendentry{Diversity of runs}
	\end{axis}
	\end{tikzpicture}
	\caption{Evolvované ha¹ovací funkce a jejich fitnes hodnota nad data setem èíslo 4.}
	\label{fig:basicComparison4}
\end{figure*}
%%%%%%%%%%%%% IPHASH AVG Population SET #4 %%%%%%%%%%%%%%%

Zdá se, ¾e stejnì jako v pøedchozím pøípadì, se IPHash chová i nad posledním datasetem ètyøi (\ref{fig:basicComparison4}).
Mediánová hodnota je opìt ni¾¹í ne¾ v pøípadì náhodného prohledávání. Je v¹ak vy¹¹í, ne¾ v pøípadì
\textit{MurmurHash3}. Stavovı prostor, zda se, má opìt náhodnou charakteristiku a algoritmus spatnì
koverguje. Rozptyl je opìt vìt¹í ne¾ v prvních dvou pøípadech. Algoritmus rychle konverguje v prvních
nìkolika generacích. Brzy v¹ak pøejde ve stagnaci.

Døíve, ne¾ se pustíme dále je vhodné se zamyslet na doposud dosa¾enımi vısledky algoritmem náhodného
prohledávání. Teoreticky algoritmus náhodného prohledávání je takovı, kterı náhodnì vybírá body
daného stavového prostoru. Souèástí ka¾dého evoluèního algoritmu je v¹ak také reprezentace problému,
která modeluje stavovı prostor. V na¹em pøípadì bylo náhodné proheldávání velmi silnì ovlivnìno 
reprezentací jedncù jako abstraktních syntaktickıch stromù a pou¾itımi terminálními a funkèními symboly.
Lze tedy stále mluvit o algoritmu náhodného prohledávání, mìjme v¹ak na pamìti, ¾e vısledky jím
dosa¾enou jsou velkou mìrou zpùsobené právì námi vhodnì zvolenou reprezentací.

Jedna ze zajímavıch vlastostí spoleènou pro v¹echny grafy je fakt, ¾e v iniciálních populacích obou
iteraèních algoritmù jsme nalezli øe¹ení, která pøevy¹ovala èlovìkem vytvoøené ha¹ovací funkce. Toto
je velmi zajímavı poznatek. Dùvodem je, ¾e velikost populace jsme zvolili pomìrnì velkou. I pøes to
v¹ak z toho plyne, ¾e po nìkolika málo pokusech s náhodnım generováním abstraktních syntaktickıch 
stromù mù¾eme nalézt øe¹ení, která pøevy¹ují ta èlovìkem vytvoøená.

\begin{table}[!ht]
	\centering
	\begin{tabular}{l|c|c|c|c}
		Ha¹ovací funkce & Dataset 1 & Dataset 2 & Dataset 3 & Dataset 4 \\
		\hline
		FarmHash             & 5227 & 5199 & 5203 & 5158 \\
		MurmurHash3    		 & 5190 & 5190 & 5206 & 5206 \\
		CityHash             & 5180 & 5156 & 5171 & 5155 \\
		\hline
		IPHash               & 5301 & 5305 & 5274 & 5278 \\
		Náhodné prohledávání & 5276 & 5281 & 5277 & 5281 \\
		\hline
	\end{tabular}
	\caption{Shrnutí vısledkù evolvovanıch i obecnıch ha¹ovacích funkcí napøíè v¹emi datasety.}
	\label{tab:IPHash_conclusion}
\end{table}

Ve shrnující tabulkce \ref{tab:IPHash_conclusion} mùzeme vidìt vısledky algoritmu náhodného prohledávání
a algoritmu IPHash v kontrastu s èlovìkem vytvoøenımi ha¹ovacími funkcemi z kapitoly \ref{sec:hashing}.
Nad prvními dvìma má nejlep¹í mediánovou hodnotu fitnes IPHash. Nad druhımi dvìma naopak náhodné prohledávání.
Èlovìkem vytvoøené algoritmy ani v jednom pøípadì napøekonaly IPHash. Naopak IPHash nad obecnımi ha¹ovacími
funkcemi jasnì dominuje. Rozdíl je nejvíce znát v v pøípadì funkce \textit{CityHash} nad datasetem dva, kde se rozdíl
rovná hodnotì 150 naha¹ovanıch funkcí. Nejménì je to naopak v pøípadì funkce \textit{FarmHash} nad datasetem tøi,
kde se rozdíl zmen¹il na 71 naha¹ovanıch adres.
 
Nyní se budeme podrobnìji zabıvat rozptylem nejlep¹ího nalezeného øe¹ení (ekvivalent
hodnoty poslední generace algoritmu), které  nalezne náhodné prohledávání a IPHash v porovnání s
algoritmem náhodného prohledávání.

%%%%%%%%%%%%% IPHASH BOXPLOT %%%%%%%%%%%%%%%
\begin{figure}[!h]
	\centering
	\begin{tikzpicture}
	\begin{axis}
	[ boxplot/draw direction=y
	, name=plot1
	, xtick={1,2,3}
	, xticklabels={RS, IPHash, Náhodné prohledávání}
	, ymin=5200
	, ymax=5360
	]
	\addplot+[
	boxplot prepared={
		lower whisker=5250,
		lower quartile=5266,
		median=5276,
		upper quartile=5286,
		upper whisker=5311,
	},
	] coordinates {}; % RS
	
	\addplot+[
	boxplot prepared={
		lower whisker=5279,
		lower quartile=5292,
		median=5301,
		upper quartile=5315,
		upper whisker=5352,
	},
	] coordinates {}; % IPHash
	
	\addplot+[
	boxplot prepared={
		lower whisker=5242,
		lower quartile=5265,
		median=5274,
		upper quartile=5286,
		upper whisker=5319,
	},
	] coordinates {}; % ERS
	\end{axis}		

	\begin{axis}
	[ boxplot/draw direction=y
	, name=plot2
	, at=(plot1.right of south east)
	, xtick={1,2,3}
	, xticklabels={RS, IPHash, Náhodné prohledávání}
	, ymin=5200
	, ymax=5360
	, yticklabels={,,}
	]		
	\addplot+[color=blue,
		boxplot prepared={
		lower whisker=5255,
		lower quartile=5270,
		median=5281,
		upper quartile=5290,
		upper whisker=5331,
	},
	] coordinates {}; % RS
	
	\addplot+[color=red,
		boxplot prepared={
			lower whisker=5286,
			lower quartile=5298,
			median=5305,
			upper quartile=5319,
			upper whisker=5352,
		},
		] coordinates {}; % IPHash
		
	\addplot+[
	boxplot prepared={
		lower whisker=5251,
		lower quartile=5270,
		median=5279,
		upper quartile=5285,
		upper whisker=5328,
	},
	] coordinates {}; % ERS
	\end{axis}		
	\end{tikzpicture}
	\caption{Porovnání vısledkù algirutmu IPHash a náhodného porovnání krabicovım diagramem pro datasety jedna a dvì.}
	\label{fig:basic_boxplot_1}
\end{figure}

Na dvou krabicovıch diagramech grafech na obrázku \ref{fig:basic_boxplot_1}, vidíme porovnání
algoritmù v nad datasety jedna dvì. Nad tìmito datasety si algoritmus vedl velmi dobøe, a to potvrzují
i krabicové diagramy. V celém rozsahu rozptylu námi navr¾eného øe¹ení dostáváme lep¹í vısledky, ne¾ u
algoritmu náhodného prohledávání a to v obou pøípadech. Nejlep¹í øe¹ení nalezené algoritmem náhodného
prohledávání je jen nepatrnì vı¹e, ne¾ horní hranice rozptylu algoritmu IPHash. Nejhor¹í øe¹ení nalezené
algoritmem IPHash je v pøípadì prvního datasetu lep¹í ne¾ medián algoritmu náhodného prohledávání a
v pøípadì druhého datasetu dokonce lep¹í, ne¾ nejlep¹í øe¹ení rozptylu náhodného prohledávání. Co se tıèe
nejlep¹ího øe¹ení algoritmu IPHash, tak to znaènì pøevu¹uje i to nejlep¹í øe¹ení nalezené algoritmem
náhodného prohledávání. Je tedy patrné, ¾e ve v¹ech pøípadech algoritmus IPHash dobøe konvergoval v daném
stavovém prostoru popsaném fitnes funkcí a zvolenou reprezentací jedincù.

\begin{figure}[!h]
\centering
\begin{tikzpicture}
	\begin{axis}
	[ boxplot/draw direction=y
	, name=plot3	
	, xtick={1,2,3}
	, xticklabels={RS, IPHash, Náhodné prohledávání}
	, ymin=5200
	, ymax=5360
	]		
	\addplot+[
	boxplot prepared={
		lower whisker=5246,
		lower quartile=5268,
		median=5277,
		upper quartile=5290,
		upper whisker=5302,
	},
	] coordinates {}; % RS
	
	\addplot+[
	boxplot prepared={
		lower whisker=5242,
		lower quartile=5261,
		median=5274,
		upper quartile=5287,
		upper whisker=5342,
	},
	] coordinates {}; % IPHash
	
	\addplot+[
	boxplot prepared={
		lower whisker=5237,
		lower quartile=5263,
		median=5275,
		upper quartile=5289,
		upper whisker=5318,
	},
	] coordinates {}; % ERS
	\end{axis}		

	\begin{axis}
	[ boxplot/draw direction=y
	, name=plot4
	, at=(plot3.right of south east)
	, xtick={1,2,3}
	, xticklabels={RS, IPHash, Náhodné prohledávání}
	, yticklabels={,,}
	, ymin=5200
	, ymax=5360
	]		
	\addplot+[
	boxplot prepared={
		lower whisker=5251,
		lower quartile=5269,
		median=5281,
		upper quartile=5285,
		upper whisker=5310,
	},
	] coordinates {}; % RS
	
	\addplot+[
	boxplot prepared={
		lower whisker=5252,
		lower quartile=5264,
		median=5278,
		upper quartile=5285,
		upper whisker=5298,
	},
	] coordinates {}; % IPHash
	
	\addplot+[
	boxplot prepared={
		lower whisker=5251,
		lower quartile=5268,
		median=5276,
		upper quartile=5290,
		upper whisker=5323,
	},
	] coordinates {}; % ERS
	\end{axis}		

	\end{tikzpicture}
	\caption{Porovnání vısledkù algirutmu IPHash a náhodného porovnání krabicovım diagramem pro datasety tøi a ètyøi.}
	\label{fig:basic_boxplot_2}
\end{figure}
%%%%%%%%%%%%% IPHASH BOXPLOT %%%%%%%%%%%%%%%

V kontrastu s vısledky nad prvními dvìma datasety jsou vısledky nad druhımi dvìma datasety. V obou pøípadech
si námi navr¾ené øe¹ení nevedlo v prùmìru lépe, ne¾ algorimus náhodného prohledávání. Je vidìt, ¾e nejlep¹í
nalezená øe¹ení mají obdobnı rozptyl. Nad datasetem èíslo tøi je rozptyl velmi podobnı, tìsnì ve prospìch 
náhodného prohledávání. Medián lze pova¾ovat za toto¾nı. Nejlep¹í nalezené øe¹ení v¹ak jasnì mluví ve prospìch
algoritmu IPHash, kde je rozdíl více ne¾ dvacet úspì¹nì naha¹ovanıch adres. V pøípadì datasetu èíslo ctyøi náhodné
prohledávání jasnì pøedèilo námi navr¾enı algoritmus. I pøes to, ¾e je mediánová hodnota náhodného prohledávání
nepatrnì men¹í, je zanedbatelná a lze ji pova¾ovat za nepøesnost mìøení. Horní i spodní hranice rozptylu náhodného
prohledávání je polo¾ena vı¹e ne¾ v pøípadì algoritmu IPHash. Celkem lze pozorovat, ¾e ani jeden algoritmus 
nena¹el øe¹ení, které by mohlo konkurovat nejlep¹ím vıslekùm dosa¾enım v nad pøede¹lımi datasety. I pøes to
nejlep¹í nalezené øe¹ení jednoznaènì mluví ve prospìch algoritmu náhodného prohledávání.

Nejlep¹ích vısledkù bylo dosa¾eno nad prvními dvìma datasety, kde v obou pøípadech si nejlépe vedl námi navr¾enı
algoritmus. U tøetího datasetu se vısledky zhor¹ili v porovnání s pøedchozími a to u obou algoritmù. Oba si byly 
rovnocéné, ale nejlep¹í øe¹ení nalezl algoritmus IPHash. V pøípadì posledního datasetu jsou vısledky podobné jako
v pøípadì datasetu tøi. Nejlep¹í øe¹ení nalezlo náhodné prohledávání, ale i zde mù¾eme pozorovat zhoø¹ení. 

%%%%%%%%%%%%% IPHASH Population depth %%%%%%%%%%%%%%%
\begin{figure}[!ht]
\centering
\begin{tikzpicture}
	\begin{axis}[ 
	, grid=major
	, width=0.49\linewidth
	, legend pos=outer north east
	, xlabel={Population size}
	, xtick={1,2,3,4,5,6,7,8}
	, xticklabels={8,16,32,64,128,256,512}
	, ylabel={Initial depth}
	, ytick={2,3,4,5,6} 
	, zlabel={Successfully hashed}
	, ztick={5280,5290,5300,5310,5320}
	, zticklabels={5280,5290,5300,5310,5320}
	]
	\addplot3[surf] coordinates {
		    %8            16         32           64           128          256          512          1024  
		    (1,2,5288.5) (2,2,5289) (3,2,5291)   (4,2,5294)	  (5,2,5297)   (6,2,5295)   (7,2,5293.5) (8,2,5296.5)
		    
		    (1,3,5292.9) (2,3,5301) (3,3,5300.5) (4,3,5314)   (5,3,5312.5) (6,3,5310.5) (7,3,5306)   (8,3,5307)
		    
		    (1,4,5299.5) (2,4,5306) (3,4,5305)   (4,4,5308.5) (5,4,5311.5) (6,4,5312)   (7,4,5306.5) (8,4,5309.5)
		    
		    (1,5,5299)   (2,5,5300) (3,5,5307)   (4,5,5313.5) (5,5,5302.5) (6,5,5311)   (7,5,5312)   (8,5,5307)
		    
		    (1,6,5293.5) (2,6,5302) (3,6,5304)   (4,6,5295.5) (5,6,5307)   (6,6,5304)   (7,6,5302)   (8,6,5307) 
		};
	\end{axis}
\end{tikzpicture}
\caption{Number of successfully hashed addresses in relation to population size and initial depth.}
\label{fig:basicPopulationDepth1}
\end{figure}
%%%%%%%%%%%%% IPHASH Population depth %%%%%%%%%%%%%%%

\begin{table}[h]
	\centering
	\caption{Vliv rùznıch voleb and terminálních a neterminálních mno¾in na vıslednou hodnotu fitnes. Experimenty jsou provedeny
		napøíè v¹emi datasety.}
	\begin{tabular}{cccccc} \\ \hline
		Terminal set & Function set & Dataset 1 & Dataset 2 & Dataset 3 & Dataset 4 \\ \hline
		$\{o_{0} .. o_{3}, \Re \}$ & $\{*, +, \wedge, \ggg\}$ & 5307 & 5305 & 5274 & 5278 \\
		$\{o_{0} .. o_{3}\}$ & $\{*, +, \wedge, \ggg\}$ & 5291 & 5269 & 5273 &  \\
		$\{o_{0} .. o_{3}, \Re \}$ & $\{*, +, \wedge, \neg, \ggg\}$ & 5300 &  & 5274 & \\
		$\{o_{0} .. o_{3}, \Re \}$ & $\{*, \wedge, \ggg\}$ & 5306 & 5274 & 5270 & \\
		$\{o_{0} .. o_{3}, \Re \}$ & $\{+, \wedge, \ggg\}$ & 5290 & 5270 &  & \\
		$\{o_{0} .. o_{3}, \Re \}$ & $\{*, +, \wedge\}$ & 5298 & & & \\
		$\{o_{0} .. o_{3}, \Re \}$ & $\{+, \wedge\}$ & 5065 & & 5018 & \\
		\hline
	\end{tabular}
	\label{tab:basicRunAlternatives1}
\end{table}

\section{Ha¹ování s Merkle-Damg\r{a}rdovou konstrukcí}

\section{Kukaèèí ha¹ování}

\chapter{Závìr}
\input{conclusion}

%=========================================================================