%=========================================================================

\chapter{Úvod}
\input{introduction}

\chapter{Ha¹ování}
\label{sec:hashing}
Ha¹ovací tabulky jsou dùle¾itou souèástí moderního svìta informaèních 
technologíí. Jsou to vyhledávací datové struktury, které nám za urèitých
okolností umo¾ní vyhledávat, vkládat a mazat ulo¾ené polo¾ky s konstantní
èasovou slo¾itostí. Jedná se o jednu z nìkolika mo¾ných implementací
asociativního pole. Ty dal¹í jsou napøíklad stromové implementace, 
implementace vázaným seznamem s lineáním prùchodem a dal¹í. ®ádnými
z tìchto implementací se zde zabývat nebudeme \cite{art_of_programming}.

\section{Princip}
Mìjme dané univerzum klíèù $U$, kde nìkteré klíèe $k \in U$ si pøejeme
asociovat s nìjakými satelitnímy daty $v$, jejich¾ povaha není pro nás v
tuto chvíli dùle¾itá. Dále máme dynamickou mno¾inu $S = \{(k,v) | k \in u\}$
uchovávající klíèe s jejich satelitními daty. Pak nad mno¾inou $S$ chceme
pro nìjaký klíè $k$ a nìkteré její polo¾ky $x=(k, v)$ provádìt následující 
operace: 

\begin{enumerate}
	\item \textit{vkládání} dat, tedy operaci 
		$Insert(S,x) : S \to S \cup \{(k, v)\} $,

	\item \textit{mazání} dat, tedy operaci 
		$Delete(S,x) : S \to S - \{(k, v)\}$

	\item \textit{výhledávání} satelitních dat podle zadaného klíèe,
		tedy operaci \newline $Search(S,k) : 
			\begin{cases}
				x 	: x.k = k \\
				nil : jinak 
			\end{cases} $
\end{enumerate}

Operace vyhledávání není totální, musíme tedy explicitnì vhodnì o¹etøit
pøípady, kdy se prvek $x=(k,v)$ v tabulce nevyskytuje.

Nejjedodu¹¹í implementací je \textit{tabulka s pøímým pøístupem} za
pøedpokladù, ¾e $|U|$ je pøijatelná. Uva¾me napøíklad univerzum
klíèu $U = \{0,1,2,3,\ldots,m-1\}$, a tabulku $T$ reprezentující
dynamickou mno¾inu $S$, pak nejjednodu¹¹ím pøístupem je pou¾ít jako
klíèe pøímo prvky mno¾iny $U$. Pak operace vyhledávání je rovna operaci
pøístupu do tabulky na zadanou lokaci, napøíklad $Search(T,k) = T[k]$
pro nìjaký klíè $k \in U$.

Mù¾e v¹ak nastat pøípad, kdy $m$ bude pøíi¹ velké èíslo. Typickým pøíkladem
jsou klíèe mno¾iny v¹ech mo¾ných øetìzcù. Pak by tabulka s pøímým pøístupem
byla pøíli¹ velká a nevhodná pro moderní poèítaèe. Pokud potøebujeme 
vyhledávat pouze v nìjaké podmno¾inì $K \subset U$, kde $|K| << |U|$, je 
vhodné pou¾ít ha¹ovací funkci. Zjevnou výhodou tabulek s pøímým pøistupem je slo¾itost
, která je $\theta (1)$ v nejhor¹ím pøípadì. Nevýhodou je pamì»ová nároènost
pro velká univerza $U$, kdy velká èást tabulky zùstane prázdná.

\subsection{Ha¹ovací funkce}
Ha¹ovací funkce je zobrazení, mapující prvky mno¾iny $U$ na jednotlivé 
sloty (indexy) tabulky $T$ :
$$ f_{hash} : U \to (0,1,\ldots,m-1)$$
za pøedpokladu, ¾e tabulka má právì $m-1$ slotù. Vyhledávací struktura 
slo¾ená z dynamické mno¾iny $S$ reprezentovanou tabulkou $T$ a ha¹ovací 
funkcí $f_{hash}$ se nazývá \textit{ha¹ovací tabulka} 
viz. \ref{fig:hash_table_example}.

%%%%%%%%%%%%% HASH TABLE EXAMPLE %%%%%%%%%%%%%%%
\begin{figure}[!ht]
	\centering
	\includegraphics[scale=0.6]{fig/hash_table_example}	
	\caption{Princip fungování ha¹ovacích tabulek}
	\label{fig:hash_table_example}
\end{figure}
%%%%%%%%%%%%% HASH TABLE EXAMPLE %%%%%%%%%%%%%%%
 
Vzhledem k tomu, ¾e velikost tabulky je men¹í, ne¾ velikost univerza $|U|$,
budou nastávat kolize. Kolize je pøípad kdy, dva rùzné prvky univerza
$k_{1}, k_{2} \in U$ budou zobrazeny na stejný slot : 
$f_{hash} (k_{1}) = f_{hash} (k_{2})$. S tímto neduhem se dá vypoøádat mnoha 
zpùsoby, jak uvidíme dále v sekci \ref{sec:collisions}.

\section{Kritéria kvality ha¹ovacích funkcí}

Shròme si nyní základní kritéria, která jsou dùle¾iá pro ha¹ovací funkce.

\subsection{Uniformní rozlo¾ení výstupù}

Pro dokonalé uniformní rozlo¾ení ha¹ovací funkce bychom potøebovali \textit{náhodný}
generátor a i kdybychom nìjaký mìli k dispozici, pak by sice dobøe dokázal 
rozprostøít jednotlivé prvky do ha¹ovací tabulky, nicménì vzhledem k jeho náhodné 
povaze bychom je jen tì¾ko zpìt dohledávali. Musíme tedy zvolit jinou 
alternativu. Ha¹ovací funkce musí být deterministická a musí dobøe aproximovat
uniformní rozlo¾ení. Uniformní rozlo¾ení výstupù je pøedpokladem pro
nízkou èasovou slo¾itost ha¹ovacích algoritmù, jak je vidìt z pøíkladu
v sekci \ref{se:hash_function_design}.

\subsection{Odolnost proti kolizím}

Uva¾ujeme-li uniformní rozlo¾ení ha¹ovací funkce, pak dva klíèe u univerza
$U$ budou kolizní (dle \textit{birthday attack}) asi po $2^{\frac{m}{2}}$ 
operacích vlo¾ení\cite{NCHF_auto_design}. Pokud v¹ak ha¹ovací funkce nebude
uniformì distribuovat výsledky, pravdìpodobnost kolize se rapidnì zvý¹í.

\subsection{Lavinový efekt}

Lavinový efekt (angl. Avalanche effect) je vlastnost ha¹ovací funkce, pøi
které se rapidnì mìní výstup ha¹ovací funkce pro malou zmìnu vstupu. 
Funkce které mají vysoký lavinový efekt mohou odolávat problému shlukování,
pøi kterém se nìkteré èásti univerza mají tendenci shlukovat na výstupu
do skupin.

\subsection{Rychlost}

Nesporná výhoda ha¹ovacích tabulek je jejich rychlost. Dobøe navr¾ená ha¹ovací
tabulka dosahuje za urèitých okolností slo¾itosti $\theta (1)$. Pokud je v¹ak
výpoèetní algoritmus pøíli¹ slo¾itý, mù¾e daná funkce být pomalá. Je proto
nutné dbát na to, ¾e pøíli¹ pomalý, i kdy¾ dobrý algoritmus nemusí být
v¾dy ten nejlep¹í. 

\section{Návrh ha¹ovací funkce}
\label{se:hash_function_design}

V praxi je èasto sly¹et názor, ¾e ha¹ovací funkce pracují v konstantním èase.
To v¹ak není pravda, nebo» výkon ha¹ovací funkce zále¾í jednak na faktoru
zatí¾ení ha¹ovací tabulky a uniformnosti, s jakou doká¾e ha¹ovací funkce
pøíøazovat klíèe do slotù.

Zamìøme se nejprve na zatí¾ení tabulky a uva¾me nìjakou podmno¾inu univerza
v¹ech klíèù $K \in U$, ha¹ovací tabulku $T$ s $m$ sloty a oznaème $n = |K|$.
Pokud $n$ bude men¹í ne¾ $m$, pak ha¹ovací tabulka bude skuteènì pracovat v 
$\theta (1)$, za pøedpokladu uniformního rozlo¾ení ha¹ovací funkce. Pokud ale
bude $m$ men¹í ne¾ $n$, faktor zatí¾ení bude vìt¹í ne¾ jedna a ha¹ovací tabulka
v konstantním èase pracovat nebude. Uva¾me $m=4$ a $n=5$. Pak za pøedpokladu
uniformního rozlo¾ení ha¹ovací funkce, s vlo¾ením pátého prvku bude ha¹ovací 
tabulka plná a nám nezbude ne¾ vkládaný prvek zaøadit na zaèátek jednosmìrnì
vázaného seznamu.

Existuje mnoho metod pro konstrukci ha¹ovací funkce, jako jsou napøíklad
\textit{metoda násobení}, \textit{metoda dìlení} a dal¹í komplikovanìj¹í
pøístupy. V souèasné dobì existují velmi dobré implementace obecných ha¹ovacích funkcí.
Av¹ak ¾ádná ha¹ovací funkce nemù¾e pracovat pro v¹echna mo¾ná univerza stejnì
dobøe. Jako pøíklad uva¾ujme ha¹ovací funkci navr¾enou metodou dìlení :
$$ f_{hash}(k) = k \text{ mod } 8 $$ 
a dále uva¾ujme univerzum $U = \mathbb{N}$ a jeho
podmno¾inu $K = \{1,2,3,4,8,13,22,71\}$, kterou budeme vkládat do tabulky.
Ha¹ovací funkce je schopna ulo¾it $8$ ruzných hodnot a v pøípadì 
na¹eho výbìru mno¾iny $K$, se nám podaøí ulo¾it v¹echny, ani¾ by do¹lo ke kolizi.
Co by se ale stalo, pokud bychom byli omezení na univerzum pouze tìch
pøirozených èisel, která jsou dìlitelné osmi $U = \{x \in \mathbb{N}
\land x \text{ mod } 8 = 0\}$? Nemohli bychom vybrat ¾ádnou podmno¾inu 
$F \in U$ takovou, kterou by funkce $f_{hash}$ nezobrazila pouze na jeden
slot.

Je vidìt, ¾e pokud máme informace o univerzu mo¾ných klíèù, mù¾eme navrhnout
ha¹ovací funkci 'na míru' tak, aby mìla lep¹í vlastnosti, ne¾ obecná
ha¹ovací funkce. Tento úkol je v¹ak obtí¾ný a neexistuj pro nìj obecný
návod jak toho docílit. Musíme se spolehnout na zku¹enosti, znalosti a v 
neposlední øadì také na intuici. Nebo mù¾eme zvolit úplnì jiný pøístup
jak napovídá kapitola \ref{sec:evolution_design}.

\subsection{Merkle-Damg\r{a}rdovo konstrukèní schéma}
V oblasti kryptografických ha¹ovacích funkcí se Merkle-Damg\r{a}rdovo schéma \cite{merkle0} jedním ze základních
stavebních kamenù moderních kryptografických ha¹ovacích funkcí.
Dokazují to nesèetné implementace state of the art ha¹ovacích funkcí na nìm zalo¾ené. Jako
pøklad mù¾eme uvést algoritmy \textit{MD5} \cite{rfc1321}, \textit{SHA-1} \cite{rfc3174},
\textit{SHA-2} \cite{rfc4634} nebo \textit{Tiger} \cite{tiger}.

Jedná se o obecné schéma pro výstavbu ha¹ovacích funkcí odolných proti kolizím z jednosmìrnì
kompresní funkce. Schéma se skládá z $n$ blokù pevné délky reprezentující vstupní zprávu.
K nim korespondují jednosmìrné kompresní funkce. Ka¾dá kompresní funkce má na vstupu blok vstupních dat,
výstup pøedchozí kompresní funkce a produkuje výstup. Velikosti obou vstupu a výstupu jsou toto¾né,
proto nazýváme funkce kompresní. Poslední èlánek v øetìzu kompresních funkcí pøedstavuje vhodné 
zarovnání. Nìkdy se také pou¾ívá volitelna finalizaèní komponenta. Schéma blí¾e ilustruje obrázek 
\ref{fig:merkle_damgard}.

Bylo nezávisle ukázáno, ¾e pokud je pou¾itá vhodná 'vata'
(angl. \textit{padding}) pro zarovnání na správnou velikost a kompresní funkce jsou odolné
proti kolizím, pak vzniknuv¹í ha¹ovací funkce je také odolná proti kolizím \cite{damgard0}.

Dùvodem, proè se zde zabýváme kryptografickým schématem je, ¾e jej pou¾ívají i mnohé nekryptografické
ha¹ovací funkce. I pøes to, ¾e tyto funkce nejsou kryptograficky bezpeèné (co¾ ani není úèelem zavedení
Merkle-Damg\r{a}rdova shématu), pou¾ití kryptografického schématu dodá do ha¹ovací funkce dodateènou 
náhodnost. Pou¾itím schématu docílíme v evoluèním algoritmu znaèného zmen¹ení prohledávaného prostoru
a tedy lep¹í a rychlej¹í konvergence algoritmu viz. dále kapitola \ref{sec:evolution_design}.

Kromì Merkle-Damg\r{a}rdova schémata, exitují i jiná konstrukèní schémata, napøíklad Merkleho strom 
\cite{merkle1}, èasto pou¾ívaný v \textit{P2P} sítích,
struktura \textit{HAIFA} \cite{haifa} pou¾itá v rodinì kryptografických ha¹ovacích funkcí \textit{BLAKE}
nebo funkce \textit{Sponge} \cite{sponge}. Tìmito se zde v¹ak zabývat nebudeme.

 
\begin{figure}
	\centering
	\includegraphics[width=\textwidth]{fig/merkle_damgard}
	\caption{Obecné Merkle-Damg\r{a}rdovo schéma pro $n$ blokù.}
	\label{fig:merkle_damgard}
\end{figure}

\section{Øe¹ení kolizí pøi ha¹ování}
\label{sec:collisions}

Situaci, kdy ha¹ovací funkce zobrazí dva rùzné klíèe na tentý¾ slot:
$f_{hash} (k_{1}) = f_{hash} (k_{2})$ nazýváme ha¹ovací kolize nebo jen kolize. 
Kolize jsou ne¾ádoucím dùsledkem pou¾ití ha¹ovacích funkcí
a chceme se jim pokud mo¾no vyhnout, nebo» zásadním zpùsoben negativnì ovlivòují 
èasovou slo¾itost asociativních polí, které jsou na ha¹ovacích funkcích postavené. 
Pro dobré pochopení kolizí je nezbytné uvést míru zaplnìní ha¹ovací tabulky
neboli takzvaný faktor zatí¾ení $\alpha$ definovaný vztahem $\alpha = \frac{n}{m}$.
Právì èasová slo¾itost tabulky zále¾í za pøedpokladu uniformního rozlo¾ení 
ha¹ovací funkce právì na \textit{faktoru zatí¾ení}. 

Pou¾itím kvalitní ha¹ovací funkce mù¾eme riziko kolizí do jisté míry minimalizovat, ale
s narùstajícím faktorem zatí¾ení $\alpha$ roste i riziko kolize, které dosáhne 
urèitosti pøi $\alpha = 1$, tedy v ha¹ovací tabulce není ji¾ ¾ádný volný slot.
V takovém pøípadì musíme kolizi vhodným zpùsobem øe¹it. Zpùsobù jak takovou sitaci
øe¹it je mnoho. My si v této sekci uvedeme ty, které jsou pro na¹i práci podstatné.

\subsection{Zøetìzené ha¹ování}

\begin{figure}
	\centering
	\begin{subfigure}[b]{0.49\textwidth}
		\includegraphics[width=\textwidth]{fig/chained_hashing_insert}
		\caption{Operace vlo¾ení nového prvku do ha¹ovací tabulky zpùsobí kolizi klíèù.}
	\end{subfigure}
	\begin{subfigure}[b]{0.49\textwidth}
		\includegraphics[width=\textwidth]{fig/chained_hashing_insert_result}
		\caption{Kolidovaná data se zøetìzí v jednosmìrnì vázaném seznamu.}
	\end{subfigure}
	\caption{Demonstrace øe¹ení kolize za pou¾ití vázaného seznamu.}
	\label{chained_hashing}
\end{figure}

Nejjednodu¹¹í a nejznámìj¹í formou øe¹ení kolizí je øetìzení dat v daném slotu. Jednotlivé 
sloty jsou reprezentovány jednosmìrnì vázaným seznamem, jeho¾ polo¾ky tvoøí data dohromady
s klíèem. Èasová slo¾iost takové implementace je:
\begin{itemize}
	\item v nejhor¹ím pøípadì $\theta (n)$, kdy v¹echny prvky budou namapovány
	na jeden slot,
	\item v prùmìru bude $\theta (1 + \alpha)$, za pøedpokladu
	uniformního rozlo¾ení, kdy pravdìpodobnost namapování libovolného
	prvku na konkrétní slot je $\frac{1}{m}$.
\end{itemize}

Èasovou slo¾itost lze vylep¹it vhodnou heuristikou, jakou mù¾e být napøíklad sledování
èetnosti vyhledávání daných klíèù s následným vhodným pøeuspoøádáním jednosmìrnì vázaného
seznamu. Prostorová slo¾itost této implementace také narùstá, nebo» souèástí ka¾dé polo¾ky jednosmìrnì
vázaného seznamu \textit{ll} je i ukazatel na dal¹í prvek potøebný pro získání
dal¹ího prvku seznamu \textit{next(ll)}. Øe¹ení kolizí zøetìzením kolidovaných 
polo¾ek do jednosmìrnì vázaného seznamu poskytuje za pøedpokladu uniformního rozlo¾ení dobré
výsledky a je výraznì rychlej¹í ne¾ samotný jednosmìrnì vázaný seznam. Existují v¹ak i jiné
pøístupy, nabízející lep¹í vlastnosti.

\subsection{Kukaèèí ha¹ování}

Kukaèèí ha¹ování je moderní pøístup k øe¹ení ha¹ovacích kolizí, za pou¾ití dvou a více ha¹ovacích
funkci a jedné nebo více tabulek \cite{Cuckoo_hashing}. Èastá implementace zahruje pouze jednu
tabulku, v ní¾ má ka¾dá ha¹ovací funkce vyhrazena vlastní prostor. Uva¾ujme univerzum klíèù $U$
a velikosti ha¹ovací tabulky $m$. Pak na pøíklad pro dvì ha¹ovací funkce 
$h_1, h_2$, kde $h_1 : U \rightarrow \{0,\ldots,r_1-1\}$ a $h_2 : U \leftarrow \{r_1,\ldots,r_2-1\}$ musí platit
$|\{0,\ldots,r_1-1\} \cup \{r_1,\ldots,r_2-1\}| = m$ a celkový poèet slotù ha¹ovací tabulky je $m$.

Opakem je implementace, kdy ka¾dá ka¾dá ha¹ovací fukce obsluhuje dedikovanou tabulku. Zde pro
jiné dvì funkce $h_3, h_4$ tvaru $h_3 : U \rightarrow \{0,\ldots,r_1-1\}$ a $h_4 : U \leftarrow \{0,\ldots,r_1-1\}$
musí opìt platit $|\{0,\ldots,r_1-1\} \cup \{0,\ldots,r_1-1\}| = m$. Tedy ¾e ha¹ovací funkce musí dokonale pokrýt
celou ha¹ovací tabulku.

Název Kukaèèí ha¹ování je odvozen z chování nìkterých druhù kukaèek, kdy kukaèky vytlaèují vejce nebo své mladé
z hnízda. Toto chování je velmi podobné operaci vkládání. I pøes to, ¾e se rozhraní operace $Insert(S,x)$ nemìní 
, výraznì se mìní její vnitøní implementace. Operace vlo¾ení prvku do tabulky, vybere jednu z dostupných ha¹ovacích
funkcí a pokusí se vlo¾it prvek na pøíslu¹né místo. Dojde-li ke kolizi, pùvodní prvek je vytlaèen a nahrazen prvkem novým.
Vytlaèený prvek je znovu vlo¾en do tabulky, av¹ak za pou¾ití jiné ha¹ovací funkce. Tento postup se opakuje tak dlouho, dokud
dochází pøi vkládání ke kolizím. Zøejmì tímto zpùsobem mù¾e docházet k cyklùm. Maximální poèet po sobì jdoucích vlo¾ení je tedy
omezen konstantou. Celý proces blí¾e demonstruje algoritmus \ref{alg:cuckoo_hashing} a obrázek \ref{fig:cuckoo_hashing}.

\begin{figure}
	\centering
	\begin{subfigure}[b]{0.53\textwidth}
		\includegraphics[width=\textwidth]{fig/cuckoo_hashing_insert}
		\caption{Kolize je øe¹ena za pou¾ití druhé ha¹ovací funkce.}
	\end{subfigure}
	\begin{subfigure}[b]{0.46\textwidth}
		\includegraphics[width=\textwidth]{fig/cuckoo_hashing_insert_result}
		\caption{Data v tabulkce se po nìkolikanásobném vytlaèení ustálí.}
	\end{subfigure}
	\caption{Demostrace øe¹ení kolize za pou¾ití kukaèèího ha¹ování.}
	\label{fig:cuckoo_hashing}
\end{figure}

Pokud v prùbìhu operace dosa¾eno mezní hodnoty $MaxLoop$, pøedpokládáme ¾e jsme narazili na cyklus. V takovém pøípadì 
provedeme nejprve operaci \Call{rehash}{} a poté zkusíme prvek vlo¾it opìtovným zavoláním funkce \Call{insert}{x}.
Funkce \Call{rehash}{} zaji¹»uje, aby pøi opìtovném vlo¾ení prvku do tabulky znovu nevzniknul cyklus. Toho se dá
dosáhnout napøíklad pou¾itím jiných ha¹ovacích funkci \cite{Cuckoo_hashing}. Není tøeba znovu vytváøet ha¹ovací tabulku,
postaèí ha¹ovací tabulku projít a na ka¾dý prvek uplatnit nejprve operace \Call{delete}{x}, která jej z tabulky odstraní 
a následnì jej znovu vlo¾it za pou¾ití operace \Call{insert}{x}.

\begin{algorithm}
\begin{algorithmic}
\Function{insert}{x}
	\Repeat
		\State $x \leftrightarrow T_1[h_1(x)]$
		\If {$x = \bot$} \Return \EndIf
		\State $x \leftrightarrow T_2[h_2(x)]$
		\If {$x = \bot$} \Return \EndIf
	\Until{$!MaxLoop$}
	\State \Call{rehash}{}; \Call{insert}{x}
\EndFunction
\end{algorithmic}
\caption{Pseudokód popisující operaci $insert$ za pou¾ití kukaèèího ha¹ování.}
\label{alg:cuckoo_hashing}
\end{algorithm}

Èasová slo¾itost výhledávání v tabulce za pou¾ití Kukaèèího ha¹ování je v prùmìru $\theta(1)$. Pro nás je ale
dùle¾itìj¹í, ¾e èasová slo¾itost v nejhor¹ím pøípadì zustává také konstantní. Je v¹ak dùle¾ité zohlednit 
následující faktory:
\begin{itemize}
	\item Je nutné pou¾ít takové ha¹ovací funkce, které dobøe uniformì distribuují svoje výstupy. Pokud by tento
	pøedpoklad nebyl splnìn, mù¾e být (a pravdìpodobnì bude) èasto volána nákladná operace \Call{REHASH}{}.

	\item Operace \Call{REHASH}{} nezvìt¹uje ani nezmen¹uje kapacitu ha¹ovací tabulky. Vzhledem k tomu, ¾e ka¾dý slot
	ha¹ovací tabulky pojme právì jeden klíè, maximální faktor zatí¾ení $\alpha$ je právì roven jedné (co¾ je pøesný
	opak chování zøetìzeného ha¹ování, kdy za pou¾ití vázaného seznamu snadno dosáhneme $\alpha \geq 1$).

	\item Je dobré poèítat s tím, ¾e i za pou¾ití více ha¹ovacích funkcí se koeficientu $\alpha = 1$ pøiblí¾íme jen
	vzdálenì. Opìtovné pokusy o vlo¾ení prvku do tabulky, která má ji¾ koeficient $\alpha \approx 1$ nevyhnutelnì
	vyústí ve volání funkce \Call{REHASH}{}. Je tedy vhodné podrobit Kukaèèí ha¹ování nìjaké formì heuristiky, kdy
	bude její kapacita ve vhodný okam¾ik zvìt¹ena, aby nedocházelo k opakovanému volání funkce \Call{REHASH}{}.
\end{itemize}

\section{Analýza existujících øe¹ení}
Cílem této sekce je podat pøehled o existujících state of the art obecných ha¹ovacích funkcích, proto¾e nìkterými z tìchto
funkcí budeme porovnávat námi navr¾ené ha¹ovací funkce. Také budeme analyzovat, z jakých elementárních operací se 
dané ha¹ovací funkce skládají, co¾ nám poslou¾í pøedev¹ím pro návrh mno¾iny funkcí dále viz. kapitola  
\ref{sec:solution_design}. 

\textit{MurmurHash2} \cite{murmurhash2}, \textit{MurmurHash3} \cite{murmurhash3} \textit{FarmHash} \cite{farmhash}, \textit{CityHash} \cite{cityhash_slides}

\chapter{Evoluèní návrh}
\label{sec:evolution_design}

% Chapter INTRO
Evoluèní návrh je netradièní disciplína, která vyu¾ívá evoluèní algoritmy
k návrhu. Evoluèní algoritmy spadají do oblasti umìlé 
inteligence. Specifickou vlastností mnoha úloh spadajících do obasti umìlé 
inteligence je, ¾e èasto vhodným zpùsobem prohledávají prostor $U$,
reprezentující v¹echna mo¾ná øe¹ení (kandidátní) dané úlohy 
\cite{evolution_hardware}. Evoluèní algoritmy se dají pova¾ovat za speciální metodou 
prohledávání prostoru kandidátních øe¹ení.

% Section Natural computing
\section{Poèítání podle pøírody}
\label{sec:natural_computing}
Poèítání podle pøírody (Natural computing) je sohrný termín pro tvorbu 
inteligentních strojù napodobováním biologických procesù, chování ¾ivých 
tvorù nebo jejich mechanismù. Øadíme sem také výpoèetní paradigmata, která 
svoji inspiraci nalezla v pøírodních procesech nebo pou¾ití organismù a 
jiných netradièních materiálù jako výpoèetních platforem. Míra do jaké je 
pøírodní fenomén napodoben se rùzní. Od Témìø úplného napodobení a¾ po 
inspiraci. 

Jedním z motivù pro vznik alternativních výpoèetních pøístupù a poèítání 
podle pøírody je lep¹í splynutí s reálným svìtem a jeho probémy.
V tomto kontextu je vhodné zmínit \textit{soft-computing}. \textit{Soft-computing}
je podmno¾inou poèítání podle pøírody, bývají sem zaøazovány 
neuronové sítì, \textit{Support Vector Machines}, fuzzy systémy, evoluèní 
algoritmy a teorie chaosu. Postupy spadající do \textit{Soft-computing} 
tolerují nepøesnosti a nejistotu èím¾ dosahují vysoké robustnosti a 
lep¹ího vztahu s realitou. Poèítání podle pøírody ve svùj prospìch pou¾ívá 
procesy zejména fylogeneze, ontogeneze a epigeneze. Fylogeneze oznaèuje proces
evoluce druhù, ontogeneze proces vývoje mnohobunìèného organismu a epigeneze
je nìjaký proces, který nastává v ji¾ slo¾itìj¹ím organismu 
(sem øadíme napøíklad neuronové sítì).
Dále se se poèítání podle pøíody inspirovalo procesy vznikajícími ve spoleènosti, 
v usuzování jedincù apodobnì. My se zde budeme zabývat hloubìji pouze fylogenezí, nebo» 
právì na ní je zalo¾ena my¹lenka evoluèních algoritmù.

\section{Evoluèní algoritmy}

Fylogeneze je proces evoluce druhù. Evoluce je umo¾nìna schopností reprodukce jednotlivých
jedincù, kdy potomkové se od svých roduèù li¹í jen velmi málo. Pøi reprodukci v¹ak dochází také
k náhodným obèasným mutacím, které zabezpeèují dostateènou diferzitu a vzniká tak nový
genetický materiál. Na fylogenezi jsou zalo¾ené evoluèní algoritmy. 

Evoluèní algoritmy lze chápat jako speciální optimalizaèní metodu nad prostorem 
$$U = D_{1} \times D_{2} \times D_{3} \times \ldots \times D_{n}$$
v¹ech kandidátních øe¹ení. Takový prostor je pak kartézský souèin domén, kde
jednotlivé domény univerza mohou nabývat
hodnot z pøedem známých, èasto nìjak omezených intervalù \cite{evolution_hardware}.  

V matematické optimalizaci, bychom se sna¾ili hledat hodnoty $x \in U$ takové,
pro které je hodnota úèelové funkce
$$ f : U \to \mathcal{R} $$
minimální (hledání maxima lze úpravou úèelové funkce pøevést na hledání minima).
Minima mohou být globální nebo lokální, ostrá nebo neostrá. Øe¹íme tedy úlohu,
kdy hledáme nìjaký argument, jeho¾ hodnota úèelové funkce spadá do mno¾iny optimálních
hodnot úèelové funkce \cite{nlprog}.
$$ argmin_{x}\{f(x)|x \in U\} $$		
V kontextu evoluèních algoritmù nazýváme $f$ funkcí \textit{fitness} a nehledáme 
argument $x$, pro nìj¾ je funkce $f$ minimální, ale postaèuje nám najít argument $x$ 
takový, ¾e $f(x)$ splní nìjaké pøedem dáné ukonèovací podmínky.

\subsection{Princip}
Evoluèní algoritmy jsou inspirované procesem reprodukce jedincù napøíè generacemi.
Na zaèátku výpoètu algoritmu vytvoøíme poèáteèní populaci $P_{0}$, tj.
populaci generace nula o pøedem známé velikosti $n$.
Volba jedincù do poèáteèní populace jsou rùzné, mù¾eme napøíklad sáhnout po náhodném 
výbìru nebo volit jedince za pou¾ití vhodné heuristiky.

%$$ \mathcal{P}_{0} = \{x|x \in U \land vyber\_do\_poèáteèní\_populace(x) \} $$

V ka¾dém dal¹ím kroku evoluèního algoritmu, který nazýváme generace, je nejprve vybráno
$m$ vhodných jedincù z generace pøedchozí $P_{t - 1}$, kteøí nám tvoøí mno¾inu rodièù. Aplikací
genetických operátorù nad mno¾inou rodièù vznikne mno¾ina potomkù, Následnì se z obou
mno¾in vybere nová generace $P_{t}$ o velikosti $n$ a celý process (znázornìn na diagramu \ref{fig:eaflow})
se opakuje. Zpùsoby výbìru rodièu jsou rùzné stejnì
tak jako mo¾né genetické operátory. Obìma se budeme zabývat pozdìji.

%%%%%%%%%%%%% EVOLUTION ALGORITHM FLOWCHART %%%%%%%%%%%%%%%
\begin{figure}[!ht]
	\centering
	\includegraphics[scale=0.4]{fig/evolution_algorithm_flowchart}	
	\caption{Obecný postup výpoètu evoluèního algoritmu}
	\label{fig:eaflow}
\end{figure}
%%%%%%%%%%%%% EVOLUTION ALGORITHM FLOWCHART %%%%%%%%%%%%%%%

\subsection{Fitness funkce}
Fitness funkce je obdoba úèelové funkce z oboru matematické optimalizace. Název fitness
pochází z oboru evoluèní biologie, kde hodnota fitness popisuje biologickou zdatnost jedince
\cite{evolution_hardware}. Vstupem fitness funkce je (v jednodu¹¹ím pøípadì) jedinec
reprezentovaný chromozomem a výstupem je hodnota reprezentující zdatnost jedince.

Ve slo¾itìj¹ích pøípadech je nutné rozli¹ovat mezi prostorem genotypù a fenotypù. Genotypem
nazýváme v kontextu evoluèních algoritmù prostor v¹ech mo¾ných øe¹ení, tedy 
v¹ech mo¾ných chromozomù. Fenotyp je soubor charakteristik, projevù a chování,
jimi¾ se daný jedinec reprezentovaný urèitým chromozomem projevuje.
Zobrazení z prostoru genotypù do prostoru fenotypù lze potom vyjádøít následovnì:
$$ f_{phenotype} : U \to \mathcal{F}, $$
Potom je v¹ak nutné modifikovat na¹i fitness funkci následovnì :
$$ f : \mathcal{F} \to \mathcal{R} $$
a celý proces evaluace jedince bude poté kompizice tìchto dvou funkcí :
$$ f_{eval} = f \circ f_{phenotype}$$

Volba pota¾mo návrh vhodné fitness funkce je znaènì obtí¾ná. Neexistuje ¾ádný obecný
pøedpis pro jejich návrh. Musíme se spoléhat na obecná pravidla, zku¹enosti nebo 
intuici. Velké mno¾ství dobøe zakomponovaných informací o problému ve fitness funkci je
dobrým základem pro úspì¹ný evoluèní algoritmus. Obecnì tedy platí, ¾e 
vhodnì zvolená fitness funkce má znaèný dopad na kvalitu výsledného øe¹ení.

\subsection{Zpùsoby selekce}
Zpùsoby selekce jsou dùle¾itým faktorem pøi návrhu evoluèního algoritmu. Selekce
je proces, pøi nìm¾ se vybýrají rodièe z aktuální populace urèení k reprodukci. 
Dobrý selekèní algoritmus musí být schopen upøednostòovat jedince s vysokou hodnotou
fitness funkce, na druhou stranu musí zajistit dostateèné mno¾ství genetického 
materiálù pro dal¹i generace. Èasto vyu¾ívané selekèní mechanismy, zejména v kontextu
genetických algoritmù jsou napøíklad \cite{selection_schemes_comparison} :

\begin{itemize}
	\item \textit{deterministická selekce}, kde se do mno¾iny rodièù vybere $k$
		jedincù z aktuální populace s nejvy¹¹í hodnotou fitness,
		
	\item \textit{proporcionlní selekce}, kde pravdìpodobnost výbìru jedince $i$ je 
		rovna vztahu $p_{i} = \frac{f(i)}{\sum_{j=1}{N} f(j)}$,
		
	\item \textit{turnajová selekce}, kdy je v nìkolika kolech turnaje postupnì 
		porovnáno nìkolik náhodnì vybraných jedincù a vítìz turnaje je zaøazen
		do mno¾iny rodièù. Turnaj provedeme $n$-krát, kde $n$ je po¾adovaná mohutnost
		mno¾iny rodièù. 
\end{itemize}

\subsection{Genetické operátory}
Evoluèní algoritmy vyu¾ívají køí¾ení i mutaci, oba mechanismy jsou pøevzaty z
oboru bunìèné biologie, kde se uplatòují v procesu redukèního dìlení bunìk.

Operátor mutace se aplikuje na potomka
a vytvoøí z nìj potomka mutovaného. Stejnì jako v biologii, mutace se vyskytuje
pouze v malém poètu pøípadù. Na¹im cílem je prozkoumat prostor $U$ postupnì a
konvergovat k dobrým øe¹ením. V pøípadì vysoké pravdìpodobnosti mutace se ji¾
nejedná o algorigmus \textbf{evoluèní}, nýbr¾ \textbf{revoluèní} a algoritmus pøipomíná 
spí¹e náhodné prohledávání. Operátor mutace je velmi dùle¾itý, nebo» zanesení
náhodne mutace zaji¹»uje nový genetický materiál, èím¾ je algoritmus jednou za
èas nucen prozkoumat vzdálenìj¹í bod prostoru. Neuvázne tak v lokálních extrémech.

Pøi køí¾ení dochází k pøenosu èástí chromozomù rodièù na potomka. Zpùsobù køí¾ení
existuje celá øada. Obecnì v¹ak platí, ¾e zpùsob køí¾ení je závislý na zvolené 
reprezentaci. Pokud máme jedince reprezentovaného grafem, operátor køí¾ení 
se bude znaènì odli¹ovat od pøípadu, kdy máme jedince reprezentovaného binárním
vektorem. 

Uveïmì si zde alespoò nejznámìj¹í druhy køí¾ení nad binární reprezentaci, jimi¾ jsou:
\begin{itemize}
	\item \textit{jednobodové køí¾ení}, kdy se urèí místo køí¾ení urèující,
		která èást chromozomu doputuje do potomka.
		
	\item \textit{dvoubodové køí¾ení} je obdobou vý¹e zmínìného, av¹ak pro dva body
		køí¾ení a
	\item \textit{uniformní køí¾ení}, které je do znaèné míry zobecnìním vý¹e zmínìných.
		 Urèí $n$ genù v chromozomu, jejich¾ hodnoty jsou vystøídány.
\end{itemize}

\subsection{Návrh evoluèního algoritmu}

Kvalita námi navr¾eného evoluèního algoritmu, je zejména závislá na následujících faktorech:
\begin{enumerate}
	\item reprezentace problémù a jeho kódování,
	\item pou¾itá fitness funkce,
	\item zobrazení z prostoru genotypù do prostoru fenotypù,
	\item volbou genetických operátorù a zpùsoby selekce,
	\item nastavením parametrù genetického algoritmu.
\end{enumerate}

Prostor ka¾dého problému øe¹itelného evoluènímy algoritmy je jiný. Neexistuje tedy obecný
evoluèní algoritmus, který by kvalitnì øe¹il v¹echny problémy. Toto tvrzení podporuje takzvaný
\textit{No Free Lunch} teorém. Pokud uvá¾íme dostateènì velký poèet optimalizaèních problémù,
neexistuje ¾ádný optimalizaèní algoritmus, který projde ka¾dý bod prostoru $U$ právì jednou
a v prùmìru bude efektivnìj¹í ne¾ ostatní optimalizaèní algoritmy \cite{nflteorem, evolution_hardware}. 
Z tohoto tvrzení plyne, ¾e chceme-li øe¹it optimalizaèní problém skuteènì efektnivnì, musíme 
do na¹eho evoluèního algoritmu \textbf{vlo¾it co nejvíce informací} o problému prostøednictvím 
zejména polo¾ek zmínìných vý¹e.

\subsection{Genetické algoritmy}

Evoluèní algoritmy popisují mno¾inu algoritmù, jejich¾ èinnost je urèena procesem Darwinovské
evoluce. Na druhé stranì je v¹ak neomezuje natolik, aby se od sebe nemohly (nìkdy i velmi
významnì) li¹it.

Asi nejvýznamìj¹ím ¾ástupcem evoluèních algoritmù jsou genetické algoritmy. Jedinci jedné populace
jsou reprezentovány øetìzcem (chromozomem) binárních, celoèíselných nebo i reálných hodnot.
Iniciální populace vzniká buï náhodnì nebo za pou¾ití vhodné heuristiky. Uplatòují se zde v¹echny
bì¾né selekèní mechanismy a stejnì tak zde najdeme pou¾ity v¹echny druhy metod køí¾ení.
Mutace se takté¾ pou¾ívá. Nevýhodou mohou nìkdy být chromozomý pevné délky.

\subsection{Evoluèní strategie}

Dal¹ím zajímavým algoritmem jsou evoluèní strategie. Jejich nejvìt¹í zajímavostí je, ¾e
se spoléhají pouze na operátor mutace. Køí¾ení se zde nevyskytuje. Nové generace se zde
vytváøejí zejména tak, ¾e rodièovská populace je mutována pøiètením hodnoty normálního rozlo¾ení s nulovou
$x' = x + \mathcal{N}(0, \sigma)$
støední hodnotou. Rozptyl $\sigma$ se mìní na základì toho, jak dobøe algoritmus aktuálnì
konverguje. Jako selekèní mechanismy se u¾ívá totální elitismus ve variantách $(\mu + \lambda)$
a $(\mu, \lambda)$ \cite{ES}. Uva¾ujeme-li $\mu$ mno¾inu rodièù a $\lambda$ mno¾inu jejich
potomkù, pak :

\begin{itemize}
	\item $(\mu + \lambda)$ vybere do dal¹í generace nejlep¹í jedince z mno¾iny
		rodièù a potomku
	\item $(\mu, \lambda)$ vybere do dal¹í generace jen ty nejlep¹í potomky. Rodièovská
		generace tedy vymírá.
\end{itemize} 

\section{Genetické programování}

Pro na¹í práce je zejména zajímavé genetické programování, nebo» právì to jsme zvolili 
jako evoluèní algoritmus pro øe¹ení na¹eho problémù. Seznámíme se s ním podrobnìji a 
proto mu vìnujme celou sekci.

Genetické programování je speciálním druhem evoluèního algoritmu, kde jednotlivce a 
celé populace tvoøí poèítaèové programy. Výpoèet iterativnì transformuje poèítaèové
programy na jiné poèítaèové programy aplikací genetických operátorù, které jsou 
pro genetické programování specifické. Výstupem genetického algoritmu
je v pøípadì, ¾e uspìje, nìjaký program. 

\subsection{Reprezentace}
Evolvované programy musíme vhodnì reprezentovat. Musíme pøí tom klást dùraz na to,
¾e programy je mezi sebou tøeba køí¾it, mutovat a obecnì na nich provádìt nutné
genetické operace. Na druhé stranì v¹ak chceme volit takovou reprezentaci, která
nám umo¾ní programy evaluovat, tudí¾ vykonávat je nad zadaným vstupem. 

Jedinci v populaci jsou reprezentování radìji jako \textit{abstraktní syntaktické stromy}
\cite{GPTutorial} ne¾ jako øádky programu. Ukázka jedince v geneticém programování je na
diagramu \ref{fig:exampletree1} a zobrazuje jedince reprezentovaného programem
\texttt{max(min(x,y), 5 + z)}. Stromy se skládají z uzlù a listù. Listy jsou
reprezentovány terminálním symbolem z mno¾iny terminálù $T$ a uzly jsou reprezentovány
funkcí z mno¾iny $F$. Na diagramu \ref{fig:exampletree1} mno¾inu funkcí tvoøí 
$F = \{max, min, +\}$ a mno¾inu terminálu $T = \{5, x, y, z\}$. Mno¾iny povolených
funkcí a terminálù dohromady tvoøí primitivní mno¾inu systému. Prostor mo¾ných 
øe¹ení mù¾eme tedy definovat jako mno¾inu v¹ech mo¾ných stromù, které mohou vzniknout
kombinací funkcí a terminálù :

$$ U = \{t | t=(FT)^{n}, 0 \leq n \leq max\_depth \}$$

Programová reprezentace stromù se li¹í v závislosti na pou¾itém programovacího jazyku.
Platí v¹ak, ¾e 
v prosøedích nároèných na výpoèetní výkon je pamì»ová nároènost grafové reprezentace
neefektnivní. Stromové reprezentace lze u¾ít i nepøímo za pou¾ití prefixové notace.
Pøí pou¾ití prefixové notace se závorky stanou nadbyteènými a program lze v pamìti
ulo¾it jako \textit{lineární sekvenci symbolù}. Jako pøíklad poslou¾í diagram 
\ref{fig:exampletree1}, tedy \texttt{max min x y + 5 z}. Volba reprezentace tedy
v koneèném dùsledkù zále¾í na u¾ivateli a jeho preferencích, po¾adavcích a prostøedí. 

%%%%%%%%%%%%% TREE REPRESENTATION EXAMPLE 1 %%%%%%%%%%%%%%%
\begin{figure}[!ht]
	\centering
	\includegraphics[scale=0.6]{fig/example_tree1}	
	\caption{Ukázka reprezentace programu max(min(x,y), 5 + z)}
	\label{fig:exampletree1}
\end{figure}
%%%%%%%%%%%%% TREE REPRESENTATION EXAMPLE 1 %%%%%%%%%%%%%%%

\subsection{Inicializace nulté populace}

Pro inicializaci nulté populace platí obecná pravidla. Mù¾eme ji buï volit náhodnì
nebo pou¾ít nìjakou vhodnou heuristiku. Je zde v¹ak specifická vlastnost, kterou 
musíme vzít do úvahy. Na¹e programy nemají pevnì omezenou velikost (délka
chromozomu je promìnná). Jak velké náhodné programy tedy generovat? Existují tøi
základní pøístupy:

\begin{enumerate}
	\item \textit{Full} metoda, kdy náhodnì vygenerujeme strom do maximální povolené
		hloubky,
	\item \textit{Grow} metoda, generujeme stromy promìnlivé délky a tvaru (maximální
		hloubka je omezena) a
	\item \textit{Ramped half-and-half}, kdy polovina populace je generována metodou
		\textit{Grow} a druhá metodou \textit{Full}, za promìnlivé maximální hloubky.
\end{enumerate}

Metoda Full v¾dy a za v¹ech okolností generuje plné stromy. V uzlech jsou funkce
vybírány náhodnì z mno¾íny $F$ a jakmile algoritmus dosáhne maximální hloubky,
nageneruje terminály z mno¾iny $T$ a skonèí.

Grow metoda naproti tomu generuje v uzlech s urèitou pravdìpodobností i terminály, èím¾
je schopna vytváøet stromy rùzných délek i tvarù. Je v¹ak velmi závisla na velikostech
mno¾in $F$ a $T$. Pokud $|T| << |F|$ algoritmus degraduje na metodu Full. Pokud
na druhé stranì $|T| >> |F|$, algoritmus bude generovat jen velmi malé stromy.

Aby se omezil dopad rozdílných velikostí mno¾in $T$ a $F$, John Koza navrhl alternativu
v podobì algoritmu ramped half-and-half. Ten pou¾ívá obì metody souèasnì na polovinu 
jedincù populace a maximální hloubku stromu volí náhodnì, èím¾ zaji¹»uje promìnlivou
velikost i tvar stromù.

\subsection{Genetické operátory a selekce}

V pøípadì selekce do mno¾iny rodièù, se vyu¾ívají v¹echny bì¾né selekèní mechanismy
známé z evoluèních algoritmù, av¹ak nejèastìji se vyu¾ívá turnajová selekce následovaná
proporcionální selekcí.

Zajímavìj¹í je to v pøípadì genetických operátorù køí¾ení a mutace. Nejèastìj¹í formou
køí¾ení je \textit{podstromové køí¾ení}. U rodièù vybraných k reprodukci se se náhodnì 
vybere bod køí¾ení, který v genetickém programování zastupují vìtve stromu. Potomek
vznikne umístìním podstromu prvního rodièe na prázdnou vìtev druhého rodièe (rodièe
implicitnì zachováváme). Celý proces blí¾e ilustruje diagram \ref{fig:tree_crossover}

%%%%%%%%%%%%% TREE CROSSOVER EXAMPLE 1 %%%%%%%%%%%%%%%
\begin{figure}[!ht]
	\centering
	\includegraphics[scale=0.6]{fig/tree_crossover}	
	\caption{Ukázka operátoru podstromového køí¾ení}
	\label{fig:tree_crossover}
\end{figure}
%%%%%%%%%%%%% TREE CROSSOVER EXAMPLE 1 %%%%%%%%%%%%%%%

Je vidìt, ¾e køí¾ení vytvoøí pouze jednoho potomka. Pro více potomkù celý proces 
opakujeme. Dale existuje specializace podstromového køí¾ení, obdoba jednobodového
kø¾ení, kdy se urèí v obou rodièích stejný bod køí¾ení a pøehození korespondujících
podstromù. Je v¹ak potøeba oba strommy projít a najít spoleèný region, tedy èást stromu,
kde je mo¾né køí¾it. Existují dal¹í varianty jako je køí¾ení se zachováním kontextu, 
velikost zachovávající køí¾ení a uniformní køí¾ení. Tìmito se zde zatím blí¾e zabývat
nebudeme.

Nejbì¾nìj¹í druh mutace je podstromová mutace. Algoritmus podstromové mutace ve stromu
náhodnì zvolí vìtev z ní¾ náhodnì vygeneruje nový podstrom, jak ilustruje diagram
\ref{fig:subtree_mutation}. V pøípadì tohoto algoritmu jde v podstatì o alternativu k
podstromovému køí¾ení s jedním rodièem a jedním náhodnì generovaným stromem.

Dal¹í variantou mutace v genickém programování je uzlová nutace, kdy na ka¾dý
uzel stromu je s urèitou nizkou pravdìpodobností mutace aplikována. Staré uzly
se nahrazují novými se stejnou aritou.

%%%%%%%%%%%%% SUBTREE MUTATION EXAMPLE 1 %%%%%%%%%%%%%%%
\begin{figure}[!ht]
	\centering
	\includegraphics[scale=0.6]{fig/subtree_mutation}	
	\caption{Ukázka operátoru podstromové mutace}
	\label{fig:subtree_mutation}
\end{figure}
%%%%%%%%%%%%% SUBTREE MUTATION EXAMPLE 1 %%%%%%%%%%%%%%%

\subsection{Fitness funkce}
Populace v genetickém programování jsou programy. Evaluace kvality programu se provádí
zpravidla spu¹tìním daného programu nad daným vstupem a ohodnocením výstupu. Spu¹tìní 
programu nad zadaným vstupem mù¾eme chápat jako zobrazení z mno¾íny genotypù do mno¾iny
fenotypù za vstupu dal¹ího parametru. Celý proces evaluace mù¾e být tedy chápán jako :
$$ f_{eval} = f \circ f_{run}(input)$$
kde $f$ je standarní fitness funkce a $f_{run} : I \to (U \to \mathcal{F})$ je
modifikované zobrazení genotyp-fenotyp pro nìjaký vstup $I$.

Fitness funkce v pøípadì genetického programování se li¹í od té tradièní v jednom
dùle¾itém smìru. Proto¾e pracujeme nad programy, musíme poskytnout zpùsob, jak daný
program spustit. Mo¾ností by bylo program zkompilovat. To s sebou nese znaènou re¾ii
a tak toto øe¹ení není v mnoha pøípadech vhodné. Pokud v¹ak bychom daný program chtìli
evaluovat nìkolikrát (mnohokrát), mù¾e se i toto øe¹ení jevit jako vhodné.

Èastìj¹í je ale programy interpretovat, to znamená projít strom od listù ke koøenu a 
spoèítání hodnoty uzlu za vstupu hodnot jeho následníkù. Kostru algoritmu bude jistì
tvoøit prùchod \textit{postorder}. Evaluace jednotlivých hodnot v¹ak nemusí být za v¹ech 
okolností triviální, mù¾e napøíklad nastat pøípad, kdy bude program dìlit nulou nebo
se sna¾it seèíst hodnoty rùzných typù (napø. \texttt{Bool} a \texttt{Int}). Pøi reprodukci
jedincù zde nará¾íme na podobné problémy jako napøíklad v teorii typù. Typovost se v
pøípadì genetického programování øe¹í dvìma základnímy zpùsoby:

\begin{enumerate}
	\item \textit{typová unifikace}, kdy ve¹keré uzly i listy stromu budou tého¾ typu,
	\item \textit{silná typovost}, kdy souèástí ka¾dého uzlu i listu stromu bude uveden
	explicitnì jeho typ.
\end{enumerate}

Typová bezpeènost je nutná zejména kvùli operátoru køí¾ení a mutace. V prvním pøípadì
musíme tedy poèítat s tím, ¾e jakýkoli podstrom mù¾e být zavì¹en jako argument
libovolné funkci z mno¾ny $F$ a výsledný program pøesto musí být interpretovatelný.
Jinými slovy navratový typ libovolné funkce z mno¾iny $F$ musí být stejný jako
typ libovolného vstupního argumentu jakékoli dostupné funkce. Toho mù¾eme dosáhnout
napøíklad jednodu¹e tím, ¾e v¹echny funkce z mno¾iny $F$ budou definovány nad jedním
oborem hodnot toto¾ného typu. Èasto to v¹ak není mo¾né, proto se musíme nìkdy uchílit
napøíklad k implicitním typovým konverzím.

Druhou mo¾ností je pou¾ití silnì typovaných stromù. Tento zpùsob je obecnìj¹í, nebo»
nám umo¾òuje pou¾ít naprosto libovolnou mno¾inu funkcí $F$. Je v¹ak také výraznì
implementaènì slo¾itìj¹í. Ve¹keré reprodukèní operace zde musí provádìt explicitní
typovou kontrolu a èastokrát dlouho procházet strom, ne¾ naleznou uzel vhodný ke 
køí¾ení èi mutaci. To má dopad samozøejmì hlavnì na èasovou slo¾itost, která je 
vy¹¹í ne¾ v pøípadì typové unifikace.

Spoleènou vlastností, kterou je nutné splnit jak v pøípadì silné typovosti, tak v pøípadì
typové unifiace je, abychom se vypoøádali s mo¾nými
nedefinovanými hodnotami, které jsou typické pro vstupy nìkterých parciálních funkcí
jako je dìlení, kde hodnota je nedefinovaná pokud je dìlitel roven nule.
S parciálními funkcemi se mù¾eme vypoøádat tím, ¾e je explicitnì roz¹íøíme na funkce
totální nebo v pøípadì, je-li nedefinovaná hodnota detekována, znaènì sní¾íme jedincùv 
fitness.

\chapter{Návrh øe¹ení}
\label{sec:solution_design}

Jak ji¾ bylo øeèeno v kapitole \ref{sec:hashing}, navrhujeme-li ha¹ovací funkci "na
míru" nìjakému konkrétnímu univerzu klíèù, mù¾eme dosáhnout podstatnì lep¹í 
výkonnosti ha¹ovací funkce, ne¾ je tomu v pøípadì obecných ha¹ovacích funkcí.

\section{Problém}
Na¹im problémem bude navrhnout konkrétní ha¹ovací funkci pro ha¹ování domény
\texttt{IP} adres. Adresa \texttt{IP} je èíslo, jednoznaènì identifikující sí»ové
rozhraní v síti, která pou¾ívá internetový protokol \texttt{IP}. Vzhledem k tomu,
¾e budeme ha¹ovat èísla, nabízí se otázka, zda by nebylo vhodné pou¾ít tabulku
s pøímým pøístupem, tedy pou¾ít \texttt{IP} adresy pro pøístup do tabulky
pøímo bez vyu¾ití ha¹ování. Bohu¾el neznáme konkrétní interval nebo podmno¾inu
univerza \texttt{IP} adres a celé univerzum je pøíli¹ velké na to, aby jeho 
prvky mohly slou¾it jako èísla slotù do tabulky. Ve verzi 4 se jedná o 32 
bitové èíslo a verzi 6 dokonce o velikosti 128 bitù. Tabulka by tedy musela
mít $2^{32} = 4 294 967 296$ slotù v pøípadì  \texttt{IP} verze 4 a ve verzi 6
dokonce $2^{128} \approx 3×10^{38}$
slotù. Je vidìt, ¾e tabulky by byly opravdu velké a jejich pamì»ová nároènost
by byla nedostupná i pro specializované poèítaèe, uva¾ujeme-li, ¾e by takový
stroj mìl dìlat i nìco jiného, ne¾ uchovávat tak ohromnou tabulku. Musíme se
tedy uchílit k návrhu ha¹ovací funkce.

Pracujeme nad ctyømi datasety, kde ka¾dý dataset obsahuje právì 8192 rùzných 
IP adres. Pro ka¾dý dataset bude nutno navrhnout zvlá¹tní ha¹ovací funkci a tu
na dané vstupy natrénovat. Nenavrhujeme obecnìj¹í ha¹ovací funkci, která by dobøe
pracovala nad libovolnou podmno¾inou celého univerza IP adres, ale velmi
specifické funkce, které budou dobøe pracovat právì nad zvoleným datasetem.
Proto¾e celý ha¹ovaný prostor je pøedem znám, sna¾íme se najít takové ha¹ovací
funkce, které pojmou co nejvíce z dané podmno¾iny. State of the art øe¹ení je v
tomto pøípadì taková ha¹ovací funkce, která pojme celý podprostor, její 
faktor zatí¾ení bude roven právì jedné ($\alpha = 1$). Taková øe¹ení v¹ak
bude tì¾ké najít. Pro na¹e úèely postaèí, nalezneme-li takové, které budou
pracovat lépe, ne¾ obecné ha¹ovací funkce, vytvoøené èlovìkem. Je zde samozøejmì
mo¾nost pou¾ít metody perfektního ha¹ovaní \cite{perfect_hashing}, ale to nemusí
být ve v¹ech pøípadech napøíklad z dùvodù pou¾ití na specializovaném hardware
dostupná mo¾nost. Zabývat se jí tedy nebudeme.


\section{Princip}
Ha¹ovací funkce budeme navrhovat evoluènímy algoritmy, konkrétnì za pou¾ití 
genetického programování. Zvoleno bylo genetické programování, proto¾e 
jako jedince populace abstraktní syntaktické stromy. Jenotlivé syntaktické 
stromy budeme interpretovat nad zadanými vstupy. Ohodnocení konkrétního jedince
bude spoèívat v naha¹ování jednoho celé subsetu. Na výstupu budeme mìøit, kolik 
rùzných klíèù dokázala ha¹ovach tabulku obsáhnout klíèù.

\section{Pøinos práce}
Evoluèní návrh ha¹ovacích funkcí byl se ukázalo jako zajímavé téma v posledním 
desetiletí \cite{dobai0,NCHF_auto_design,grammar_evolution,safdari}.
Naprostá vìt¹ina prací se se zamìrovala na návrh obecných ha¹ovacích
funkcí. Byly pou¾ity jak evoulèní návrh tak evoluèní optimalizace. Jedna z prací
podobná té na¹í je \cite{safdari}. Je podobná ve smyslu cíle a pou¾ité techniky,
av¹ak autor zde pou¾il evoluèní optimalizaci namísto návrhu. Autor zde optimalizuje
parametry $a,b$ následující ha¹ovací funkce:
$$h_{a,b}(k) = ((ak + b) \; mod \; p) \; mod \; N$$
kde $p$ je nìjaké prvoèíslo a $N - 1$ je nejvìt¹í index slotu ha¹ovací tabulky.
``Výsledky jsou slibné, ale pou¾itá metodika je sporná'' \cite{NCHF_auto_design}.
Proto¾e mno¾ina klíèù je obsahuje celá èisla a je volena náhodnì, náskýta se otázka,
proè vùbec evolvovat ha¹ovací funkci, kdy¾ mohou být pou¾ity její prvky k indexování
napøímo. Druhá vìc je, ¾e autor pou¾íva jako primární metriku fitness funkce odolnost
vùèi kolizím, která je silnì závislá na vstupní mno¾inì. Funkce tedy nemusí dobøe 
zobecòovat.

Vhodnìj¹í metrikou pro návrh obecných ha¹ovacích funkcí je lavinový efekt, který 
není závislý na vstupu. Tohoto faktu vyu¾ili autoøi dal¹í podobné práce \cite{NCHF_auto_design}
zabývající se návrhem ha¹ovacích funckí. Tato práce je pravdìpodobnì nejblí¾e té 
na¹í s rozdílem, ¾e my nenavrhujeme obecné ha¹ovací funkce. Autoøi stejnì jako my,
zvolili genetické programování jako evoluèní platformu a volili i podobné parametry.
Jako základ pro svoji fitnes funkci zvolili lavinový efekt, který není
závislý na vstupu. Funkce navr¾ené jejích systémem otestovali na rùzných vstupních tøídách
a dosáhli slibných výsledkù. Tvrdí, ¾e jeji algoritmus je velice robustní, proto¾e zmìny
klíèových parametrù mají jen velmi nízký nebo ¾ádný dopad na výsledné funkce. Bohu¾el
souèástí jejich experimentu není porovnání s algoritmem náhodného prohledávání, ke 
kterému mohl jejich systém nedopatøením degradovat a který je z povahy vìci také 
velmi robustní. Autoøi také tvrdí, ¾e evoluènì navrhují ha¹ovací funkce, co¾ 
vzhledem k tomu, ¾e navrhují kompresní funkce Merkle-Damg\r{a}rdova schémata
není ùplnì pravda. Takový pøístup se nachází na pomezí evoluèního návrhu a optimalizace.

Zajímavou prací, která se vydala pøístupem kartézského genetického programování je
\cite{dobai0}. Kartézské genetické programování je zejména vhodné pro aplikace blízké
hardwarové vrstvì, tak¾e jeho volba se zdá velmi dobrá vzhledem k cílové aplikaèní doménì
, kterou jsou sí»ové prvky. Nesporný pøínos práce spoèívá v pou¾ití Kukaèèího ha¹ování, které
je pou¾ito za úèelem zvý¹ení faktoru zatí¾ení výsledné ha¹ovací tabulky a práce tak dosáhla velmi
dobrých výsledkù. Faktor, který tato a na¹e práce sdílí je návrh doménovì specifické ha¹ovací 
funkce, kde ha¹ovanou doménou jsou také IP adresy. Práce se v¹ak rozchází zejména ve volbì 
fitnes funkce. Zatímco my (jak uvidíme pozdìji v této kapitole) jsme zvolili pøístup, kdy ha¹ujeme
celý daný rozsah a mìøíme výskyt kolizi, mìøí poèet úspì¹nì naha¹ovaných adres a¾ do výskytu
první kolize. Taková metrika je vskutku zajímavá, ale intuitivnì se naskýta úvaha, ¾e fitnes funkce
velmi ¹patnì ohodnotí øe¹ení, která mají kolizi velmi brzo, ale pøitom mohou naha¹ovat velkou èást
celého rozsahu. Fitnes funkce jasnì míøí na cíl naha¹ovat celý rozsah (tedy optimální øe¹ení), toho
nicménì nedosáhla. Bude zajímavé porovnat výsledky na¹í prace s s výsledky dosa¾enými v této
práci. Autoøi opìt pou¾ívají Merkle-Damg\r{a}rdovo schéma a práce se tudí¾ také nachází na 
pomezí evoluèního návrhu a evoluèní optimalizace.

\section{Návrh fitness funkce}

V na¹í práce navrhujeme specifickou
ha¹ovací funkci pro specifické univerzum hodnot. Proto mù¾eme pou¾ít jako kritérium
kvality odolnost vùèi kolizím, které je nepøímým ukazatelem toho, jak dobøe funkce
náhodnì distribuuje své výstupy. Evaluovanou ha¹ovací
funkci budeme testoat nad v¹emi prvky univerza. To znamená, ¾e budeme navrhovat
celkem ctyøi ha¹ovací funkce, pro ka¾dý vsupní dataset jednu. Kdybychom pro v¹echny ètyøi
datasety navrhovali jednu jedinou, nedostali bychom dobré výsledky. Výsledný ha¹ovací tabulka
by mìla 8192 slotù, ale byla by ``natrénována'' nad v¹emi adresami ze v¹ech datasetù. Navic 
bychom se museli zabývat vhodnou volbou trénovacích dat, co¾ je obtí¾ný úkol a navíc pøídat
kritérim, které by bralo v úvahu zobecòování. Výsledný ha¹ovací funkce by ji¾ nebyla obecná, ale
nìkde ``na pùl cesty'' mezi obecnou a velmi specifickou ha¹ovací funkci.

Neménì dùle¾itým kritériem je rychlost ha¹ovací funkce a to obzvlá¹tì v aplikacích jako jsou
sí»ové smìrovaèe nebo jiná uplatòìní nároèná na rychlost a odezvu. Jak uvidíme pozdìji v této
kapitole, ve¹keré námi navr¾ené funkce jsou implicitnì rychlé, proto¾e explicitnì omezíme hloubku
abstraktních syntaktických stromù a vhodnì zvolíme mno¾inu terminálù a neterminálù. 

\section{Zvolené parametry genetického programování}

V této sekci uvedeme, jaké parametry jsme zvolili parametry pro geneticé programování.

\subsection{Genetické operátory a selekce}

Operátory mutace pou¾ijeme ve dvou verzích. \textit{Podstromovou} mutaci a 
\textit{bodovou} mutaci zároveò. Budeme náhodnì volit mezi obìma alternativami, 
av¹ak pravdìpodobnost mutace ponecháme velmi nízkou. Pùvodní implementace algoritmù
genetického programování \cite{GPTutorial} operátor mutace vynechávaly úplnì. 
Budeme radìji volit cestu postupné pomaleji konvergující evoluce, ne¾ abychom 
nìjaká øe¹ení minuli.

Co se køí¾ení týka, v prvních verzích pou¾ijeme základní formu tedy \textit{podstromové}
køí¾ení, pozdìji jej mù¾eme porovnat i s pokroèilej¹ími technikami jako jsou 
\textit{jednobodové} a køí¾ení se zachováním kontextu. 

Selekci pou¾ijeme turnajovou a to zejména kvùli své determinitiènosti (jedince
sice musíme volit náhodnì, ale nemusíme se mezi nimi stochastiky rozhodovat). Dal¹ím dùvodem
je dobrá ¹kálovatelnost selekèního tlaku.

Poèáteèní populaci budeme generovat náhodnì bez pou¾ití jakýchkoli heuristik
a to metodou \textit{ramped-half-and-half}, která zaji¹»uje pro start algoritmu
kvalitní populaci co se rùznorodosti verlikostí a tvarù jedincù týká. 

\subsection{Mno¾ina terminálù a funkèních symbolù}

Mno¾inu vstupù zkonstruujeme z konstant a vstupních promìnných. Vstupní
promìnné vyrobíme z jednotlivých oktetù adres a budeme po¾adovat, aby ka¾dý
vstupní program obsahoval v¹echny promìnné alespoò jednou, tedy aby pracoval
s celou adresou. Jako konstanty budeme volit prvoèísla. 

Prvoèísla hrají dùle¾itou roli pøi operaci modulo. Pokud volíme jako argument modula nìjaké
násobky malých èísel jako je napøíklad èislo dvì, mù¾e se stát, ¾e funkce bude
mít tendenci seskupovat èísla dìlitelná dvìmi. Jako konstanty budeme volit
prvoèísla z rozsahu $\langle 2, 2N \rangle$, kde $N$ je velikost datasetu. Prvoèísla
budeme implementovat ve formì \textit{pomíjivé náhodné konstanty} (angl. \textit{ephemeral
random constant}, zkr. \textit{ERC}), kterou budeme znaèit $\Re$. Tento pøístup nám
zajistí vhodné chování konstany s ohledem na operátory køí¾ení a mutace a také pøi
evaluaci. Taková konstanta pokud je vygenerována bude pøi ka¾dém ohodnocení 
nabývat stejné hodnoty, ale v mutaci jej bude mìnit s urèitou pravdìpodobností na
nìjaké nejbli¾¹í prvoèíslo. 

Ka¾dá IP adresa má délku 32 bitù a skládá se ze ètyø osmibitových oktetù. Oktety zahrneme
do na¹í mno¾iny terminálních symbolù ka¾dý zvlá¹» a oznaèíme je $o_0 \ldots o_4$ jemnìj¹í 
dìlení (napøíklad 4, 2 nebo 1 bit) nebudeme uva¾ovat, proto¾e pou¾ijeme rotace (viz. dále),
které budou schopny vybrat jednotlivé bity z oktetu.

Budeme-li uva¾ovat Merkle-Damg\r{a}rdovo schéma, musíme reprezentovat v na¹í
mno¾inì terminálù mezivýsledky kompresní funkce. I kdy¾ se jedná obecnì o iterativní
schéma pracující nad libovolnou délkou vstupu, my si vzhledem k pøedem pevnì 
dané délce 32 bitù vystaèíme se ctyømi kompresními jednotkami, jejich¾ mezivýsledky
budeme znaèit $a_0, a_1, a_2$ (pozn.v pøípadì $a_3 $ se jedná o výstup). 

Mno¾inu funkcí zvolíme z bì¾ných operací. Vyhneme se cyklùm a jiným slo¾itým
øídícím konstrukcím, nebo» ty by vzhledem ke stochastické povaze algoritmu mohly
vyústit ve velmi pomalé ha¹ovací funkce. Dal¹í nevítanou skupinou operací jsou operace
v plovoucí øádové èárce, které na procesorech s komplexní instrukèní sadou vy¾adují
mnoho taktù procesoru aøí implementaci v hardware zase zabírají velké místo na èipu.
Nosnou èást mno¾iny funkcí budou tvoøit aritmetické operace. Konkrétnì do ní zahrneme
násobení ($*$), sèítání ($+$), odèítání ($-$) a operaci modulo ($mod$). V pøípadì dìlení
se spokojíme s dìlením beze zbytku ($/$). Pou¾ívat budeme také booleovské operace,
kam zahrneme logické souèet ($OR$), logický souèin ($AND$) a negaci ($NOT$), která 
je dùle¾itá zejmána proto, proto¾e umo¾òuje vytvoøit úplnou bázi a logické funkce mohou
tedy zkonstruovat libovolnou logickou funkci. Poslední skupinu budou tvoøit funkce bitové.
Zde zahrneme pravou ($\ggg$) a levou ($\lll$) rotaci. Které jsou dùle¾ité pro výbìr 
jednotlivých bitù ze vstupních argumentù. Výèet pou¾itých funkcí a terminálù
popisují tabulky \ref{tab:function_set_design} a \ref{tab:terminal_set_design}.

%%%%%%%%%%%%% FUNCTION AND TERMINAL SETS %%%%%%%%%%%%%%%
\begin{table}
\begin{center}
\begin{tabular}{ |l|c| }
	\hline
   	Kategorie & Zástupci \\
  	\hline
  	Aritmetické celoèíselné  & $\{ +,-,*,/,mo	d \}$ \\
  	Aritmetické                     & $\{\}$ \\
  	Booleovské				      & $\{AND, OR, NOT\}$ \\
  	Bitové					          & $\{ \lll, \ggg \}$ \\ 	 
  	\hline
\end{tabular}
\caption{Zvolená mno¾ina funkcí}
\label{tab:function_set_design}
\end{center}
\end{table}

\begin{table}
\begin{center}
\begin{tabular}{ |l|c| }
	\hline
   	Kategorie & Zástupci \\
  	\hline
  	Promìnné       & $\{o_0, o_1, o_2, o_3, a_0, a_1, a_2\}$ \\
  	Funkce arity 0 & $\{ \Re \}$ \\	 
  	\hline
\end{tabular}
\caption{Zvolená mno¾ina terminálù}
\label{tab:terminal_set_design}
\end{center}
\end{table}
%%%%%%%%%%%%% FUNCTION AND TERMINAL SETS %%%%%%%%%%%%%%%

\section{Evoluèní návrh ha¹ovacích funkcí}
V této sekci pøedstavíme princip metody a konkrétní podobu navr¾eného øe¹ení pro pøímý evoluèní 
návrh ha¹ovacích funkcí. Pøímý proto, proto¾e zde nebudeme uva¾ovat zádné schéma ani koncept
jeho¾ èásti bychom evolvovali. Ha¹ovací funkce zde budou reprezentovat pøímo abstraktní syntaktické
stromy, s kterými pracuje algoritmus genetického programování. Funkce navr¾ené touto metodou 
budeme oznaèovat \textit{IPHash}. Ka¾dý jedinec bude pracovat se v¹emi oktety IP adresy.
Merkle-Damg\r{a}rdovo schéma zde nepou¾íváme, tak¾e do mno¾iny terminálù není tøeba zahrnovat
¾ádné symboly reprezentující mezivýsledky. Dále do mno¾iny zahrneme konstantu  $\Re$. Operátor
køá¾ení zvolíme v podstromové variantì a operátor mutace takté¾. Hloubku jednotlivých jedincù omezíme
na hodnotu ¹est a to ze dvou dùvodu. Jednak proto¾e oèekáváme od na¹ich ha¹ovacích funkcí aby byly
rychlé a také proto, ¾e algoritmus genetického programování je pamì»ovì nároèný a s rostoucí hloubkou
stromù roste exponenciálnì pamì»ová nároènost, co¾ klade neúnosné nároky na výpoèetní zaøízení 
(servery \textit{edesign1} \ldots \textit{edesign4}). Parametry základní variantu této metody shrnuje 
tabulka \ref{tab:IPHash_params}.

\begin{table}[h]
	\centering
	\caption{Kompletní shrnutí parametrù genetického programování pro experimenty spjaté s touto sekcí.}
	\begin{tabular}{lc} \\ \hline
		Parametr & Hodnota \\ \hline
		Poèet populací v bìhu & 1 \\
		Velikost populace & 512 \\
		Reprezentace jedince & jeden abstraktní syntaktický strom \\ \hline
		Maximální poèet ohodnocení & 100000 \\
		Maximální hloubka & 6 \\
		Mno¾ina funkcí & $\{*, +, \wedge, \ggg\}$ \\
		Mno¾ina symbolù & $\{o_{0} .. o_{3}, \Re \}$ \\
		\hline 
		Inicializaèní metoda & Ramped half-and-half \\
		Poèáteèní maximální hloubka & 6 \\
		Poèáteèní maximální hloubka & 2 \\
		\hline
		Selekce & Turnajová \\
		Velikost turnaje & 7 \\
		\hline
		Køí¾ení & Podstromové \\
		Èetnost selekce koøene & 0.0 \\
		Èetnost selekce listu & 0.1 \\ 
		Èetnost selekce uzlù & 0.9 \\
		\hline 
		Mutace & Podstromová \\
		Èetnost & 0.1 \\
		\hline
		Elitismus & Ano \\
		Èetnost & 0.05 \\
		\hline
	\end{tabular}
	\label{tab:IPHash_params}
\end{table}

\section{Optimalizace za pou¾ití Merkle-Damg\r{a}rdova schématu}

Dále se budeme zabývat evoluèním návrhem kompresních funkcí pro Merkle-Damg\r{a}rdovo schéma.
Budeme zkoumat dva rùzné pøístupy. V prvním pøípadì budeme evolvovat jednu jedinou kompresní 
pøi konstrukci Merkle-Damg\r{a}rdova schématu tak jak bylo popsáno v kapitole \ref{sec:hashing}.
V druhém pøipadì budeme namísto jedné kompresní funkce evolvovat hned ctyøi, pro ka¾dý oktet
ha¹ovací funkce jednu jak je ukázáno na obrázku \ref{fig:merkle_damgard_2}. Tento pøístup nám
umo¾ní dekomponovat prohledávací prostor a dosáhnout tak lep¹ích výsledkù díky navr¾ení
kompresních funkcí na míru konkrétnímu oktetu IP adresy. Merkle-Damg\r{a}rdovo schéma je obecnì
iterativní schéma pøijímat vstup o libovolné velikosti. My vyu¾ijeme v obou pøípadech faktu, ¾e délku
vstupu pøedem známe. Omezíme se tedy pouze na ctyøi kompresní funkce, pro ka¾dý oktet vstupu jednu.
A proto¾e je velikost vstupu násobek osmi, nemusíme poslední oktet doplòovat o ohranièující vatu. Dále
náme nezále¾í na kryptografické bezpeènosti, mù¾eme tedy vzpostit poslední kompresní komponentu
pro délkové ohranièení. Ani dobrovolnou finalizaèní komponentu nevyu¾ijeme. Výsledná ha¹ovací funkce
bude tvaru
$$f_{Merkle-Damgard} : IV \times X \to \{0,1,2 \ldots 8192\}$$,
kde $IV$ je nìjaké celé èíslo a $X$ je vstupní IP adresa.

Druhý bude vy¾adovat zásadní zmìnu v reprezentaci jedincù. Ka¾dý jedinec se bude skládat ze ctyø 
rùzných abstraktních syntaktickách stromù reprezentující jednotlivé kompresní funkce. Genetické operátory
mutace a zejména køí¾ení pracují v ka¾dém procesu reprodukce pouze nad jedním abstraktním
syntaktickým stromem. Proto¾e naráz pracujeme se ètyømi stromy zvedme poèet evaluací ctyønásobnì na
400 000 evaluací, abychom dosáhli ekvivalentní situace v porovnání s ostatními metodami. V procesu
reprodukce jsou abstraktní syntaktické stromy vybírány náhodnì. 

\begin{figure}[!ht]
\begin{subfigure}[b]{0.49\textwidth}
%	\includegraphics[width=\textwidth]{fig/merkle_damgard_design1}
	\caption{První pøípad, který budeme studovat. Schéma pou¾ívá zøetìzení jediné kompresní funkce.}
\end{subfigure}
\begin{subfigure}[b]{0.49\textwidth}
%	\includegraphics[width=\textwidth]{fig/merkle_damgard_design2}
	\caption{Druhý pøípad, který budeme studovat. Schéma pou¾ívá zøetìzení nìkolika rùzných kompresních funkcí.}
\end{subfigure}
	\caption{Porovnání dvou navr¾ených øe¹ení pou¾ívající Merkle-Damg\r{a}rdovo schéma.}
\end{figure}

U obou variant do tabulky terminálních symbolù musíme zavést pøíslu¹né symboly reprezentující
konkrétní mezivýsledky $a_0, a_1, a_2$. Ostatní parametry se oproti metodì v pøedchozí sekci neli¹í.

\section{Evoluèní návrh za pou¾ití kukaèèího ha¹ování}

\chapter{Experimenty}

%%%%%%%%%%%%% EXPERIMENTS WITH VARIOUS FUNCTIONS %%%%%%%%%%%%%%%
V této kapitole provedeme experimenty v nich¾ nejprve ovìøíme, zda navr¾ené øe¹ení poskytuje dobré
výsledky. Poté provedeme dal¹í sérii experimentù, v ních¾ budeme postupnì mìnit parametry navr¾eného
øe¹ení a vyhodnotíme výsledky. Mìnit budeme jak samotné parametry algoritmu genetického
programování, tak i mno¾iny terminálních a neterminálních symbolù. Budeme provádìt v¾dy pouze
jednu zmìnu v ka¾dém experimentu, abychom zachovali jejich vìrohodnost a správnou korespondenci
mezi zmìnou parametru a dùsledkem, jaký má na výsledné øe¹ení.

V následující sekci budeme experimentovat s evolvovanými ha¹ovacími funkcemi, do kterých zahrneme
Merkle-Damg\r{a}rdovo schéma popsané v kapitole \ref{sec:hashing}. Krátce popí¹eme zmìny v na¹em
evoluèním algoritmu a provedeme pøíslu¹né experimenty.

V poslední sekci této kapitoly uvedeme do námi navr¾eného øe¹ení Kukaèèí schéma jak bylo popsané
v kapitole \ref{sec:hashing}. Opìt shrneme zmìny v genetickém algoritmu, provedeme a vyhodnotíme
pøíslu¹né experimenty.

Ve v¹ech experimentech budeme mìrit míru odolnosti proti kolizím, konkrétnì tedy kolik je daná ha¹ovací 
funkce schopna naha¹ovat rùzných IP adres. Dal¹í, neménì dùle¾itou roli hraje u ha¹ovacích funkcí jejich
rychlost. Provedeme tedy i experimenty, které odhalí rychlost s jakou jednotlivé ha¹ovací funkce provádí svou
èinnost. 

\section{Experimenty s navr¾eným øe¹ením}
Nejprve se tedy budeme zkoumat výsledky, jaké poskytuje námi navr¾ené øe¹ení z kapitoly
 \ref{sec:solution_design}. Námi navr¾ený algoritmus porovnáme se dvìma variantami náhodného prohledávání.
 První varianta bude náhodné prohledávání bez pou¾ití elitismu, druhá s elitismem. Do grafu zahrneme i jednu
 variantu èlovekem vytvoøené obecné ha¹ovací funkce, konkrétnì ha¹ovací funkci \textit{Murmurhash3} pøedstavenou
 v sekci \ref{sec:evolution_design}. Bìhy námí navr¾eného øe¹ení jsme promítli do grafù, kde ka¾dému
 datasetu odpovída jeden graf. Na levé stranì grafu mù¾eme vidìt prùbìhy námi navr¾eného systémù a oba
 algoritmy náhodného prohledávání. Ka¾dá køivka je výsledkem mediánu z padesátí nezávislých bìhù. Na levé
 stranì mù¾eme pozotovat medián systémù IPHash a u nìj je¹tì interval spolehlivosti. Interval spolehlivosti
 je zaznaèen dvìma ohranièujícímy køivkami, kde spodní zaèní první a horní tøetí kvartil.

%%%%%%%%%%%%% IPHASH AVG Population SET #1 %%%%%%%%%%%%%%%
\begin{figure*}[!ht]
	\centering
	\begin{tikzpicture}
	\begin{axis}[ %
	, name=plot1
	, height=8cm
	, width=0.50\textwidth
	, grid=major
	, xlabel=Generation
	, ymin=5180
	, ymax=5320
	, ylabel=Successfully hashed
	, legend style=
	{ at={(1.0, 0.3)}
		, anchor=east
	}
	]
	\addplot[color=black, dashdotted, thick, mark=none] table {graph/IPHash/Set1/ElitistRandomRun_1.dat};
	\addlegendentry{Elitist Random Search}
	
	\addplot[color=blue, dotted, very thick, mark=none] table {graph/IPHash/Set1/RandomRun_1.dat};
	\addlegendentry{Random Search}
	
	\addplot[color=green, solid, thick, mark=none] coordinates {(0,5190) (194, 5190)};
	\addlegendentry{MurmurHash3}
	
	\addplot[color=red, mark=none, dashed, thick] table {graph/IPHash/Set1/IPHashMedian_1.dat}; 
	\addlegendentry{Proposed IPHash}
	
	\end{axis}
	
	\begin{axis}[ %
	, name=plot2
	, at=(plot1.right of south east)
	, anchor=left of south west
	, ymin=5180
	, ymax=5320
	, height=8cm
	, width=0.50\textwidth
	, grid=major
	, xlabel=Generation
	%%	, ylabel=Successfully hashed
	, yticklabels={,,}
	%%	, legend pos=outer north east
	, legend style=
	{ at={(1.0, 0.3)}
		, anchor=east
	}
	]
	\addplot[color=red, mark=none, dashed,thick] table {graph/IPHash/Set1/IPHashMedian_1.dat}; 
	\addlegendentry{Proposed IPHash}
	\addplot[color=red, mark=none, dotted] table {graph/IPHash/Set1/IPHashReliab1_1.dat}; 
	%\addlegendentry{Proposed IPHash RR1}
	\addplot[color=red, mark=none, dotted] table {graph/IPHash/Set1/IPHashReliab3_1.dat}; 
	\addlegendentry{Diversity of runs}
	\end{axis}
	\end{tikzpicture}
	\caption{Evolvované ha¹ovací funkce a jejich fitnes hodnota nad data setem èíslo 1.}
	\label{fig:basicComparison1}
\end{figure*}
%%%%%%%%%%%%% IPHASH AVG Population SET #1 %%%%%%%%%%%%%%%

Na obrázku \ref{fig:basicComparison1} mù¾eme vidìt vidìt porovnání bìhù a jejich výsledkù v¹ech algoritmù.
Je patrné, ¾e nad prvním datasetem, navr¾ené øe¹ení jasnì dominuje nad zbývajícímy algoritmy. IPHash
naha¹oval o 25 IP adres více ne¾ druhý nejùspì¹nìj¹í algoritmus náhodného prohledávání. Nejhùøe si vedl
èlovìkem vytvoøený algoritmus \textit{MurmurHash3}, který naha¹oval o celých 111 IP adres ménì. 

Z intervalu spolehlivost mù¾eme usoudit, ¾e námi navr¾ený algoritmus skuteènì funguje dobøe a rozptyly jeho
øe¹ení nejsou pøíli¹ signifikantní. Nalezené øe¹ení není tedy dílem èísté náhody. Z grafu mù¾eme vyèíst, ¾e 
algoritmus v prních nìkolika generacích rapidnì konverguje a s postupným pøíbýváním generací se jeho 
konvergence zpomaluje. Toto je typickou vlastností algoritmu genetického programování \cite{GPTutorial}.

%%%%%%%%%%%%% IPHASH AVG Population SET #2 %%%%%%%%%%%%%%%
\begin{figure*}[!ht]
	\centering
	\begin{tikzpicture}
	\begin{axis}[ %
	, name=plot1
	, height=8cm
	, width=0.50\textwidth
	, grid=major
	, xlabel=Generation
	, ymin=5180
	, ymax=5330
	, ylabel=Successfully hashed
	, legend style=
	{ at={(1.0, 0.3)}
		, anchor=east
	}
	]
	\addplot[color=black, dashdotted, thick, mark=none] table {graph/IPHash/Set2/ElitistRandomRun_2.dat};
	\addlegendentry{Elitist Random Search}
	
	\addplot[color=blue, dotted, very thick, mark=none] table {graph/IPHash/Set2/RandomRun_2.dat};
	\addlegendentry{Random Search}
	
	\addplot[color=green, solid, thick, mark=none] coordinates {(0,5190) (194, 5190)};
	\addlegendentry{MurmurHash3}
	
	\addplot[color=red, mark=none, dashed, thick] table {graph/IPHash/Set2/IPHashMedian_2.dat}; 
	\addlegendentry{Proposed IPHash}
	
	\end{axis}
	
	\begin{axis}[ %
	, name=plot2
	, at=(plot1.right of south east)
	, anchor=left of south west
	, ymin=5180
	, ymax=5330
	, height=8cm
	, width=0.50\textwidth
	, grid=major
	, xlabel=Generation
	%%	, ylabel=Successfully hashed
	, yticklabels={,,}
	%%	, legend pos=outer north east
	, legend style=
	{ at={(1.0, 0.3)}
		, anchor=east
	}
	]
	\addplot[color=red, mark=none, dashed,thick] table {graph/IPHash/Set2/IPHashMedian_2.dat}; 
	\addlegendentry{Proposed IPHash}
	\addplot[color=red, mark=none, dotted] table {graph/IPHash/Set2/IPHash1stQ_2.dat}; 
	%\addlegendentry{Proposed IPHash RR1}
	\addplot[color=red, mark=none, dotted] table {graph/IPHash/Set2/IPHash3rdQ_2.dat}; 
	\addlegendentry{Diversity of runs}
	\end{axis}
	\end{tikzpicture}
	\caption{Evolvované ha¹ovací funkce a jejich fitnes hodnota nad data setem èíslo 2.}
	\label{fig:basicComparison2}
\end{figure*}
%%%%%%%%%%%%% IPHASH AVG Population SET #2 %%%%%%%%%%%%%%%

V pøípadì druhého datasetu jsou dosa¾ené výsledky (\ref{fig:basicComparison2}) je¹tì lep¹í. IPHash dosáhl vy¹¹ího mediánu
a opìt výraznì pøevý¹il jak náhodné prohledávání, tak \textit{MurmurHash3}. Naha¹oval o 24
IP adres více ne¾ náhodné prohledávání a o 115 IP adres více, ne¾ \textit{MurmurHash3}. 
Interval spolehlivosti je s výjimkou posledních nìkolika generací více sevøený kolem køivky
IPHash, co¾ znaèí spolehlivý algoritmus. Stejnì jako v pøedchozím pøípadì, algoritmus rapidnì
konverguje v prvních nìkolika generacích. Poté jeho nástup ustává.

%%%%%%%%%%%%% IPHASH AVG Population SET #3 %%%%%%%%%%%%%%%
\begin{figure*}[!ht]
	\centering
	\begin{tikzpicture}
	\begin{axis}[ %
	, name=plot1
	, height=8cm
	, width=0.50\textwidth
	, grid=major
	, xlabel=Generation
	, ymin=5180
	, ymax=5320
	, ylabel=Successfully hashed
	, legend style=
	{ at={(1.0, 0.3)}
		, anchor=east
	}
	]
	\addplot[color=black, dashdotted, thick, mark=none] table {graph/IPHash/Set3/ElitistRandomRun_3.dat};
	\addlegendentry{Elitist Random Search}
	
	\addplot[color=blue, dotted, very thick, mark=none] table {graph/IPHash/Set3/RandomRun_3.dat};
	\addlegendentry{Random Search}
	
	\addplot[color=green, solid, thick, mark=none] coordinates {(0,5206) (194, 5206)};
	\addlegendentry{MurmurHash3}
	
	\addplot[color=red, mark=none, dashed, thick] table {graph/IPHash/Set3/IPHashMedian_3.dat}; 
	\addlegendentry{Proposed IPHash}
	
	\end{axis}
	
	\begin{axis}[ %
	, name=plot2
	, at=(plot1.right of south east)
	, anchor=left of south west
	, ymin=5180
	, ymax=5320
	, height=8cm
	, width=0.50\textwidth
	, grid=major
	, xlabel=Generation
	%%	, ylabel=Successfully hashed
	, yticklabels={,,}
	%%	, legend pos=outer north east
	, legend style=
	{ at={(1.0, 0.3)}
		, anchor=east
	}
	]
	\addplot[color=red, mark=none, dashed,thick] table {graph/IPHash/Set3/IPHashMedian_3.dat}; 
	\addlegendentry{Proposed IPHash}
	\addplot[color=red, mark=none, dotted] table {graph/IPHash/Set3/IPHash1stQ_3.dat}; 
	%\addlegendentry{Proposed IPHash RR1}
	\addplot[color=red, mark=none, dotted] table {graph/IPHash/Set3/IPHash3rdQ_3.dat}; 
	\addlegendentry{Diversity of runs}
	\end{axis}
	\end{tikzpicture}
	\caption{Evolvované ha¹ovací funkce a jejich fitnes hodnota nad data setem èíslo 3.}
	\label{fig:basicComparison3}
\end{figure*}
%%%%%%%%%%%%% IPHASH AVG Population SET #3 %%%%%%%%%%%%%%%

Zajímavá situace nastala v pøípadì tøetího datasetu \ref{fig:basicComparison3}. Na první pohled je patrné,
¾e oba iteraèní algoritmy zde øe¹ení s obdobnou hodnotou fitnes. Dále je vidìt,
¾e mediánová hodnota fitnes se nám znatelnì a to o více ne¾ dvacet naha¹ovaných 
adres v pøípadì algoritmu IPHash. Výsledná øe¹ení náhodného prohledávání na¹la
øe¹ení s obdobnou hodnotou fitnes jako v pøedchozím pøípadì. Naopak se zvý¹ila 
hodnota u algoritmu \textit{MurmurHash3}, a to o celýh 15 naha¹ovaných adres.

Z intervalu spolehlivosti mù¾eme vyèíst, mnohem vìt¹í rozptyl ne¾ v pøedchozích
pøípadech. IPHash algoritmus produkuje mnohem vìt¹í diverzitu v nalezených øe¹eních.
Tento fakt ve spojení s obdobnou hodnotou fitnes funkce jako má náhodné prohledávání
znaèí, ¾e stavový prostor tak jak modelován tøetím datasetem je vhodný spí¹e pro 
algoritmus náhodného prohledávání, ne¾ pro evoluèní algoritmus. Evoluèní algoritmus
se v prostoru dostupných øe¹ení ``nemá èeho chytit''. Proto ¹patnì konverguje a jeho
prùbìh pøipomíná náhodné prohledávání. Na poèátku algoritmus konverguje velmi rychle
velmi rychle v¹ak ztrácí ve¹kerý progres a témìø úplnì staguje.

%%%%%%%%%%%%% IPHASH AVG Population SET #4 %%%%%%%%%%%%%%%
\begin{figure*}[!ht]
	\centering
	\begin{tikzpicture}
	\begin{axis}[ %
	, name=plot1
	, height=8cm
	, width=0.50\textwidth
	, grid=major
	, xlabel=Generation
	, ymin=5180
	, ymax=5320
	, ylabel=Successfully hashed
	, legend style=
	{ at={(1.0, 0.3)}
		, anchor=east
	}
	]
	\addplot[color=black, dashdotted, thick, mark=none] table {graph/IPHash/Set4/ElitistRandomSearch_4.dat};
	\addlegendentry{Elitist Random Search}
	
	\addplot[color=blue, dotted, very thick, mark=none] table {graph/IPHash/Set4/RandomSearch_4.dat};
	\addlegendentry{Random Search}
	
	\addplot[color=green, solid, thick, mark=none] coordinates {(0,5206) (194, 5206)};
	\addlegendentry{MurmurHash3}
	
	\addplot[color=red, mark=none, dashed, thick] table {graph/IPHash/Set4/IPHashMedian_4.dat}; 
	\addlegendentry{Proposed IPHash}
	
	\end{axis}
	
	\begin{axis}[ %
	, name=plot2
	, at=(plot1.right of south east)
	, anchor=left of south west
	, ymin=5180
	, ymax=5320
	, height=8cm
	, width=0.50\textwidth
	, grid=major
	, xlabel=Generation
	%%	, ylabel=Successfully hashed
	, yticklabels={,,}
	%%	, legend pos=outer north east
	, legend style=
	{ at={(1.0, 0.3)}
		, anchor=east
	}
	]
	\addplot[color=red, mark=none, dashed,thick] table {graph/IPHash/Set4/IPHashMedian_4.dat}; 
	\addlegendentry{Proposed IPHash}
	\addplot[color=red, mark=none, dotted] table {graph/IPHash/Set4/IPHash1stQ_4.dat}; 
	%\addlegendentry{Proposed IPHash RR1}
	\addplot[color=red, mark=none, dotted] table {graph/IPHash/Set4/IPHash3rdQ_4.dat}; 
	\addlegendentry{Diversity of runs}
	\end{axis}
	\end{tikzpicture}
	\caption{Evolvované ha¹ovací funkce a jejich fitnes hodnota nad data setem èíslo 4.}
	\label{fig:basicComparison4}
\end{figure*}
%%%%%%%%%%%%% IPHASH AVG Population SET #4 %%%%%%%%%%%%%%%

Zdá se, ¾e stejnì jako v pøedchozím pøípadì, se IPHash chová i nad posledním datasetem ètyøi (\ref{fig:basicComparison4}).
Mediánová hodnota je opìt ni¾¹í ne¾ v pøípadì náhodného prohledávání. Je v¹ak vy¹¹í, ne¾ v pøípadì
\textit{MurmurHash3}. Stavový prostor, zda se, má opìt náhodnou charakteristiku a algoritmus spatnì
koverguje. Rozptyl je opìt vìt¹í ne¾ v prvních dvou pøípadech. Algoritmus rychle konverguje v prvních
nìkolika generacích. Brzy v¹ak pøejde ve stagnaci.

Døíve, ne¾ se pustíme dále je vhodné se zamyslet na doposud dosa¾enými výsledky algoritmem náhodného
prohledávání. Teoreticky algoritmus náhodného prohledávání je takový, který náhodnì vybírá body
daného stavového prostoru. Souèástí ka¾dého evoluèního algoritmu je v¹ak také reprezentace problému,
která modeluje stavový prostor. V na¹em pøípadì bylo náhodné proheldávání velmi silnì ovlivnìno 
reprezentací jedncù jako abstraktních syntaktických stromù a pou¾itými terminálními a funkèními symboly.
Lze tedy stále mluvit o algoritmu náhodného prohledávání, mìjme v¹ak na pamìti, ¾e výsledky jím
dosa¾enou jsou velkou mìrou zpùsobené právì námi vhodnì zvolenou reprezentací.

Jedna ze zajímavých vlastostí spoleènou pro v¹echny grafy je fakt, ¾e v iniciálních populacích obou
iteraèních algoritmù jsme nalezli øe¹ení, která pøevy¹ovala èlovìkem vytvoøené ha¹ovací funkce. Toto
je velmi zajímavý poznatek. Dùvodem je, ¾e velikost populace jsme zvolili pomìrnì velkou. I pøes to
v¹ak z toho plyne, ¾e po nìkolika málo pokusech s náhodným generováním abstraktních syntaktických 
stromù mù¾eme nalézt øe¹ení, která pøevy¹ují ta èlovìkem vytvoøená.

\begin{table}[!ht]
	\centering
	\begin{tabular}{l|c|c|c|c}
		Ha¹ovací funkce & Dataset 1 & Dataset 2 & Dataset 3 & Dataset 4 \\
		\hline
		FarmHash             & 5227 & 5199 & 5203 & 5158 \\
		MurmurHash3    		 & 5190 & 5190 & 5206 & 5206 \\
		CityHash             & 5180 & 5156 & 5171 & 5155 \\
		\hline
		IPHash               & 5301 & 5305 & 5274 & 5278 \\
		Náhodné prohledávání & 5276 & 5281 & 5277 & 5281 \\
		\hline
	\end{tabular}
	\caption{Shrnutí výsledkù evolvovaných i obecných ha¹ovacích funkcí napøíè v¹emi datasety.}
	\label{tab:IPHash_conclusion}
\end{table}

Ve shrnující tabulkce \ref{tab:IPHash_conclusion} mùzeme vidìt výsledky algoritmu náhodného prohledávání
a algoritmu IPHash v kontrastu s èlovìkem vytvoøenými ha¹ovacími funkcemi z kapitoly \ref{sec:hashing}.
Nad prvními dvìma má nejlep¹í mediánovou hodnotu fitnes IPHash. Nad druhými dvìma naopak náhodné prohledávání.
Èlovìkem vytvoøené algoritmy ani v jednom pøípadì napøekonaly IPHash. Naopak IPHash nad obecnými ha¹ovacími
funkcemi jasnì dominuje. Rozdíl je nejvíce znát v v pøípadì funkce \textit{CityHash} nad datasetem dva, kde se rozdíl
rovná hodnotì 150 naha¹ovaných funkcí. Nejménì je to naopak v pøípadì funkce \textit{FarmHash} nad datasetem tøi,
kde se rozdíl zmen¹il na 71 naha¹ovaných adres.
 
Nyní se budeme podrobnìji zabývat rozptylem nejlep¹ího nalezeného øe¹ení (ekvivalent
hodnoty poslední generace algoritmu), které  nalezne náhodné prohledávání a IPHash v porovnání s
algoritmem náhodného prohledávání.

%%%%%%%%%%%%% IPHASH BOXPLOT %%%%%%%%%%%%%%%
\begin{figure}[!h]
	\centering
	\begin{tikzpicture}
	\begin{axis}
	[ boxplot/draw direction=y
	, name=plot1
	, xtick={1,2,3}
	, xticklabels={RS, IPHash, Náhodné prohledávání}
	, ymin=5200
	, ymax=5360
	]
	\addplot+[
	boxplot prepared={
		lower whisker=5250,
		lower quartile=5266,
		median=5276,
		upper quartile=5286,
		upper whisker=5311,
	},
	] coordinates {}; % RS
	
	\addplot+[
	boxplot prepared={
		lower whisker=5279,
		lower quartile=5292,
		median=5301,
		upper quartile=5315,
		upper whisker=5352,
	},
	] coordinates {}; % IPHash
	
	\addplot+[
	boxplot prepared={
		lower whisker=5242,
		lower quartile=5265,
		median=5274,
		upper quartile=5286,
		upper whisker=5319,
	},
	] coordinates {}; % ERS
	\end{axis}		

	\begin{axis}
	[ boxplot/draw direction=y
	, name=plot2
	, at=(plot1.right of south east)
	, xtick={1,2,3}
	, xticklabels={RS, IPHash, Náhodné prohledávání}
	, ymin=5200
	, ymax=5360
	, yticklabels={,,}
	]		
	\addplot+[color=blue,
		boxplot prepared={
		lower whisker=5255,
		lower quartile=5270,
		median=5281,
		upper quartile=5290,
		upper whisker=5331,
	},
	] coordinates {}; % RS
	
	\addplot+[color=red,
		boxplot prepared={
			lower whisker=5286,
			lower quartile=5298,
			median=5305,
			upper quartile=5319,
			upper whisker=5352,
		},
		] coordinates {}; % IPHash
		
	\addplot+[
	boxplot prepared={
		lower whisker=5251,
		lower quartile=5270,
		median=5279,
		upper quartile=5285,
		upper whisker=5328,
	},
	] coordinates {}; % ERS
	\end{axis}		
	\end{tikzpicture}
	\caption{Porovnání výsledkù algirutmu IPHash a náhodného porovnání krabicovým diagramem pro datasety jedna a dvì.}
	\label{fig:basic_boxplot_1}
\end{figure}

Na dvou krabicových diagramech grafech na obrázku \ref{fig:basic_boxplot_1}, vidíme porovnání
algoritmù v nad datasety jedna dvì. Nad tìmito datasety si algoritmus vedl velmi dobøe, a to potvrzují
i krabicové diagramy. V celém rozsahu rozptylu námi navr¾eného øe¹ení dostáváme lep¹í výsledky, ne¾ u
algoritmu náhodného prohledávání a to v obou pøípadech. Nejlep¹í øe¹ení nalezené algoritmem náhodného
prohledávání je jen nepatrnì vý¹e, ne¾ horní hranice rozptylu algoritmu IPHash. Nejhor¹í øe¹ení nalezené
algoritmem IPHash je v pøípadì prvního datasetu lep¹í ne¾ medián algoritmu náhodného prohledávání a
v pøípadì druhého datasetu dokonce lep¹í, ne¾ nejlep¹í øe¹ení rozptylu náhodného prohledávání. Co se týèe
nejlep¹ího øe¹ení algoritmu IPHash, tak to znaènì pøevu¹uje i to nejlep¹í øe¹ení nalezené algoritmem
náhodného prohledávání. Je tedy patrné, ¾e ve v¹ech pøípadech algoritmus IPHash dobøe konvergoval v daném
stavovém prostoru popsaném fitnes funkcí a zvolenou reprezentací jedincù.

\begin{figure}[!h]
\centering
\begin{tikzpicture}
	\begin{axis}
	[ boxplot/draw direction=y
	, name=plot3	
	, xtick={1,2,3}
	, xticklabels={RS, IPHash, Náhodné prohledávání}
	, ymin=5200
	, ymax=5360
	]		
	\addplot+[
	boxplot prepared={
		lower whisker=5246,
		lower quartile=5268,
		median=5277,
		upper quartile=5290,
		upper whisker=5302,
	},
	] coordinates {}; % RS
	
	\addplot+[
	boxplot prepared={
		lower whisker=5242,
		lower quartile=5261,
		median=5274,
		upper quartile=5287,
		upper whisker=5342,
	},
	] coordinates {}; % IPHash
	
	\addplot+[
	boxplot prepared={
		lower whisker=5237,
		lower quartile=5263,
		median=5275,
		upper quartile=5289,
		upper whisker=5318,
	},
	] coordinates {}; % ERS
	\end{axis}		

	\begin{axis}
	[ boxplot/draw direction=y
	, name=plot4
	, at=(plot3.right of south east)
	, xtick={1,2,3}
	, xticklabels={RS, IPHash, Náhodné prohledávání}
	, yticklabels={,,}
	, ymin=5200
	, ymax=5360
	]		
	\addplot+[
	boxplot prepared={
		lower whisker=5251,
		lower quartile=5269,
		median=5281,
		upper quartile=5285,
		upper whisker=5310,
	},
	] coordinates {}; % RS
	
	\addplot+[
	boxplot prepared={
		lower whisker=5252,
		lower quartile=5264,
		median=5278,
		upper quartile=5285,
		upper whisker=5298,
	},
	] coordinates {}; % IPHash
	
	\addplot+[
	boxplot prepared={
		lower whisker=5251,
		lower quartile=5268,
		median=5276,
		upper quartile=5290,
		upper whisker=5323,
	},
	] coordinates {}; % ERS
	\end{axis}		

	\end{tikzpicture}
	\caption{Porovnání výsledkù algirutmu IPHash a náhodného porovnání krabicovým diagramem pro datasety tøi a ètyøi.}
	\label{fig:basic_boxplot_2}
\end{figure}
%%%%%%%%%%%%% IPHASH BOXPLOT %%%%%%%%%%%%%%%

V kontrastu s výsledky nad prvními dvìma datasety jsou výsledky nad druhými dvìma datasety. V obou pøípadech
si námi navr¾ené øe¹ení nevedlo v prùmìru lépe, ne¾ algorimus náhodného prohledávání. Je vidìt, ¾e nejlep¹í
nalezená øe¹ení mají obdobný rozptyl. Nad datasetem èíslo tøi je rozptyl velmi podobný, tìsnì ve prospìch 
náhodného prohledávání. Medián lze pova¾ovat za toto¾ný. Nejlep¹í nalezené øe¹ení v¹ak jasnì mluví ve prospìch
algoritmu IPHash, kde je rozdíl více ne¾ dvacet úspì¹nì naha¹ovaných adres. V pøípadì datasetu èíslo ctyøi náhodné
prohledávání jasnì pøedèilo námi navr¾ený algoritmus. I pøes to, ¾e je mediánová hodnota náhodného prohledávání
nepatrnì men¹í, je zanedbatelná a lze ji pova¾ovat za nepøesnost mìøení. Horní i spodní hranice rozptylu náhodného
prohledávání je polo¾ena vý¹e ne¾ v pøípadì algoritmu IPHash. Celkem lze pozorovat, ¾e ani jeden algoritmus 
nena¹el øe¹ení, které by mohlo konkurovat nejlep¹ím výslekùm dosa¾eným v nad pøede¹lými datasety. I pøes to
nejlep¹í nalezené øe¹ení jednoznaènì mluví ve prospìch algoritmu náhodného prohledávání.

Nejlep¹ích výsledkù bylo dosa¾eno nad prvními dvìma datasety, kde v obou pøípadech si nejlépe vedl námi navr¾ený
algoritmus. U tøetího datasetu se výsledky zhor¹ili v porovnání s pøedchozími a to u obou algoritmù. Oba si byly 
rovnocéné, ale nejlep¹í øe¹ení nalezl algoritmus IPHash. V pøípadì posledního datasetu jsou výsledky podobné jako
v pøípadì datasetu tøi. Nejlep¹í øe¹ení nalezlo náhodné prohledávání, ale i zde mù¾eme pozorovat zhoø¹ení. 

%%%%%%%%%%%%% IPHASH Population depth %%%%%%%%%%%%%%%
\begin{figure}[!ht]
\centering
\begin{tikzpicture}
	\begin{axis}[ 
	, grid=major
	, width=0.49\linewidth
	, legend pos=outer north east
	, xlabel={Population size}
	, xtick={1,2,3,4,5,6,7,8}
	, xticklabels={8,16,32,64,128,256,512}
	, ylabel={Initial depth}
	, ytick={2,3,4,5,6} 
	, zlabel={Successfully hashed}
	, ztick={5280,5290,5300,5310,5320}
	, zticklabels={5280,5290,5300,5310,5320}
	]
	\addplot3[surf] coordinates {
		    %8            16         32           64           128          256          512          1024  
		    (1,2,5288.5) (2,2,5289) (3,2,5291)   (4,2,5294)	  (5,2,5297)   (6,2,5295)   (7,2,5293.5) (8,2,5296.5)
		    
		    (1,3,5292.9) (2,3,5301) (3,3,5300.5) (4,3,5314)   (5,3,5312.5) (6,3,5310.5) (7,3,5306)   (8,3,5307)
		    
		    (1,4,5299.5) (2,4,5306) (3,4,5305)   (4,4,5308.5) (5,4,5311.5) (6,4,5312)   (7,4,5306.5) (8,4,5309.5)
		    
		    (1,5,5299)   (2,5,5300) (3,5,5307)   (4,5,5313.5) (5,5,5302.5) (6,5,5311)   (7,5,5312)   (8,5,5307)
		    
		    (1,6,5293.5) (2,6,5302) (3,6,5304)   (4,6,5295.5) (5,6,5307)   (6,6,5304)   (7,6,5302)   (8,6,5307) 
		};
	\end{axis}
\end{tikzpicture}
\caption{Number of successfully hashed addresses in relation to population size and initial depth.}
\label{fig:basicPopulationDepth1}
\end{figure}
%%%%%%%%%%%%% IPHASH Population depth %%%%%%%%%%%%%%%

\begin{table}[h]
	\centering
	\caption{Vliv rùzných voleb and terminálních a neterminálních mno¾in na výslednou hodnotu fitnes. Experimenty jsou provedeny
		napøíè v¹emi datasety.}
	\begin{tabular}{cccccc} \\ \hline
		Terminal set & Function set & Dataset 1 & Dataset 2 & Dataset 3 & Dataset 4 \\ \hline
		$\{o_{0} .. o_{3}, \Re \}$ & $\{*, +, \wedge, \ggg\}$ & 5307 & 5305 & 5274 & 5278 \\
		$\{o_{0} .. o_{3}\}$ & $\{*, +, \wedge, \ggg\}$ & 5291 & 5269 & 5273 &  \\
		$\{o_{0} .. o_{3}, \Re \}$ & $\{*, +, \wedge, \neg, \ggg\}$ & 5300 &  & 5274 & \\
		$\{o_{0} .. o_{3}, \Re \}$ & $\{*, \wedge, \ggg\}$ & 5306 & 5274 & 5270 & \\
		$\{o_{0} .. o_{3}, \Re \}$ & $\{+, \wedge, \ggg\}$ & 5290 & 5270 &  & \\
		$\{o_{0} .. o_{3}, \Re \}$ & $\{*, +, \wedge\}$ & 5298 & & & \\
		$\{o_{0} .. o_{3}, \Re \}$ & $\{+, \wedge\}$ & 5065 & & 5018 & \\
		\hline
	\end{tabular}
	\label{tab:basicRunAlternatives1}
\end{table}

\section{Ha¹ování s Merkle-Damg\r{a}rdovou konstrukcí}

\section{Kukaèèí ha¹ování}

\chapter{Závìr}
\input{conclusion}

%=========================================================================